<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Marcelo S. Perlin" />
  <meta name="date" content="2020-02-15" />
  <title>Analyzing Financial and Economic Data with R</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">
body
{
margin: 0 0 0 0;
padding: 0 0 0 0;
width: 100%;
height: 100%;
color: black;
background-color: white;
font-family: "Gill Sans MT", "Gill Sans", GillSans, sans-serif;
font-size: 14pt;
}
div.toolbar {
position: fixed; z-index: 200;
top: auto; bottom: 0; left: 0; right: 0;
height: 1.2em; text-align: right;
padding-left: 1em;
padding-right: 1em; font-size: 60%;
color: DimGray;
background-color: rgb(240,240,240);
border-top: solid 1px rgb(180,180,180);
}
div.toolbar span.copyright {
color: DimGray;
margin-left: 0.5em;
}
div.initial_prompt {
position: absolute;
z-index: 1000;
bottom: 1.2em;
width: 100%;
background-color: rgb(200,200,200);
opacity: 0.35;
background-color: rgb(200,200,200, 0.35);
cursor: pointer;
}
div.initial_prompt p.help {
text-align: center;
}
div.initial_prompt p.close {
text-align: right;
font-style: italic;
}
div.slidy_toc {
position: absolute;
z-index: 300;
width: 60%;
max-width: 30em;
height: 30em;
overflow: auto;
top: auto;
right: auto;
left: 4em;
bottom: 4em;
padding: 1em;
background: rgb(240,240,240);
border-style: solid;
border-width: 2px;
font-size: 60%;
}
div.slidy_toc .toc_heading {
text-align: center;
width: 100%;
margin: 0;
margin-bottom: 1em;
border-bottom-style: solid;
border-bottom-color: rgb(180,180,180);
border-bottom-width: 1px;
}
div.slide {
z-index: 20;
margin: 0 0 0 0;
padding-top: 0;
padding-bottom: 0;
padding-left: 20px;
padding-right: 20px;
border-width: 0;
clear: both;
top: 0;
bottom: 0;
left: 0;
right: 0;
line-height: 120%;
background-color: transparent;
}
div.background {
display: none;
}
div.handout {
margin-left: 20px;
margin-right: 20px;
}
div.slide.titlepage {
text-align: center;
}
div.slide.titlepage h1 {
padding-top: 10%;
margin-right: 0;
}
div.slide h1 {
padding-left: 0;
padding-right: 20pt;
padding-top: 4pt;
padding-bottom: 4pt;
margin-top: 0;
margin-left: 0;
margin-right: 60pt;
margin-bottom: 0.5em;
display: block; font-size: 160%;
line-height: 1.2em;
background: transparent;
}
@media screen and (max-device-width: 1024px)
{
div.slide { font-size: 100%; }
}
@media screen and (max-device-width: 800px)
{
div.slide { font-size: 200%; }
div.slidy_toc {
top: 1em;
left: 1em;
right: auto;
width: 80%;
font-size: 180%;
}
}
div.toc-heading {
width: 100%;
border-bottom: solid 1px rgb(180,180,180);
margin-bottom: 1em;
text-align: center;
}
img {
image-rendering: optimize-quality;
}
pre {
font-size: 80%;
font-weight: bold;
line-height: 120%;
padding-top: 0.2em;
padding-bottom: 0.2em;
padding-left: 1em;
padding-right: 1em;
border-style: solid;
border-left-width: 1em;
border-top-width: thin;
border-right-width: thin;
border-bottom-width: thin;
border-color: #95ABD0;
color: #00428C;
background-color: #E4E5E7;
}
li pre { margin-left: 0; }
blockquote { font-style: italic }
img { background-color: transparent }
p.copyright { font-size: smaller }
.center { text-align: center }
.footnote { font-size: smaller; margin-left: 2em; }
a img { border-width: 0; border-style: none }
a:visited { color: navy }
a:link { color: navy }
a:hover { color: red; text-decoration: underline }
a:active { color: red; text-decoration: underline }
a {text-decoration: none}
.toolbar a:link {color: blue}
.toolbar a:visited {color: blue}
.toolbar a:active {color: red}
.toolbar a:hover {color: red}
ul { list-style-type: square; }
ul ul { list-style-type: disc; }
ul ul ul { list-style-type: circle; }
ul ul ul ul { list-style-type: disc; }
li { margin-left: 0.5em; margin-top: 0.5em; }
li li { font-size: 85%; font-style: italic }
li li li { font-size: 85%; font-style: normal }
div dt
{
margin-left: 0;
margin-top: 1em;
margin-bottom: 0.5em;
font-weight: bold;
}
div dd
{
margin-left: 2em;
margin-bottom: 0.5em;
}
p,pre,ul,ol,blockquote,h2,h3,h4,h5,h6,dl,table {
margin-left: 1em;
margin-right: 1em;
}
p.subhead { font-weight: bold; margin-top: 2em; }
.smaller { font-size: smaller }
.bigger { font-size: 130% }
td,th { padding: 0.2em }
ul {
margin: 0.5em 1.5em 0.5em 1.5em;
padding: 0;
}
ol {
margin: 0.5em 1.5em 0.5em 1.5em;
padding: 0;
}
ul { list-style-type: square; }
ul ul { list-style-type: disc; }
ul ul ul { list-style-type: circle; }
ul ul ul ul { list-style-type: disc; }
ul li { list-style: square;
margin: 0.1em 0em 0.6em 0;
padding: 0 0 0 0;
line-height: 140%;
}
ol li { margin: 0.1em 0em 0.6em 1.5em;
padding: 0 0 0 0px;
line-height: 140%;
list-style-type: decimal;
}
li ul li { font-size: 85%; font-style: italic;
list-style-type: disc;
background: transparent;
padding: 0 0 0 0;
}
li li ul li { font-size: 85%; font-style: normal;
list-style-type: circle;
background: transparent;
padding: 0 0 0 0;
}
li li li ul li {
list-style-type: disc;
background: transparent;
padding: 0 0 0 0;
}
li ol li {
list-style-type: decimal;
}
li li ol li {
list-style-type: decimal;
}

ol.outline li:hover { cursor: pointer }
ol.outline li.nofold:hover { cursor: default }
ul.outline li:hover { cursor: pointer }
ul.outline li.nofold:hover { cursor: default }
ol.outline { list-style:decimal; }
ol.outline ol { list-style-type:lower-alpha }
ol.outline li.nofold {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAIACAMzMzOvr/ywAAAAACQAJAAACD4SPoRvG614Dctb4MEMcFAA7) no-repeat 0px 0.5em;
}
ol.outline li.unfolded {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAMPD/8zMzOvr/////ywAAAAACQAJAAACEYyPoivG614LAlg7ZZbxoR8UADs=) no-repeat 0px 0.5em;
}
ol.outline li.folded {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAMPD/8zMzOvr/////ywAAAAACQAJAAACFIyPoiu2sJyCyoF7W3hxz850CFIAADs=) no-repeat 0px 0.5em;
}
ol.outline li.unfolded:hover {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAAAAAAAA/8PD/////ywAAAAACQAJAAACEYSPoivG614DIlg7ZZbxoQ8UADs=) no-repeat 0px 0.5em;
}
ol.outline li.folded:hover {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAAAAAAAA/8PD/////ywAAAAACQAJAAACFISPoiu2sZyCyoV7G3hxz850CFIAADs=) no-repeat 0px 0.5em;
}
ul.outline li.nofold {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAIACAMzMzOvr/ywAAAAACQAJAAACD4SPoRvG614Dctb4MEMcFAA7) no-repeat 0px 0.5em;
}
ul.outline li.unfolded {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAMPD/8zMzOvr/////ywAAAAACQAJAAACEYyPoivG614LAlg7ZZbxoR8UADs=) no-repeat 0px 0.5em;
}
ul.outline li.folded {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAMPD/8zMzOvr/////ywAAAAACQAJAAACFIyPoiu2sJyCyoF7W3hxz850CFIAADs=) no-repeat 0px 0.5em;
}
ul.outline li.unfolded:hover {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAAAAAAAA/8PD/////ywAAAAACQAJAAACEYSPoivG614DIlg7ZZbxoQ8UADs=) no-repeat 0px 0.5em;
}
ul.outline li.folded:hover {
padding: 0 0 0 20px;
background: transparent url(data:image/gif;base64,R0lGODdhCQAJAKEDAAAAAAAA/8PD/////ywAAAAACQAJAAACFISPoiu2sZyCyoV7G3hxz850CFIAADs=) no-repeat 0px 0.5em;
}

a.titleslide { font-weight: bold; font-style: italic }

img.hidden { display: none; visibility: hidden }
div.initial_prompt { display: none; visibility: hidden }
div.slide {
visibility: visible;
position: inherit;
}
div.handout {
border-top-style: solid;
border-top-width: thin;
border-top-color: black;
}
@media screen {
.hidden { display: none; visibility: visible }
div.slide.hidden { display: block; visibility: visible }
div.handout.hidden { display: block; visibility: visible }
div.background { display: none; visibility: hidden }
body.single_slide div.initial_prompt { display: block; visibility: visible }
body.single_slide div.background { display: block; visibility: visible }
body.single_slide div.background.hidden { display: none; visibility: hidden }
body.single_slide .invisible { visibility: hidden }
body.single_slide .hidden { display: none; visibility: hidden }
body.single_slide div.slide { position: absolute }
body.single_slide div.handout { display: none; visibility: hidden }
}
@media print {
.hidden { display: block; visibility: visible }
div.slide pre { font-size: 60%; padding-left: 0.5em; }
div.toolbar { display: none; visibility: hidden; }
div.slidy_toc { display: none; visibility: hidden; }
div.background { display: none; visibility: hidden; }
div.slide { page-break-before: always }

div.slide.first-slide { page-break-before: avoid }
}


.jslider table {
margin-left: 0em;
margin-right: 0em;
}

table.dataTable, .shiny-datatable-output div {
font-size: 14pt;
}

.dataTables_info, .dataTables_paginate {
font-size: 19px;
}

pre.sourceCode, code.sourceCode {
font-size: 80%;
}

label, button, input, select, textarea {
font-size: 14pt;
}

ul.nav, ul.nav li {
list-style-type: none;
}
</style>
  <script src="data:application/javascript;base64,Lyogc2xpZHkuanMKCiAgIENvcHlyaWdodCAoYykgMjAwNS0yMDEzIFczQyAoTUlULCBFUkNJTSwgS2VpbyksIEFsbCBSaWdodHMgUmVzZXJ2ZWQuCiAgIFczQyBsaWFiaWxpdHksIHRyYWRlbWFyaywgZG9jdW1lbnQgdXNlIGFuZCBzb2Z0d2FyZSBsaWNlbnNpbmcKICAgcnVsZXMgYXBwbHksIHNlZToKCiAgIGh0dHA6Ly93d3cudzMub3JnL0NvbnNvcnRpdW0vTGVnYWwvY29weXJpZ2h0LWRvY3VtZW50cwogICBodHRwOi8vd3d3LnczLm9yZy9Db25zb3J0aXVtL0xlZ2FsL2NvcHlyaWdodC1zb2Z0d2FyZQoKICAgRGVmaW5lcyBzaW5nbGUgbmFtZSAidzNjX3NsaWR5IiBpbiBnbG9iYWwgbmFtZXNwYWNlCiAgIEFkZHMgZXZlbnQgaGFuZGxlcnMgd2l0aG91dCB0cmFtcGxpbmcgb24gYW55IG90aGVycwoqLwoKLy8gdGhlIHNsaWR5IG9iamVjdCBpbXBsZW1lbnRhdGlvbgp2YXIgdzNjX3NsaWR5ID0gewogIC8vIGNsYXNzaWZ5IHdoaWNoIGtpbmQgb2YgYnJvd3NlciB3ZSdyZSBydW5uaW5nIHVuZGVyCiAgbnNfcG9zOiAodHlwZW9mIHdpbmRvdy5wYWdlWU9mZnNldCE9J3VuZGVmaW5lZCcpLAogIGtodG1sOiAoKG5hdmlnYXRvci51c2VyQWdlbnQpLmluZGV4T2YoIktIVE1MIikgPj0gMCA/IHRydWUgOiBmYWxzZSksCiAgb3BlcmE6ICgobmF2aWdhdG9yLnVzZXJBZ2VudCkuaW5kZXhPZigiT3BlcmEiKSA+PSAwID8gdHJ1ZSA6IGZhbHNlKSwKICBpcGFkOiAoKG5hdmlnYXRvci51c2VyQWdlbnQpLmluZGV4T2YoImlQYWQiKSA+PSAwID8gdHJ1ZSA6IGZhbHNlKSwKICBpcGhvbmU6ICgobmF2aWdhdG9yLnVzZXJBZ2VudCkuaW5kZXhPZigiaVBob25lIikgPj0gMCA/IHRydWUgOiBmYWxzZSksCiAgYW5kcm9pZDogKChuYXZpZ2F0b3IudXNlckFnZW50KS5pbmRleE9mKCJBbmRyb2lkIikgPj0gMCA/IHRydWUgOiBmYWxzZSksCiAgaWU6ICh0eXBlb2YgZG9jdW1lbnQuYWxsICE9ICJ1bmRlZmluZWQiICYmICF0aGlzLm9wZXJhKSwKICBpZTY6ICghdGhpcy5uc19wb3MgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJNU0lFIDYiKSAhPSAtMSksCiAgaWU3OiAoIXRoaXMubnNfcG9zICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiTVNJRSA3IikgIT0gLTEpLAogIGllODogKCF0aGlzLm5zX3BvcyAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoIk1TSUUgOCIpICE9IC0xKSwKICBpZTk6ICghdGhpcy5uc19wb3MgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJNU0lFIDkiKSAhPSAtMSksCgogIC8vIGRhdGEgZm9yIHN3aXBlIGFuZCBkb3VibGUgdGFwIGRldGVjdGlvbiBvbiB0b3VjaCBzY3JlZW5zCiAgbGFzdF90YXA6IDAsCiAgcHJldl90YXA6IDAsCiAgc3RhcnRfeDogMCwKICBzdGFydF95OiAwLAogIGRlbHRhX3g6IDAsCiAgZGVsdGFfeTogMCwKCiAgLy8gYXJlIHdlIHJ1bm5pbmcgYXMgWEhUTUw/IChkb2Vzbid0IHdvcmsgb24gT3BlcmEpCiAgaXNfeGh0bWw6IC94bWwvLnRlc3QoZG9jdW1lbnQuY29udGVudFR5cGUpLAoKICBzbGlkZV9udW1iZXI6IDAsIC8vIGludGVnZXIgc2xpZGUgY291bnQ6IDAsIDEsIDIsIC4uLgogIHNsaWRlX251bWJlcl9lbGVtZW50OiBudWxsLCAvLyBlbGVtZW50IGNvbnRhaW5pbmcgc2xpZGUgbnVtYmVyCiAgc2xpZGVzOiBbXSwgLy8gc2V0IHRvIGFycmF5IG9mIHNsaWRlIGRpdidzCiAgbm90ZXM6IFtdLCAvLyBzZXQgdG8gYXJyYXkgb2YgaGFuZG91dCBkaXYncwogIGJhY2tncm91bmRzOiBbXSwgLy8gc2V0IHRvIGFycmF5IG9mIGJhY2tncm91bmQgZGl2J3MKICBvYnNlcnZlcnM6IFtdLCAvLyBsaXN0IG9mIG9ic2VydmVyIGZ1bmN0aW9ucwogIHRvb2xiYXI6IG51bGwsIC8vIGVsZW1lbnQgY29udGFpbmluZyB0b29sYmFyCiAgdGl0bGU6IG51bGwsIC8vIGRvY3VtZW50IHRpdGxlCiAgbGFzdF9zaG93bjogbnVsbCwgLy8gbGFzdCBpbmNyZW1lbnRhbGx5IHNob3duIGl0ZW0KICBlb3M6IG51bGwsICAvLyBzcGFuIGVsZW1lbnQgZm9yIGVuZCBvZiBzbGlkZSBpbmRpY2F0b3IKICB0b2M6IG51bGwsIC8vIHRhYmxlIG9mIGNvbnRlbnRzCiAgb3V0bGluZTogbnVsbCwgLy8gb3V0bGluZSBlbGVtZW50IHdpdGggdGhlIGZvY3VzCiAgc2VsZWN0ZWRfdGV4dF9sZW46IDAsIC8vIGxlbmd0aCBvZiBkcmFnIHNlbGVjdGlvbiBvbiBkb2N1bWVudAogIHZpZXdfYWxsOiAwLCAgLy8gMSB0byB2aWV3IGFsbCBzbGlkZXMgKyBoYW5kb3V0cwogIHdhbnRfdG9vbGJhcjogdHJ1ZSwgIC8vIHVzZXIgcHJlZmVyZW5jZSB0byBzaG93L2hpZGUgdG9vbGJhcgogIG1vdXNlX2NsaWNrX2VuYWJsZWQ6IHRydWUsIC8vIGVuYWJsZXMgbGVmdCBjbGljayBmb3IgbmV4dCBzbGlkZQogIHNjcm9sbF9oYWNrOiAwLCAvLyBJRSB3b3JrIGFyb3VuZCBmb3IgcG9zaXRpb246IGZpeGVkCiAgZGlzYWJsZV9zbGlkZV9jbGljazogZmFsc2UsICAvLyB1c2VkIGJ5IGNsaWNrZWQgYW5jaG9ycwoKICBsYW5nOiAiZW4iLCAvLyB1cGRhdGVkIHRvIGxhbmd1YWdlIHNwZWNpZmllZCBieSBodG1sIGZpbGUKCiAgaGVscF9hbmNob3I6IG51bGwsIC8vIHVzZWQgZm9yIGtleWJvYXJkIGZvY3VzIGhhY2sgaW4gc2hvd1Rvb2xiYXIoKQogIGhlbHBfcGFnZTogImh0dHA6Ly93d3cudzMub3JnL1RhbGtzL1Rvb2xzL1NsaWR5Mi9oZWxwL2hlbHAuaHRtbCIsCiAgaGVscF90ZXh0OiAiTmF2aWdhdGUgd2l0aCBtb3VzZSBjbGljaywgc3BhY2UgYmFyLCBDdXJzb3IgTGVmdC9SaWdodCwgIiArCiAgICAgICAgICAgICAib3IgUGcgVXAgYW5kIFBnIERuLiBVc2UgUyBhbmQgQiB0byBjaGFuZ2UgZm9udCBzaXplLiIsCgogIHNpemVfaW5kZXg6IDAsCiAgc2l6ZV9hZGp1c3RtZW50OiAwLAogIHNpemVzOiAgbmV3IEFycmF5KCIxMHB0IiwgIjEycHQiLCAiMTRwdCIsICIxNnB0IiwgIjE4cHQiLCAiMjBwdCIsCiAgICAgICAgICAgICAgICAgICAgIjIycHQiLCAiMjRwdCIsICIyNnB0IiwgIjI4cHQiLCAiMzBwdCIsICIzMnB0IiksCgogIC8vIG5lZWRlZCBmb3IgZWZmaWNpZW50IHJlc2l6aW5nCiAgbGFzdF93aWR0aDogMCwKICBsYXN0X2hlaWdodDogMCwKCgogIC8vIE5lZWRlZCBmb3IgY3Jvc3MgYnJvd3NlciBzdXBwb3J0IGZvciByZWxhdGl2ZSB3aWR0aC9oZWlnaHQgb24KICAvLyBvYmplY3QgZWxlbWVudHMuIFRoZSB3b3JrIGFyb3VuZCBpcyB0byBzYXZlIHdpZHRoL2hlaWdodCBhdHRyaWJ1dGVzCiAgLy8gYW5kIHRoZW4gdG8gcmVjb21wdXRlIGFic29sdXRlIHdpZHRoL2hlaWdodCBkaW1lbnNpb25zIG9uIHJlc2l6aW5nCiAgIG9iamVjdHM6IFtdLAoKICAvLyBhdHRhY2ggaW5pdGlhbGlhdGlvbiBldmVudCBoYW5kbGVycwogIHNldF91cDogZnVuY3Rpb24gKCkgewogICAgdmFyIGluaXQgPSBmdW5jdGlvbigpIHsgdzNjX3NsaWR5LmluaXQoKTsgfTsKICAgIGlmICh0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT0gInVuZGVmaW5lZCIpCiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCJsb2FkIiwgaW5pdCwgZmFsc2UpOwogICAgZWxzZQogICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoIm9ubG9hZCIsIGluaXQpOwogIH0sCgogIGhpZGVfc2xpZGVzOiBmdW5jdGlvbiAoKSB7CiAgICBpZiAoZG9jdW1lbnQuYm9keSAmJiAhdzNjX3NsaWR5LmluaXRpYWxpemVkKQogICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnZpc2liaWxpdHkgPSAiaGlkZGVuIjsKICAgIGVsc2UKICAgICAgc2V0VGltZW91dCh3M2Nfc2xpZHkuaGlkZV9zbGlkZXMsIDUwKTsKICB9LAoKICAvLyBoYWNrIHRvIHBlcnN1YWRlIElFIHRvIGNvbXB1dGUgY29ycmVjdCBkb2N1bWVudCBoZWlnaHQKICAvLyBhcyBuZWVkZWQgZm9yIHNpbXVsYXRpbmcgZml4ZWQgcG9zaXRpb25pbmcgb2YgdG9vbGJhcgogIGllX2hhY2s6IGZ1bmN0aW9uICgpIHsKICAgIHdpbmRvdy5yZXNpemVCeSgwLC0xKTsKICAgIHdpbmRvdy5yZXNpemVCeSgwLCAxKTsKICB9LAoKICBpbml0OiBmdW5jdGlvbiAoKSB7CiAgICAvL2FsZXJ0KCJzbGlkeSBzdGFydGluZyB0ZXN0IDEwIik7CiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnZpc2liaWxpdHkgPSAidmlzaWJsZSI7CiAgICB0aGlzLmluaXRfbG9jYWxpemF0aW9uKCk7CiAgICB0aGlzLmFkZF90b29sYmFyKCk7CiAgICB0aGlzLndyYXBfaW1wbGljaXRfc2xpZGVzKCk7CiAgICB0aGlzLmNvbGxlY3Rfc2xpZGVzKCk7CiAgICB0aGlzLmNvbGxlY3Rfbm90ZXMoKTsKICAgIHRoaXMuY29sbGVjdF9iYWNrZ3JvdW5kcygpOwogICAgdGhpcy5vYmplY3RzID0gZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5VGFnTmFtZSgib2JqZWN0Iik7CiAgICB0aGlzLnBhdGNoX2FuY2hvcnMoKTsKICAgIHRoaXMuc2xpZGVfbnVtYmVyID0gdGhpcy5maW5kX3NsaWRlX251bWJlcihsb2NhdGlvbi5ocmVmKTsKICAgIHdpbmRvdy5vZmZzY3JlZW5idWZmZXJpbmcgPSB0cnVlOwogICAgdGhpcy5zaXplX2FkanVzdG1lbnQgPSB0aGlzLmZpbmRfc2l6ZV9hZGp1c3QoKTsKICAgIHRoaXMudGltZV9sZWZ0ID0gdGhpcy5maW5kX2R1cmF0aW9uKCk7CiAgICB0aGlzLmhpZGVfaW1hZ2VfdG9vbGJhcigpOyAgLy8gc3VwcHJlc3MgSUUgaW1hZ2UgdG9vbGJhciBwb3B1cAogICAgdGhpcy5pbml0X291dGxpbmVyKCk7ICAvLyBhY3RpdmF0ZSBmb2xkL3VuZm9sZCBzdXBwb3J0CiAgICB0aGlzLnRpdGxlID0gZG9jdW1lbnQudGl0bGU7CiAgICB0aGlzLmtleWJvYXJkbGVzcyA9ICh0aGlzLmlwYWR8fHRoaXMuaXBob25lfHx0aGlzLmFuZHJvaWQpOwoKICAgIGlmICh0aGlzLmtleWJvYXJkbGVzcykKICAgIHsKICAgICAgdzNjX3NsaWR5LnJlbW92ZV9jbGFzcyh3M2Nfc2xpZHkudG9vbGJhciwgImhpZGRlbiIpCiAgICAgIHRoaXMud2FudF90b29sYmFyID0gMDsKICAgIH0KCiAgICAvLyB3b3JrIGFyb3VuZCBmb3Igb3BlcmEgYnVnCiAgICB0aGlzLmlzX3hodG1sID0gKGRvY3VtZW50LmJvZHkudGFnTmFtZSA9PSAiQk9EWSIgPyBmYWxzZSA6IHRydWUpOwoKICAgIGlmICh0aGlzLnNsaWRlcy5sZW5ndGggPiAwKQogICAgewogICAgICB2YXIgc2xpZGUgPSB0aGlzLnNsaWRlc1t0aGlzLnNsaWRlX251bWJlcl07CiAgIAogICAgICBpZiAodGhpcy5zbGlkZV9udW1iZXIgPiAwKQogICAgICB7CiAgICAgICAgdGhpcy5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoInZpc2libGUiKTsKICAgICAgICB0aGlzLmxhc3Rfc2hvd24gPSB0aGlzLnByZXZpb3VzX2luY3JlbWVudGFsX2l0ZW0obnVsbCk7CiAgICAgICAgdGhpcy5zZXRfZW9zX3N0YXR1cyh0cnVlKTsKICAgICAgfQogICAgICBlbHNlCiAgICAgIHsKICAgICAgICB0aGlzLmxhc3Rfc2hvd24gPSBudWxsOwogICAgICAgIHRoaXMuc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsKCJoaWRkZW4iKTsKICAgICAgICB0aGlzLnNldF9lb3Nfc3RhdHVzKCF0aGlzLm5leHRfaW5jcmVtZW50YWxfaXRlbSh0aGlzLmxhc3Rfc2hvd24pKTsKICAgICAgfQoKICAgICAgdGhpcy5zZXRfbG9jYXRpb24oKTsKICAgICAgdGhpcy5hZGRfY2xhc3ModGhpcy5zbGlkZXNbMF0sICJmaXJzdC1zbGlkZSIpOwogICAgICB3M2Nfc2xpZHkuc2hvd19zbGlkZShzbGlkZSk7CiAgICB9CgogICAgdGhpcy50b2MgPSB0aGlzLnRhYmxlX29mX2NvbnRlbnRzKCk7CgogICAgdGhpcy5hZGRfaW5pdGlhbF9wcm9tcHQoKTsKCiAgICAvLyBiaW5kIGV2ZW50IGhhbmRsZXJzIHdpdGhvdXQgaW50ZXJmZXJpbmcgd2l0aCBjdXN0b20gcGFnZSBzY3JpcHRzCiAgICAvLyBUYXAgZXZlbnRzIGJlaGF2ZSB0b28gd2VpcmRseSB0byBzdXBwb3J0IGNsaWNrcyByZWxpYWJseSBvbgogICAgLy8gaVBob25lIGFuZCBpUGFkLCBzbyBleGNsdWRlIHRoZXNlIGZyb20gY2xpY2sgaGFuZGxlcgoKICAgIGlmICghdGhpcy5rZXlib2FyZGxlc3MpCiAgICB7CiAgICAgIHRoaXMuYWRkX2xpc3RlbmVyKGRvY3VtZW50LmJvZHksICJjbGljayIsIHRoaXMubW91c2VfYnV0dG9uX2NsaWNrKTsKICAgICAgdGhpcy5hZGRfbGlzdGVuZXIoZG9jdW1lbnQuYm9keSwgIm1vdXNlZG93biIsIHRoaXMubW91c2VfYnV0dG9uX2Rvd24pOwogICAgfQoKICAgIHRoaXMuYWRkX2xpc3RlbmVyKGRvY3VtZW50LCAia2V5ZG93biIsIHRoaXMua2V5X2Rvd24pOwogICAgdGhpcy5hZGRfbGlzdGVuZXIoZG9jdW1lbnQsICJrZXlwcmVzcyIsIHRoaXMua2V5X3ByZXNzKTsKICAgIHRoaXMuYWRkX2xpc3RlbmVyKHdpbmRvdywgInJlc2l6ZSIsIHRoaXMucmVzaXplZCk7CiAgICB0aGlzLmFkZF9saXN0ZW5lcih3aW5kb3csICJzY3JvbGwiLCB0aGlzLnNjcm9sbGVkKTsKICAgIHRoaXMuYWRkX2xpc3RlbmVyKHdpbmRvdywgInVubG9hZCIsIHRoaXMudW5sb2FkZWQpOwoKICAgIHRoaXMuYWRkX2xpc3RlbmVyKGRvY3VtZW50LCAiZ2VzdHVyZWNoYW5nZSIsIGZ1bmN0aW9uICgpCiAgICB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0pOwoKICAgIHRoaXMuYXR0YWNoX3RvdWNoX2hhbmRlcnModGhpcy5zbGlkZXMpOwoKICAgIC8vIHRoaXMgc2VlbXMgdG8gYmUgYSBkZWJ1Z2dpbmcgaGFjawogICAgLy9pZiAoIWRvY3VtZW50LmJvZHkub25jbGljaykKICAgIC8vICBkb2N1bWVudC5ib2R5Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7IH07CgogICAgdGhpcy5zaW5nbGVfc2xpZGVfdmlldygpOwoKICAgIC8vdGhpcy5zZXRfbG9jYXRpb24oKTsKCiAgICB0aGlzLnJlc2l6ZWQoKTsKCiAgICBpZiAodGhpcy5pZTcpCiAgICAgIHNldFRpbWVvdXQodzNjX3NsaWR5LmllX2hhY2ssIDEwMCk7CgogICAgdGhpcy5zaG93X3Rvb2xiYXIoKTsKCiAgICAvLyBmb3IgYmFjayBidXR0b24gZGV0ZWN0aW9uCiAgICBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IHczY19zbGlkeS5jaGVja19sb2NhdGlvbigpOyB9LCAyMDApOwogICAgdzNjX3NsaWR5LmluaXRpYWxpemVkID0gdHJ1ZTsKICB9LAoKICAvLyBjcmVhdGUgZGl2IGVsZW1lbnQgd2l0aCBsaW5rcyB0byBlYWNoIHNsaWRlCiAgdGFibGVfb2ZfY29udGVudHM6IGZ1bmN0aW9uICgpIHsKICAgIHZhciB0b2MgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJkaXYiKTsKICAgIHRoaXMuYWRkX2NsYXNzKHRvYywgInNsaWR5X3RvYyBoaWRkZW4iKTsKICAgIC8vdG9jLnNldEF0dHJpYnV0ZSgidGFiaW5kZXgiLCAiMCIpOwoKICAgIHZhciBoZWFkaW5nID0gdGhpcy5jcmVhdGVfZWxlbWVudCgiZGl2Iik7CiAgICB0aGlzLmFkZF9jbGFzcyhoZWFkaW5nLCAidG9jLWhlYWRpbmciKTsKICAgIGhlYWRpbmcuaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgiVGFibGUgb2YgQ29udGVudHMiKTsKCiAgICB0b2MuYXBwZW5kQ2hpbGQoaGVhZGluZyk7CiAgICB2YXIgcHJldmlvdXMgPSBudWxsOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zbGlkZXMubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIHZhciB0aXRsZSA9IHRoaXMuaGFzX2NsYXNzKHRoaXMuc2xpZGVzW2ldLCAidGl0bGUiKTsKICAgICAgdmFyIG51bSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKChpICsgMSkgKyAiLiAiKTsKCiAgICAgIHRvYy5hcHBlbmRDaGlsZChudW0pOwoKICAgICAgdmFyIGEgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJhIik7CiAgICAgIGEuc2V0QXR0cmlidXRlKCJocmVmIiwgIiMoIiArIChpKzEpICsgIikiKTsKCiAgICAgIGlmICh0aXRsZSkKICAgICAgICB0aGlzLmFkZF9jbGFzcyhhLCAidGl0bGVzbGlkZSIpOwoKICAgICAgdmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnNsaWRlX25hbWUoaSkpOwogICAgICBhLmFwcGVuZENoaWxkKG5hbWUpOwogICAgICBhLm9uY2xpY2sgPSB3M2Nfc2xpZHkudG9jX2NsaWNrOwogICAgICBhLm9ua2V5ZG93biA9IHczY19zbGlkeS50b2Nfa2V5X2Rvd247CiAgICAgIGEucHJldmlvdXMgPSBwcmV2aW91czsKCiAgICAgIGlmIChwcmV2aW91cykKICAgICAgICBwcmV2aW91cy5uZXh0ID0gYTsKCiAgICAgIHRvYy5hcHBlbmRDaGlsZChhKTsKCiAgICAgIGlmIChpID09IDApCiAgICAgICAgdG9jLmZpcnN0ID0gYTsKCiAgICAgIGlmIChpIDwgdGhpcy5zbGlkZXMubGVuZ3RoIC0gMSkKICAgICAgewogICAgICAgIHZhciBiciA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImJyIik7CiAgICAgICAgdG9jLmFwcGVuZENoaWxkKGJyKTsKICAgICAgfQoKICAgICAgcHJldmlvdXMgPSBhOwogICAgfQoKICAgIHRvYy5mb2N1cyA9IGZ1bmN0aW9uICgpIHsKICAgICAgaWYgKHRoaXMuZmlyc3QpCiAgICAgICAgdGhpcy5maXJzdC5mb2N1cygpOwogICAgfQoKICAgIHRvYy5vbm1vdXNldXAgPSB3M2Nfc2xpZHkubW91c2VfYnV0dG9uX3VwOwoKICAgIHRvYy5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHsKICAgICAgZXx8KGU9d2luZG93LmV2ZW50KTsKCiAgICAgIGlmICh3M2Nfc2xpZHkuc2VsZWN0ZWRfdGV4dF9sZW4gPD0gMCkKICAgICAgICAgdzNjX3NsaWR5LmhpZGVfdGFibGVfb2ZfY29udGVudHModHJ1ZSk7CgogICAgICB3M2Nfc2xpZHkuc3RvcF9wcm9wYWdhdGlvbihlKTsKICAgIAogICAgICBpZiAoZS5jYW5jZWwgIT0gdW5kZWZpbmVkKQogICAgICAgIGUuY2FuY2VsID0gdHJ1ZTsKICAgICAgCiAgICAgIGlmIChlLnJldHVyblZhbHVlICE9IHVuZGVmaW5lZCkKICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7CiAgICAgIAogICAgICByZXR1cm4gZmFsc2U7CiAgICB9OwoKICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKHRvYywgZG9jdW1lbnQuYm9keS5maXJzdENoaWxkKTsKICAgIHJldHVybiB0b2M7CiAgfSwKCiAgaXNfc2hvd25fdG9jOiBmdW5jdGlvbiAoKSB7CiAgICByZXR1cm4gIXczY19zbGlkeS5oYXNfY2xhc3ModzNjX3NsaWR5LnRvYywgImhpZGRlbiIpOwogIH0sCgogIHNob3dfdGFibGVfb2ZfY29udGVudHM6IGZ1bmN0aW9uICgpIHsKICAgIHczY19zbGlkeS5yZW1vdmVfY2xhc3ModzNjX3NsaWR5LnRvYywgImhpZGRlbiIpOwogICAgdmFyIHRvYyA9IHczY19zbGlkeS50b2M7CiAgICB0b2MuZm9jdXMoKTsKCiAgICBpZiAodzNjX3NsaWR5LmllNyAmJiB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyID09IDApCiAgICAgIHNldFRpbWVvdXQodzNjX3NsaWR5LmllX2hhY2ssIDEwMCk7CiAgfSwKCiAgaGlkZV90YWJsZV9vZl9jb250ZW50czogZnVuY3Rpb24gKGZvY3VzKSB7CiAgICB3M2Nfc2xpZHkuYWRkX2NsYXNzKHczY19zbGlkeS50b2MsICJoaWRkZW4iKTsKCiAgICBpZiAoZm9jdXMgJiYgIXczY19zbGlkeS5vcGVyYSAmJgogICAgICAgICF3M2Nfc2xpZHkuaGFzX2NsYXNzKHczY19zbGlkeS50b2MsICJoaWRkZW4iKSkKICAgICAgdzNjX3NsaWR5LnNldF9mb2N1cygpOwogIH0sCgogIHRvZ2dsZV90YWJsZV9vZl9jb250ZW50czogZnVuY3Rpb24gKCkgewogICAgaWYgKHczY19zbGlkeS5pc19zaG93bl90b2MoKSkKICAgICAgdzNjX3NsaWR5LmhpZGVfdGFibGVfb2ZfY29udGVudHModHJ1ZSk7CiAgICBlbHNlCiAgICAgIHczY19zbGlkeS5zaG93X3RhYmxlX29mX2NvbnRlbnRzKCk7CiAgfSwKCiAgLy8gY2FsbGVkIG9uIGNsaWNraW5nIHRvYyBlbnRyeQogIHRvY19jbGljazogZnVuY3Rpb24gKGUpIHsKICAgIGlmICghZSkKICAgICAgZSA9IHdpbmRvdy5ldmVudDsKCiAgICB2YXIgdGFyZ2V0ID0gdzNjX3NsaWR5LmdldF90YXJnZXQoZSk7CgogICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZVR5cGUgPT0gMSkKICAgIHsKICAgICAgdmFyIHVyaSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoImhyZWYiKTsKCiAgICAgIGlmICh1cmkpCiAgICAgIHsKICAgICAgICAvL2FsZXJ0KCJnb2luZyB0byAiICsgdXJpKTsKICAgICAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgIHczY19zbGlkeS5oaWRlX3NsaWRlKHNsaWRlKTsKICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyID0gdzNjX3NsaWR5LmZpbmRfc2xpZGVfbnVtYmVyKHVyaSk7CiAgICAgICAgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgIHczY19zbGlkeS5sYXN0X3Nob3duID0gbnVsbDsKICAgICAgICB3M2Nfc2xpZHkuc2V0X2xvY2F0aW9uKCk7CiAgICAgICAgdzNjX3NsaWR5LnNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbCgiaGlkZGVuIik7CiAgICAgICAgdzNjX3NsaWR5LnNldF9lb3Nfc3RhdHVzKCF3M2Nfc2xpZHkubmV4dF9pbmNyZW1lbnRhbF9pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKSk7CiAgICAgICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgICAgIC8vdGFyZ2V0LmZvY3VzKCk7CgogICAgICAgIHRyeQogICAgICAgIHsKICAgICAgICAgIGlmICghdzNjX3NsaWR5Lm9wZXJhKQogICAgICAgICAgICB3M2Nfc2xpZHkuc2V0X2ZvY3VzKCk7CiAgICAgICAgfQogICAgICAgIGNhdGNoIChlKQogICAgICAgIHsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICB3M2Nfc2xpZHkuaGlkZV90YWJsZV9vZl9jb250ZW50cyh0cnVlKTsKICAgIGlmICh3M2Nfc2xpZHkuaWU3KSB3M2Nfc2xpZHkuaWVfaGFjaygpOwogICAgdzNjX3NsaWR5LnN0b3BfcHJvcGFnYXRpb24oZSk7CiAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChlKTsKICB9LAoKICAvLyBjYWxsZWQgb25rZXlkb3duIGZvciB0b2MgZW50cnkKICB0b2Nfa2V5X2Rvd246IGZ1bmN0aW9uIChldmVudCkgewogICAgdmFyIGtleTsKCiAgICBpZiAoIWV2ZW50KQogICAgICB2YXIgZXZlbnQgPSB3aW5kb3cuZXZlbnQ7CgogICAgLy8ga2x1ZGdlIGFyb3VuZCBOUy9JRSBkaWZmZXJlbmNlcyAKICAgIGlmICh3aW5kb3cuZXZlbnQpCiAgICAgIGtleSA9IHdpbmRvdy5ldmVudC5rZXlDb2RlOwogICAgZWxzZSBpZiAoZXZlbnQud2hpY2gpCiAgICAgIGtleSA9IGV2ZW50LndoaWNoOwogICAgZWxzZQogICAgICByZXR1cm4gdHJ1ZTsgLy8gWWlrZXMhIHVua25vd24gYnJvd3NlcgoKICAgIC8vIGlnbm9yZSBldmVudCBpZiBrZXkgdmFsdWUgaXMgemVybwogICAgLy8gYXMgZm9yIGFsdCBvbiBPcGVyYSBhbmQgS29ucXVlcm9yCiAgICBpZiAoIWtleSkKICAgICAgcmV0dXJuIHRydWU7CgogICAgLy8gY2hlY2sgZm9yIGNvbmN1cnJlbnQgY29udHJvbC9jb21tYW5kL2FsdCBrZXkKICAgIC8vIGJ1dCBhcmUgdGhlc2Ugb25seSBwcmVzZW50IG9uIG1vdXNlIGV2ZW50cz8KCiAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkpCiAgICAgIHJldHVybiB0cnVlOwoKICAgIGlmIChrZXkgPT0gMTMpCiAgICB7CiAgICAgIHZhciB1cmkgPSB0aGlzLmdldEF0dHJpYnV0ZSgiaHJlZiIpOwoKICAgICAgaWYgKHVyaSkKICAgICAgewogICAgICAgIC8vYWxlcnQoImdvaW5nIHRvICIgKyB1cmkpOwogICAgICAgdmFyIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICB3M2Nfc2xpZHkuaGlkZV9zbGlkZShzbGlkZSk7CiAgICAgICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IHczY19zbGlkeS5maW5kX3NsaWRlX251bWJlcih1cmkpOwogICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICB3M2Nfc2xpZHkubGFzdF9zaG93biA9IG51bGw7CiAgICAgICAgdzNjX3NsaWR5LnNldF9sb2NhdGlvbigpOwogICAgICAgIHczY19zbGlkeS5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoImhpZGRlbiIpOwogICAgICAgIHczY19zbGlkeS5zZXRfZW9zX3N0YXR1cyghdzNjX3NsaWR5Lm5leHRfaW5jcmVtZW50YWxfaXRlbSh3M2Nfc2xpZHkubGFzdF9zaG93bikpOwogICAgICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgICAvL3RhcmdldC5mb2N1cygpOwoKICAgICAgICB0cnkKICAgICAgICB7CiAgICAgICAgICBpZiAoIXczY19zbGlkeS5vcGVyYSkKICAgICAgICAgICAgdzNjX3NsaWR5LnNldF9mb2N1cygpOwogICAgICAgIH0KICAgICAgICBjYXRjaCAoZSkKICAgICAgICB7CiAgICAgICAgfQogICAgICB9CgogICAgICB3M2Nfc2xpZHkuaGlkZV90YWJsZV9vZl9jb250ZW50cyh0cnVlKTsKCiAgICAgIGlmIChzZWxmLmllNykKICAgICAgIHczY19zbGlkeS5pZV9oYWNrKCk7CgogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CgogICAgaWYgKGtleSA9PSA0MCAmJiB0aGlzLm5leHQpCiAgICB7CiAgICAgIHRoaXMubmV4dC5mb2N1cygpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CgogICAgaWYgKGtleSA9PSAzOCAmJiB0aGlzLnByZXZpb3VzKQogICAgewogICAgICB0aGlzLnByZXZpb3VzLmZvY3VzKCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KCiAgICByZXR1cm4gdHJ1ZTsKICB9LAoKICB0b3VjaHN0YXJ0OiBmdW5jdGlvbiAoZSkKICB7CiAgICAvLyBhIGRvdWJsZSB0b3VjaCBvZnRlbiBzdGFydHMgd2l0aCBhCiAgICAvLyBzaW5nbGUgdG91Y2ggZHVlIHRvIGZpbmdlcnMgdG91Y2hpbmcKICAgIC8vIGRvd24gYXQgc2xpZ2h0bHkgZGlmZmVyZW50IHRpbWVzCiAgICAvLyB0aHVzIGF2b2lkIGNhbGxpbmcgcHJldmVudERlZmF1bHQgaGVyZQogICAgdGhpcy5wcmV2X3RhcCA9IHRoaXMubGFzdF90YXA7CiAgICB0aGlzLmxhc3RfdGFwID0gKG5ldyBEYXRlKS5nZXRUaW1lKCk7CgogICAgdmFyIHRhcF9kZWxheSA9IHRoaXMubGFzdF90YXAgLSB0aGlzLnByZXZfdGFwOwoKICAgIGlmICh0YXBfZGVsYXkgPD0gMjAwKQogICAgewogICAgICAvLyBkb3VibGUgdGFwCiAgICB9CgogICAgdmFyIHRvdWNoID0gZS50b3VjaGVzWzBdOwoKICAgIHRoaXMucGFnZVggPSB0b3VjaC5wYWdlWDsKICAgIHRoaXMucGFnZVkgPSB0b3VjaC5wYWdlWTsKICAgIHRoaXMuc2NyZWVuWCA9IHRvdWNoLnNjcmVlblg7CiAgICB0aGlzLnNjcmVlblkgPSB0b3VjaC5zY3JlZW5ZOwogICAgdGhpcy5jbGllbnRYID0gdG91Y2guY2xpZW50WDsKICAgIHRoaXMuY2xpZW50WSA9IHRvdWNoLmNsaWVudFk7CgogICAgdGhpcy5kZWx0YV94ID0gdGhpcy5kZWx0YV95ID0gMDsKICB9LAoKICB0b3VjaG1vdmU6IGZ1bmN0aW9uIChlKQogIHsKICAgIC8vIG92ZXJyaWRlIG5hdGl2ZSBnZXN0dXJlcyBmb3Igc2luZ2xlIHRvdWNoCiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpCiAgICAgIHJldHVybjsKCiAgICBlLnByZXZlbnREZWZhdWx0KCk7CiAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXNbMF07CiAgICB0aGlzLmRlbHRhX3ggPSB0b3VjaC5wYWdlWCAtIHRoaXMucGFnZVg7CiAgICB0aGlzLmRlbHRhX3kgPSB0b3VjaC5wYWdlWSAtIHRoaXMucGFnZVk7CiAgfSwKCiAgdG91Y2hlbmQ6IGZ1bmN0aW9uIChlKQogIHsKICAgIC8vIGRlZmF1bHQgYmVoYXZpb3IgZm9yIG11bHRpLXRvdWNoCiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpCiAgICAgIHJldHVybjsKCiAgICB2YXIgZGVsYXkgPSAobmV3IERhdGUpLmdldFRpbWUoKSAtIHRoaXMubGFzdF90YXA7CiAgICB2YXIgZHggPSB0aGlzLmRlbHRhX3g7CiAgICB2YXIgZHkgPSB0aGlzLmRlbHRhX3k7CiAgICB2YXIgYWJzX2R4ID0gTWF0aC5hYnMoZHgpOwogICAgdmFyIGFic19keSA9IE1hdGguYWJzKGR5KTsKCiAgICBpZiAoZGVsYXkgPCA1MDAgJiYgKGFic19keCA+IDEwMCB8fCBhYnNfZHkgPiAxMDApKQogICAgewogICAgICBpZiAoYWJzX2R4ID4gMC41ICogYWJzX2R5KQogICAgICB7CiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOwoKICAgICAgICBpZiAoZHggPCAwKQogICAgICAgICAgdzNjX3NsaWR5Lm5leHRfc2xpZGUodHJ1ZSk7CiAgICAgICAgZWxzZQogICAgICAgICAgdzNjX3NsaWR5LnByZXZpb3VzX3NsaWRlKHRydWUpOwogICAgICB9CiAgICAgIGVsc2UgaWYgKGFic19keSA+IDIgKiBhYnNfZHgpCiAgICAgIHsKICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7CiAgICAgICAgdzNjX3NsaWR5LnRvZ2dsZV90YWJsZV9vZl9jb250ZW50cygpOwogICAgICB9CiAgICB9CiAgfSwKCiAgLy8gIyMjIE9CU09MRVRFICMjIwogIGJlZm9yZV9wcmludDogZnVuY3Rpb24gKCkgewogICAgdGhpcy5zaG93X2FsbF9zbGlkZXMoKTsKICAgIHRoaXMuaGlkZV90b29sYmFyKCk7CiAgICBhbGVydCgiYmVmb3JlIHByaW50Iik7CiAgfSwKCiAgLy8gIyMjIE9CU09MRVRFICMjIwogIGFmdGVyX3ByaW50OiBmdW5jdGlvbiAoKSB7CiAgICBpZiAoIXRoaXMudmlld19hbGwpCiAgICB7CiAgICAgIHRoaXMuc2luZ2xlX3NsaWRlX3ZpZXcoKTsKICAgICAgdGhpcy5zaG93X3Rvb2xiYXIoKTsKICAgIH0KICAgIGFsZXJ0KCJhZnRlciBwcmludCIpOwogIH0sCgogIC8vICMjIyBPQlNPTEVURSAjIyMKICBwcmludF9zbGlkZXM6IGZ1bmN0aW9uICgpIHsKICAgIHRoaXMuYmVmb3JlX3ByaW50KCk7CiAgICB3aW5kb3cucHJpbnQoKTsKICAgIHRoaXMuYWZ0ZXJfcHJpbnQoKTsKICB9LAoKICAvLyAjIyMgT0JTT0xFVEUgPz8gIyMjCiAgdG9nZ2xlX3ZpZXc6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh0aGlzLnZpZXdfYWxsKQogICAgewogICAgICB0aGlzLnNpbmdsZV9zbGlkZV92aWV3KCk7CiAgICAgIHRoaXMuc2hvd190b29sYmFyKCk7CiAgICAgIHRoaXMudmlld19hbGwgPSAwOwogICAgfQogICAgZWxzZQogICAgewogICAgICB0aGlzLnNob3dfYWxsX3NsaWRlcygpOwogICAgICB0aGlzLmhpZGVfdG9vbGJhcigpOwogICAgICB0aGlzLnZpZXdfYWxsID0gMTsKICAgIH0KICB9LAoKICAvLyBwcmVwYXJlIGZvciBwcmludGluZyAgIyMjIE9CU09MRVRFICMjIwogIHNob3dfYWxsX3NsaWRlczogZnVuY3Rpb24gKCkgewogICAgdGhpcy5yZW1vdmVfY2xhc3MoZG9jdW1lbnQuYm9keSwgInNpbmdsZV9zbGlkZSIpOwogICAgdGhpcy5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoInZpc2libGUiKTsKICB9LAoKICAvLyByZXN0b3JlIGFmdGVyIHByaW50aW5nICAjIyMgT0JTT0xFVEUgIyMjCiAgc2luZ2xlX3NsaWRlX3ZpZXc6IGZ1bmN0aW9uICgpIHsKICAgIHRoaXMuYWRkX2NsYXNzKGRvY3VtZW50LmJvZHksICJzaW5nbGVfc2xpZGUiKTsKICAgIHRoaXMuc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsKCJ2aXNpYmxlIik7CiAgICB0aGlzLmxhc3Rfc2hvd24gPSB0aGlzLnByZXZpb3VzX2luY3JlbWVudGFsX2l0ZW0obnVsbCk7CiAgfSwKCiAgLy8gc3VwcHJlc3MgSUUncyBpbWFnZSB0b29sYmFyIHBvcCB1cAogIGhpZGVfaW1hZ2VfdG9vbGJhcjogZnVuY3Rpb24gKCkgewogICAgaWYgKCF0aGlzLm5zX3BvcykKICAgIHsKICAgICAgdmFyIGltYWdlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJJTUciKTsKCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1hZ2VzLmxlbmd0aDsgKytpKQogICAgICAgIGltYWdlc1tpXS5zZXRBdHRyaWJ1dGUoImdhbGxlcnlpbWciLCAibm8iKTsKICAgIH0KICB9LAoKICB1bmxvYWRlZDogZnVuY3Rpb24gKGUpIHsKICAgIC8vYWxlcnQoInVubG9hZGVkIik7CiAgfSwKCiAgLy8gU2FmYXJpIGFuZCBLb25xdWVyb3IgZG9uJ3QgeWV0IHN1cHBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSgpCiAgLy8gYW5kIHRoZXkgYWx3YXlzIHJlbG9hZCBwYWdlIHdoZW4gbG9jYXRpb24uaHJlZiBpcyB1cGRhdGVkCiAgaXNfS0hUTUw6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBhZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7CiAgICByZXR1cm4gKGFnZW50LmluZGV4T2YoIktIVE1MIikgPj0gMCA/IHRydWUgOiBmYWxzZSk7CiAgfSwKCiAgLy8gZmluZCBzbGlkZSBuYW1lIGZyb20gZmlyc3QgaDEgZWxlbWVudAogIC8vIGRlZmF1bHQgdG8gZG9jdW1lbnQgdGl0bGUgKyBzbGlkZSBudW1iZXIKICBzbGlkZV9uYW1lOiBmdW5jdGlvbiAoaW5kZXgpIHsKICAgIHZhciBuYW1lID0gbnVsbDsKICAgIHZhciBzbGlkZSA9IHRoaXMuc2xpZGVzW2luZGV4XTsKCiAgICB2YXIgaGVhZGluZyA9IHRoaXMuZmluZF9oZWFkaW5nKHNsaWRlKTsKCiAgICBpZiAoaGVhZGluZykKICAgICAgbmFtZSA9IHRoaXMuZXh0cmFjdF90ZXh0KGhlYWRpbmcpOwoKICAgIGlmICghbmFtZSkKICAgICAgbmFtZSA9IHRoaXMudGl0bGUgKyAiKCIgKyAoaW5kZXggKyAxKSArICIpIjsKCiAgICBuYW1lLnJlcGxhY2UoL1wmL2csICImYW1wOyIpOwogICAgbmFtZS5yZXBsYWNlKC9cPC9nLCAiJmx0OyIpOwogICAgbmFtZS5yZXBsYWNlKC9cPi9nLCAiJmd0OyIpOwoKICAgIHJldHVybiBuYW1lOwogIH0sCgogIC8vIGZpbmQgZmlyc3QgaDEgZWxlbWVudCBpbiBET00gdHJlZQogIGZpbmRfaGVhZGluZzogZnVuY3Rpb24gKG5vZGUpIHsKICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlICE9IDEpCiAgICAgIHJldHVybiBudWxsOwoKICAgIGlmIChub2RlLm5vZGVOYW1lID09ICJIMSIgfHwgbm9kZS5ub2RlTmFtZSA9PSAiaDEiKQogICAgICByZXR1cm4gbm9kZTsKCiAgICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7CgogICAgd2hpbGUgKGNoaWxkKQogICAgewogICAgICBub2RlID0gdGhpcy5maW5kX2hlYWRpbmcoY2hpbGQpOwoKICAgICAgaWYgKG5vZGUpCiAgICAgICAgcmV0dXJuIG5vZGU7CgogICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nOwogICAgfQoKICAgIHJldHVybiBudWxsOwogIH0sCgogIC8vIHJlY3Vyc2l2ZWx5IGV4dHJhY3QgdGV4dCBmcm9tIERPTSB0cmVlCiAgZXh0cmFjdF90ZXh0OiBmdW5jdGlvbiAobm9kZSkgewogICAgaWYgKCFub2RlKQogICAgICByZXR1cm4gIiI7CgogICAgLy8gdGV4dCBub2RlcwogICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykKICAgICAgcmV0dXJuIG5vZGUubm9kZVZhbHVlOwoKICAgIC8vIGVsZW1lbnRzCiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKQogICAgewogICAgICBub2RlID0gbm9kZS5maXJzdENoaWxkOwogICAgICB2YXIgdGV4dCA9ICIiOwoKICAgICAgd2hpbGUgKG5vZGUpCiAgICAgIHsKICAgICAgICB0ZXh0ID0gdGV4dCArIHRoaXMuZXh0cmFjdF90ZXh0KG5vZGUpOwogICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nOwogICAgICB9CgogICAgICByZXR1cm4gdGV4dDsKICAgIH0KCiAgICByZXR1cm4gIiI7CiAgfSwKCiAgLy8gZmluZCBjb3B5cmlnaHQgdGV4dCBmcm9tIG1ldGEgZWxlbWVudAogIGZpbmRfY29weXJpZ2h0OiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgbmFtZSwgY29udGVudDsKICAgIHZhciBtZXRhID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIm1ldGEiKTsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIG5hbWUgPSBtZXRhW2ldLmdldEF0dHJpYnV0ZSgibmFtZSIpOwogICAgICBjb250ZW50ID0gbWV0YVtpXS5nZXRBdHRyaWJ1dGUoImNvbnRlbnQiKTsKCiAgICAgIGlmIChuYW1lID09ICJjb3B5cmlnaHQiKQogICAgICAgIHJldHVybiBjb250ZW50OwogICAgfQoKICAgIHJldHVybiBudWxsOwogIH0sCgogIGZpbmRfc2l6ZV9hZGp1c3Q6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBuYW1lLCBjb250ZW50LCBvZmZzZXQ7CiAgICB2YXIgbWV0YSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJtZXRhIik7CgogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgKytpKQogICAgewogICAgICBuYW1lID0gbWV0YVtpXS5nZXRBdHRyaWJ1dGUoIm5hbWUiKTsKICAgICAgY29udGVudCA9IG1ldGFbaV0uZ2V0QXR0cmlidXRlKCJjb250ZW50Iik7CgogICAgICBpZiAobmFtZSA9PSAiZm9udC1zaXplLWFkanVzdG1lbnQiKQogICAgICAgIHJldHVybiAxICogY29udGVudDsKICAgIH0KCiAgICByZXR1cm4gMTsKICB9LAoKICAvLyA8bWV0YSBuYW1lPSJkdXJhdGlvbiIgY29udGVudD0iMjAiIC8+ICBmb3IgMjAgbWludXRlcwogIGZpbmRfZHVyYXRpb246IGZ1bmN0aW9uICgpIHsKICAgIHZhciBuYW1lLCBjb250ZW50LCBvZmZzZXQ7CiAgICB2YXIgbWV0YSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJtZXRhIik7CgogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgKytpKQogICAgewogICAgICBuYW1lID0gbWV0YVtpXS5nZXRBdHRyaWJ1dGUoIm5hbWUiKTsKICAgICAgY29udGVudCA9IG1ldGFbaV0uZ2V0QXR0cmlidXRlKCJjb250ZW50Iik7CgogICAgICBpZiAobmFtZSA9PSAiZHVyYXRpb24iKQogICAgICAgIHJldHVybiA2MDAwMCAqIGNvbnRlbnQ7CiAgICB9CgogICAgcmV0dXJuIG51bGw7CiAgfSwKCiAgcmVwbGFjZV9ieV9ub25fYnJlYWtpbmdfc3BhY2U6IGZ1bmN0aW9uIChzdHIpIHsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKQogICAgICBzdHJbaV0gPSAxNjA7CiAgfSwKCiAgLy8gIyMjIENIRUNLIE1FICMjIyBpcyB1c2Ugb2YgImxpIiBva2F5IGZvciB0ZXh0L2h0bWw/CiAgLy8gZm9yIFhIVE1MIGRvIHdlIGFsc28gbmVlZCB0byBzcGVjaWZ5IG5hbWVzcGFjZT8KICBpbml0X291dGxpbmVyOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgaXRlbXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgibGkiKTsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKQogICAgewogICAgICB2YXIgdGFyZ2V0ID0gaXRlbXNbaV07CgogICAgICBpZiAoIXRoaXMuaGFzX2NsYXNzKHRhcmdldC5wYXJlbnROb2RlLCAib3V0bGluZSIpKQogICAgICAgIGNvbnRpbnVlOwoKICAgICAgdGFyZ2V0Lm9uY2xpY2sgPSB0aGlzLm91dGxpbmVfY2xpY2s7Ci8qICMjIyBtb3JlIHdvcmsgbmVlZGVkIGZvciBJRTYKICAgICAgaWYgKCF0aGlzLm5zX3BvcykKICAgICAgewogICAgICAgIHRhcmdldC5vbm1vdXNlb3ZlciA9IHRoaXMuaG92ZXJfb3V0bGluZTsKICAgICAgICB0YXJnZXQub25tb3VzZW91dCA9IHRoaXMudW5ob3Zlcl9vdXRsaW5lOwogICAgICB9CiovCiAgICAgIGlmICh0aGlzLmZvbGRhYmxlKHRhcmdldCkpCiAgICAgIHsKICAgICAgICB0YXJnZXQuZm9sZGFibGUgPSB0cnVlOwogICAgICAgIHRhcmdldC5vbmZvY3VzID0gZnVuY3Rpb24gKCkge3czY19zbGlkeS5vdXRsaW5lID0gdGhpczt9OwogICAgICAgIHRhcmdldC5vbmJsdXIgPSBmdW5jdGlvbiAoKSB7dzNjX3NsaWR5Lm91dGxpbmUgPSBudWxsO307CgogICAgICAgIGlmICghdGFyZ2V0LmdldEF0dHJpYnV0ZSgidGFiaW5kZXgiKSkKICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoInRhYmluZGV4IiwgIjAiKTsKCiAgICAgICAgaWYgKHRoaXMuaGFzX2NsYXNzKHRhcmdldCwgImV4cGFuZCIpKQogICAgICAgICAgdGhpcy51bmZvbGQodGFyZ2V0KTsKICAgICAgICBlbHNlCiAgICAgICAgICB0aGlzLmZvbGQodGFyZ2V0KTsKICAgICAgfQogICAgICBlbHNlCiAgICAgIHsKICAgICAgICB0aGlzLmFkZF9jbGFzcyh0YXJnZXQsICJub2ZvbGQiKTsKICAgICAgICB0YXJnZXQudmlzaWJsZSA9IHRydWU7CiAgICAgICAgdGFyZ2V0LmZvbGRhYmxlID0gZmFsc2U7CiAgICAgIH0KICAgIH0KICB9LAoKICBmb2xkYWJsZTogZnVuY3Rpb24gKGl0ZW0pIHsKICAgIGlmICghaXRlbSB8fCBpdGVtLm5vZGVUeXBlICE9IDEpCiAgICAgIHJldHVybiBmYWxzZTsKCiAgICB2YXIgbm9kZSA9IGl0ZW0uZmlyc3RDaGlsZDsKCiAgICB3aGlsZSAobm9kZSkKICAgIHsKICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiB0aGlzLmlzX2Jsb2NrKG5vZGUpKQogICAgICAgIHJldHVybiB0cnVlOwoKICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7CiAgICB9CgogICAgcmV0dXJuIGZhbHNlOwogIH0sCgogIC8vICMjIyBDSEVDSyBNRSAjIyMgc3dpdGNoIHRvIGFkZC9yZW1vdmUgImhpZGRlbiIgY2xhc3MKICBmb2xkOiBmdW5jdGlvbiAoaXRlbSkgewogICAgaWYgKGl0ZW0pCiAgICB7CiAgICAgIHRoaXMucmVtb3ZlX2NsYXNzKGl0ZW0sICJ1bmZvbGRlZCIpOwogICAgICB0aGlzLmFkZF9jbGFzcyhpdGVtLCAiZm9sZGVkIik7CiAgICB9CgogICAgdmFyIG5vZGUgPSBpdGVtID8gaXRlbS5maXJzdENoaWxkIDogbnVsbDsKCiAgICB3aGlsZSAobm9kZSkKICAgIHsKICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiB0aGlzLmlzX2Jsb2NrKG5vZGUpKSAvLyBlbGVtZW50CiAgICAgIHsKICAgICAgICAgdzNjX3NsaWR5LmFkZF9jbGFzcyhub2RlLCAiaGlkZGVuIik7CiAgICAgIH0KCiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nOwogICAgfQoKICAgIGl0ZW0udmlzaWJsZSA9IGZhbHNlOwogIH0sCgogIC8vICMjIyBDSEVDSyBNRSAjIyMgc3dpdGNoIHRvIGFkZC9yZW1vdmUgImhpZGRlbiIgY2xhc3MKICB1bmZvbGQ6IGZ1bmN0aW9uIChpdGVtKSB7CiAgICBpZiAoaXRlbSkKICAgIHsKICAgICAgdGhpcy5hZGRfY2xhc3MoaXRlbSwgInVuZm9sZGVkIik7CiAgICAgIHRoaXMucmVtb3ZlX2NsYXNzKGl0ZW0sICJmb2xkZWQiKTsKICAgIH0KCiAgICB2YXIgbm9kZSA9IGl0ZW0gPyBpdGVtLmZpcnN0Q2hpbGQgOiBudWxsOwoKICAgIHdoaWxlIChub2RlKQogICAgewogICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIHRoaXMuaXNfYmxvY2sobm9kZSkpIC8vIGVsZW1lbnQKICAgICAgewogICAgICAgIHczY19zbGlkeS5yZW1vdmVfY2xhc3Mobm9kZSwgImhpZGRlbiIpOwogICAgICB9CgogICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZzsKICAgIH0KCiAgICBpdGVtLnZpc2libGUgPSB0cnVlOwogIH0sCgogIG91dGxpbmVfY2xpY2s6IGZ1bmN0aW9uIChlKSB7CiAgICBpZiAoIWUpCiAgICAgIGUgPSB3aW5kb3cuZXZlbnQ7CgogICAgdmFyIHJpZ2h0Y2xpY2sgPSBmYWxzZTsKICAgIHZhciB0YXJnZXQgPSB3M2Nfc2xpZHkuZ2V0X3RhcmdldChlKTsKCiAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldC52aXNpYmxlID09IHVuZGVmaW5lZCkKICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7CgogICAgaWYgKCF0YXJnZXQpCiAgICAgIHJldHVybiB0cnVlOwoKICAgIGlmIChlLndoaWNoKQogICAgICByaWdodGNsaWNrID0gKGUud2hpY2ggPT0gMyk7CiAgICBlbHNlIGlmIChlLmJ1dHRvbikKICAgICAgcmlnaHRjbGljayA9IChlLmJ1dHRvbiA9PSAyKTsKCiAgICBpZiAoIXJpZ2h0Y2xpY2sgJiYgdGFyZ2V0LnZpc2libGUgIT0gdW5kZWZpbmVkKQogICAgewogICAgICBpZiAodGFyZ2V0LmZvbGRhYmxlKQogICAgICB7CiAgICAgICAgaWYgKHRhcmdldC52aXNpYmxlKQogICAgICAgICAgdzNjX3NsaWR5LmZvbGQodGFyZ2V0KTsKICAgICAgICBlbHNlCiAgICAgICAgICB3M2Nfc2xpZHkudW5mb2xkKHRhcmdldCk7CiAgICAgIH0KCiAgICAgIHczY19zbGlkeS5zdG9wX3Byb3BhZ2F0aW9uKGUpOwogICAgICBlLmNhbmNlbCA9IHRydWU7CiAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTsKICAgIH0KCiAgICByZXR1cm4gZmFsc2U7CiAgfSwKCiAgYWRkX2luaXRpYWxfcHJvbXB0OiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgcHJvbXB0ID0gdGhpcy5jcmVhdGVfZWxlbWVudCgiZGl2Iik7CiAgICBwcm9tcHQuc2V0QXR0cmlidXRlKCJjbGFzcyIsICJpbml0aWFsX3Byb21wdCIpOwoKICAgIHZhciBwMSA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoInAiKTsKICAgIHByb21wdC5hcHBlbmRDaGlsZChwMSk7CiAgICBwMS5zZXRBdHRyaWJ1dGUoImNsYXNzIiwgImhlbHAiKTsKCiAgICBpZiAodGhpcy5rZXlib2FyZGxlc3MpCiAgICAgIHAxLmlubmVySFRNTCA9ICJzd2lwZSBsZWZ0IHRvIG1vdmUgdG8gbmV4dCBzbGlkZSI7CiAgICBlbHNlCiAgICAgIHAxLmlubmVySFRNTCA9ICJTcGFjZSwgUmlnaHQgQXJyb3cgb3Igc3dpcGUgbGVmdCB0byBtb3ZlIHRvICIgKwogICAgICAgICAgICAgICAgICAgICAibmV4dCBzbGlkZSwgY2xpY2sgaGVscCBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzIjsKCiAgICB0aGlzLmFkZF9saXN0ZW5lcihwcm9tcHQsICJjbGljayIsIGZ1bmN0aW9uIChlKSB7CiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocHJvbXB0KTsKICAgICAgdzNjX3NsaWR5LnN0b3BfcHJvcGFnYXRpb24oZSk7CiAgICAKICAgICAgaWYgKGUuY2FuY2VsICE9IHVuZGVmaW5lZCkKICAgICAgICBlLmNhbmNlbCA9IHRydWU7CiAgICAgIAogICAgICBpZiAoZS5yZXR1cm5WYWx1ZSAhPSB1bmRlZmluZWQpCiAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOwogICAgICAKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfSk7CgogICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcm9tcHQpOwogICAgdGhpcy5pbml0aWFsX3Byb21wdCA9IHByb21wdDsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChwcm9tcHQpO30sIDUwMDApOwogIH0sCgogIGFkZF90b29sYmFyOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgY291bnRlciwgcGFnZTsKCiAgICAgdGhpcy50b29sYmFyID0gdGhpcy5jcmVhdGVfZWxlbWVudCgiZGl2Iik7CiAgICAgdGhpcy50b29sYmFyLnNldEF0dHJpYnV0ZSgiY2xhc3MiLCAidG9vbGJhciIpOwoKICAgICAvLyBhIHJlYXNvbmFibHkgYmVoYXZlZCBicm93c2VyCiAgICAgaWYgKHRoaXMubnNfcG9zIHx8ICF0aGlzLmllNikKICAgICB7CiAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJkaXYiKTsKICAgICAgIHJpZ2h0LnNldEF0dHJpYnV0ZSgic3R5bGUiLCAiZmxvYXQ6IHJpZ2h0OyB0ZXh0LWFsaWduOiByaWdodCIpOwoKICAgICAgIGNvdW50ZXIgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJzcGFuIikKICAgICAgIGNvdW50ZXIuaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgic2xpZGUiKSArICIgbi9tIjsKICAgICAgIHJpZ2h0LmFwcGVuZENoaWxkKGNvdW50ZXIpOwogICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKHJpZ2h0KTsKCiAgICAgICB2YXIgbGVmdCA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImRpdiIpOwogICAgICAgbGVmdC5zZXRBdHRyaWJ1dGUoInN0eWxlIiwgInRleHQtYWxpZ246IGxlZnQiKTsKCiAgICAgICAvLyBnbG9iYWwgZW5kIG9mIHNsaWRlIGluZGljYXRvcgogICAgICAgdGhpcy5lb3MgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJzcGFuIik7CiAgICAgICB0aGlzLmVvcy5pbm5lckhUTUwgPSAiKiAiOwogICAgICAgbGVmdC5hcHBlbmRDaGlsZCh0aGlzLmVvcyk7CgogICAgICAgdmFyIGhlbHAgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJhIik7CiAgICAgICBoZWxwLnNldEF0dHJpYnV0ZSgiaHJlZiIsIHRoaXMuaGVscF9wYWdlKTsKICAgICAgIGhlbHAuc2V0QXR0cmlidXRlKCJ0aXRsZSIsIHRoaXMubG9jYWxpemUodGhpcy5oZWxwX3RleHQpKTsKICAgICAgIGhlbHAuaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgiaGVscD8iKTsKICAgICAgIGxlZnQuYXBwZW5kQ2hpbGQoaGVscCk7CiAgICAgICBoZWxwLnN0eWxlLmRpc3BsYXk9Im5vbmUiOyAKICAgICAgIHRoaXMuaGVscF9hbmNob3IgPSBoZWxwOyAgLy8gc2F2ZSBmb3IgZm9jdXMgaGFjawoKICAgICAgIHZhciBnYXAxID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIiAiKTsKICAgICAgIGxlZnQuYXBwZW5kQ2hpbGQoZ2FwMSk7CgogICAgICAgdmFyIGNvbnRlbnRzID0gdGhpcy5jcmVhdGVfZWxlbWVudCgiYSIpOwogICAgICAgY29udGVudHMuc2V0QXR0cmlidXRlKCJocmVmIiwgImphdmFzY3JpcHQ6dzNjX3NsaWR5LnRvZ2dsZV90YWJsZV9vZl9jb250ZW50cygpIik7CiAgICAgICBjb250ZW50cy5zZXRBdHRyaWJ1dGUoInRpdGxlIiwgdGhpcy5sb2NhbGl6ZSgidGFibGUgb2YgY29udGVudHMiKSk7CiAgICAgICBjb250ZW50cy5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKCJDb250ZW50cyIpOwogICAgICAgbGVmdC5hcHBlbmRDaGlsZChjb250ZW50cyk7CgogICAgICAgdmFyIGdhcDIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiICIpOwogICAgICAgbGVmdC5hcHBlbmRDaGlsZChnYXAyKTsKCiAgICAgICB2YXIgY29weXJpZ2h0ID0gdGhpcy5maW5kX2NvcHlyaWdodCgpOwoKICAgICAgIGlmIChjb3B5cmlnaHQpCiAgICAgICB7CiAgICAgICAgIHZhciBzcGFuID0gdGhpcy5jcmVhdGVfZWxlbWVudCgic3BhbiIpOwogICAgICAgICBzcGFuLmNsYXNzTmFtZSA9ICJjb3B5cmlnaHQiOwogICAgICAgICBzcGFuLmlubmVySFRNTCA9IGNvcHlyaWdodDsKICAgICAgICAgbGVmdC5hcHBlbmRDaGlsZChzcGFuKTsKICAgICAgIH0KCiAgICAgICB0aGlzLnRvb2xiYXIuc2V0QXR0cmlidXRlKCJ0YWJpbmRleCIsICIwIik7CiAgICAgICB0aGlzLnRvb2xiYXIuYXBwZW5kQ2hpbGQobGVmdCk7CiAgICAgfQogICAgIGVsc2UgLy8gSUU2IHNvIG5lZWQgdG8gd29yayBhcm91bmQgaXRzIHBvb3IgQ1NTIHN1cHBvcnQKICAgICB7CiAgICAgICB0aGlzLnRvb2xiYXIuc3R5bGUucG9zaXRpb24gPSAodGhpcy5pZTcgPyAiZml4ZWQiIDogImFic29sdXRlIik7CiAgICAgICB0aGlzLnRvb2xiYXIuc3R5bGUuekluZGV4ID0gIjIwMCI7CiAgICAgICB0aGlzLnRvb2xiYXIuc3R5bGUud2lkdGggPSAiOTkuOSUiOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLmhlaWdodCA9ICIxLjJlbSI7CiAgICAgICB0aGlzLnRvb2xiYXIuc3R5bGUudG9wID0gImF1dG8iOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLmJvdHRvbSA9ICIwIjsKICAgICAgIHRoaXMudG9vbGJhci5zdHlsZS5sZWZ0ID0gIjAiOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLnJpZ2h0ID0gIjAiOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLnRleHRBbGlnbiA9ICJsZWZ0IjsKICAgICAgIHRoaXMudG9vbGJhci5zdHlsZS5mb250U2l6ZSA9ICI2MCUiOwogICAgICAgdGhpcy50b29sYmFyLnN0eWxlLmNvbG9yID0gInJlZCI7CiAgICAgICB0aGlzLnRvb2xiYXIuYm9yZGVyV2lkdGggPSAwOwogICAgICAgdGhpcy50b29sYmFyLmNsYXNzTmFtZSA9ICJ0b29sYmFyIjsKICAgICAgIHRoaXMudG9vbGJhci5zdHlsZS5iYWNrZ3JvdW5kID0gInJnYigyNDAsMjQwLDI0MCkiOwoKICAgICAgIC8vIHdvdWxkIGxpa2UgdG8gaGF2ZSBoZWxwIHRleHQgbGVmdCBhbGlnbmVkCiAgICAgICAvLyBhbmQgcGFnZSBjb3VudGVyIHJpZ2h0IGFsaWduZWQsIGZsb2F0aW5nCiAgICAgICAvLyBkaXYncyBkb24ndCB3b3JrLCBzbyBpbnN0ZWFkIHVzZSBuZXN0ZWQKICAgICAgIC8vIGFic29sdXRlbHkgcG9zaXRpb25lZCBkaXYncy4KCiAgICAgICB2YXIgc3AgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJzcGFuIik7CiAgICAgICBzcC5pbm5lckhUTUwgPSAiJm5ic3A7Jm5ic3A7KiZuYnNwOyI7CiAgICAgICB0aGlzLnRvb2xiYXIuYXBwZW5kQ2hpbGQoc3ApOwogICAgICAgdGhpcy5lb3MgPSBzcDsgIC8vIGVuZCBvZiBzbGlkZSBpbmRpY2F0b3IKCiAgICAgICB2YXIgaGVscCA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImEiKTsKICAgICAgIGhlbHAuc2V0QXR0cmlidXRlKCJocmVmIiwgdGhpcy5oZWxwX3BhZ2UpOwogICAgICAgaGVscC5zZXRBdHRyaWJ1dGUoInRpdGxlIiwgdGhpcy5sb2NhbGl6ZSh0aGlzLmhlbHBfdGV4dCkpOwogICAgICAgaGVscC5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKCJoZWxwPyIpOwogICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKGhlbHApOwogICAgICAgdGhpcy5oZWxwX2FuY2hvciA9IGhlbHA7ICAvLyBzYXZlIGZvciBmb2N1cyBoYWNrCgogICAgICAgdmFyIGdhcDEgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiICIpOwogICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKGdhcDEpOwoKICAgICAgIHZhciBjb250ZW50cyA9IHRoaXMuY3JlYXRlX2VsZW1lbnQoImEiKTsKICAgICAgIGNvbnRlbnRzLnNldEF0dHJpYnV0ZSgiaHJlZiIsICJqYXZhc2NyaXB0OnRvZ2dsZVRhYmxlT2ZDb250ZW50cygpIik7CiAgICAgICBjb250ZW50cy5zZXRBdHRyaWJ1dGUoInRpdGxlIiwgdGhpcy5sb2NhbGl6ZSgidGFibGUgb2YgY29udGVudHMiLmxvY2FsaXplKSk7CiAgICAgICBjb250ZW50cy5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKCJjb250ZW50cz8iKTsKICAgICAgIHRoaXMudG9vbGJhci5hcHBlbmRDaGlsZChjb250ZW50cyk7CgogICAgICAgdmFyIGdhcDIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgiICIpOwogICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKGdhcDIpOwoKICAgICAgIHZhciBjb3B5cmlnaHQgPSB0aGlzLmZpbmRfY29weXJpZ2h0KCk7CgogICAgICAgaWYgKGNvcHlyaWdodCkKICAgICAgIHsKICAgICAgICAgdmFyIHNwYW4gPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJzcGFuIik7CiAgICAgICAgIHNwYW4uaW5uZXJIVE1MID0gY29weXJpZ2h0OwogICAgICAgICBzcGFuLnN0eWxlLmNvbG9yID0gImJsYWNrIjsKICAgICAgICAgc3Bhbi5zdHlsZS5tYXJnaW5MZWZ0ID0gIjAuNWVtIjsKICAgICAgICAgdGhpcy50b29sYmFyLmFwcGVuZENoaWxkKHNwYW4pOwogICAgICAgfQoKICAgICAgIGNvdW50ZXIgPSB0aGlzLmNyZWF0ZV9lbGVtZW50KCJkaXYiKQogICAgICAgY291bnRlci5zdHlsZS5wb3NpdGlvbiA9ICJhYnNvbHV0ZSI7CiAgICAgICBjb3VudGVyLnN0eWxlLndpZHRoID0gImF1dG8iOyAvLyIyMCUiOwogICAgICAgY291bnRlci5zdHlsZS5oZWlnaHQgPSAiMS4yZW0iOwogICAgICAgY291bnRlci5zdHlsZS50b3AgPSAiYXV0byI7CiAgICAgICBjb3VudGVyLnN0eWxlLmJvdHRvbSA9IDA7CiAgICAgICBjb3VudGVyLnN0eWxlLnJpZ2h0ID0gIjAiOwogICAgICAgY291bnRlci5zdHlsZS50ZXh0QWxpZ24gPSAicmlnaHQiOwogICAgICAgY291bnRlci5zdHlsZS5jb2xvciA9ICJyZWQiOwogICAgICAgY291bnRlci5zdHlsZS5iYWNrZ3JvdW5kID0gInJnYigyNDAsMjQwLDI0MCkiOwoKICAgICAgIGNvdW50ZXIuaW5uZXJIVE1MID0gdGhpcy5sb2NhbGl6ZSgic2xpZGUiKSArICIgbi9tIjsKICAgICAgIHRoaXMudG9vbGJhci5hcHBlbmRDaGlsZChjb3VudGVyKTsKICAgICB9CgogICAgIC8vIGVuc3VyZSB0aGF0IGNsaWNrIGlzbid0IHBhc3NlZCB0aHJvdWdoIHRvIHRoZSBwYWdlCiAgICAgdGhpcy50b29sYmFyLm9uY2xpY2sgPQogICAgICAgICBmdW5jdGlvbiAoZSkgewogICAgICAgICAgIGlmICghZSkKICAgICAgICAgICAgIGUgPSB3aW5kb3cuZXZlbnQ7CgogICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDsKCiAgICAgICAgICAgaWYgKCF0YXJnZXQgJiYgZS5zcmNFbGVtZW50KQogICAgICAgICAgICAgdGFyZ2V0ID0gZS5zcmNFbGVtZW50OwoKICAgICAgICAgICAvLyB3b3JrIGFyb3VuZCBTYWZhcmkgYnVnCiAgICAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZVR5cGUgPT0gMykKICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlOwoKICAgICAgICAgICB3M2Nfc2xpZHkuc3RvcF9wcm9wYWdhdGlvbihlKTsKCiAgICAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPSAiYSIpCiAgICAgICAgICAgICB3M2Nfc2xpZHkubW91c2VfYnV0dG9uX2NsaWNrKGUpOwogICAgICAgICB9OwoKICAgICB0aGlzLnNsaWRlX251bWJlcl9lbGVtZW50ID0gY291bnRlcjsKICAgICB0aGlzLnNldF9lb3Nfc3RhdHVzKGZhbHNlKTsKICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMudG9vbGJhcik7CiAgfSwKCiAgLy8gd3lzaXd5ZyBlZGl0b3JzIG1ha2UgaXQgaGFyZCB0byB1c2UgZGl2IGVsZW1lbnRzCiAgLy8gZS5nLiBhbWF5YSBsb3NlcyB0aGUgZGl2IHdoZW4geW91IGNvcHkgYW5kIHBhc3RlCiAgLy8gdGhpcyBmdW5jdGlvbiB3cmFwcyBkaXYgZWxlbWVudHMgYXJvdW5kIGltcGxpY2l0CiAgLy8gc2xpZGVzIHdoaWNoIHN0YXJ0IHdpdGggYW4gaDEgZWxlbWVudCBhbmQgY29udGludWUKICAvLyB1cCB0byB0aGUgbmV4dCBoZWFkaW5nIG9yIGRpdiBlbGVtZW50CiAgd3JhcF9pbXBsaWNpdF9zbGlkZXM6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBpLCBoZWFkaW5nLCBub2RlLCBuZXh0LCBkaXY7CiAgICB2YXIgaGVhZGluZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgiaDEiKTsKCiAgICBpZiAoIWhlYWRpbmdzKQogICAgICByZXR1cm47CgogICAgZm9yIChpID0gMDsgaSA8IGhlYWRpbmdzLmxlbmd0aDsgKytpKQogICAgewogICAgICBoZWFkaW5nID0gaGVhZGluZ3NbaV07CgogICAgICBpZiAoaGVhZGluZy5wYXJlbnROb2RlICE9IGRvY3VtZW50LmJvZHkpCiAgICAgICAgY29udGludWU7CgogICAgICBub2RlID0gaGVhZGluZy5uZXh0U2libGluZzsKCiAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpOwogICAgICB0aGlzLmFkZF9jbGFzcyhkaXYsICJzbGlkZSIpOwogICAgICBkb2N1bWVudC5ib2R5LnJlcGxhY2VDaGlsZChkaXYsIGhlYWRpbmcpOwogICAgICBkaXYuYXBwZW5kQ2hpbGQoaGVhZGluZyk7CgogICAgICB3aGlsZSAobm9kZSkKICAgICAgewogICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpIC8vIGFuIGVsZW1lbnQKICAgICAgICB7CiAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gIkgxIiB8fCBub2RlLm5vZGVOYW1lID09ICJoMSIpCiAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gIkRJViIgfHwgbm9kZS5ub2RlTmFtZSA9PSAiZGl2IikKICAgICAgICAgICB7CiAgICAgICAgICAgICBpZiAodGhpcy5oYXNfY2xhc3Mobm9kZSwgInNsaWRlIikpCiAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgIGlmICh0aGlzLmhhc19jbGFzcyhub2RlLCAiaGFuZG91dCIpKQogICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZzsKICAgICAgICBub2RlID0gZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChub2RlKTsKICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobm9kZSk7CiAgICAgICAgbm9kZSA9IG5leHQ7CiAgICAgIH0gCiAgICB9CiAgfSwKCiAgYXR0YWNoX3RvdWNoX2hhbmRlcnM6IGZ1bmN0aW9uKHNsaWRlcykKICB7CiAgICB2YXIgaSwgc2xpZGU7CgogICAgZm9yIChpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgc2xpZGUgPSBzbGlkZXNbaV07CiAgICAgIHRoaXMuYWRkX2xpc3RlbmVyKHNsaWRlLCAidG91Y2hzdGFydCIsIHRoaXMudG91Y2hzdGFydCk7CiAgICAgIHRoaXMuYWRkX2xpc3RlbmVyKHNsaWRlLCAidG91Y2htb3ZlIiwgdGhpcy50b3VjaG1vdmUpOwogICAgICB0aGlzLmFkZF9saXN0ZW5lcihzbGlkZSwgInRvdWNoZW5kIiwgdGhpcy50b3VjaGVuZCk7CiAgICB9CiAgfSwKCi8vIHJldHVybiBuZXcgYXJyYXkgb2YgYWxsIHNsaWRlcwogIGNvbGxlY3Rfc2xpZGVzOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgc2xpZGVzID0gbmV3IEFycmF5KCk7CiAgICB2YXIgZGl2cyA9IGRvY3VtZW50LmJvZHkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGl2cy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgZGl2ID0gZGl2cy5pdGVtKGkpOwoKICAgICAgaWYgKHRoaXMuaGFzX2NsYXNzKGRpdiwgInNsaWRlIikpCiAgICAgIHsKICAgICAgICAvLyBhZGQgc2xpZGUgdG8gY29sbGVjdGlvbgogICAgICAgIHNsaWRlc1tzbGlkZXMubGVuZ3RoXSA9IGRpdjsKCiAgICAgICAgLy8gaGlkZSBlYWNoIHNsaWRlIGFzIGl0IGlzIGZvdW5kCiAgICAgICAgdGhpcy5hZGRfY2xhc3MoZGl2LCAiaGlkZGVuIik7CgogICAgICAgIC8vIGFkZCBkdW1teSA8YnIvPiBhdCBlbmQgZm9yIHNjcm9sbGluZyBoYWNrCiAgICAgICAgdmFyIG5vZGUxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYnIiKTsKICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobm9kZTEpOwogICAgICAgIHZhciBub2RlMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImJyIik7CiAgICAgICAgZGl2LmFwcGVuZENoaWxkKG5vZGUyKTsKICAgICAgfQogICAgICBlbHNlIGlmICh0aGlzLmhhc19jbGFzcyhkaXYsICJiYWNrZ3JvdW5kIikpCiAgICAgIHsgIC8vIHdvcmsgYXJvdW5kIGZvciBGaXJlZm94IFNWRyByZWxvYWQgYnVnCiAgICAgICAgLy8gd2hpY2ggb3RoZXJ3aXNlIHJlcGxhY2VzIDFzdCBTVkcgZ3JhcGhpYyB3aXRoIDJuZAogICAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gImJsb2NrIjsKICAgICAgfQogICAgfQoKICAgIHRoaXMuc2xpZGVzID0gc2xpZGVzOwogIH0sCgogIC8vIHJldHVybiBuZXcgYXJyYXkgb2YgYWxsIDxkaXYgY2xhc3M9ImhhbmRvdXQiPgogIGNvbGxlY3Rfbm90ZXM6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBub3RlcyA9IG5ldyBBcnJheSgpOwogICAgdmFyIGRpdnMgPSBkb2N1bWVudC5ib2R5LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJkaXYiKTsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpdnMubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIGRpdiA9IGRpdnMuaXRlbShpKTsKCiAgICAgIGlmICh0aGlzLmhhc19jbGFzcyhkaXYsICJoYW5kb3V0IikpCiAgICAgIHsKICAgICAgICAvLyBhZGQgbm90ZSB0byBjb2xsZWN0aW9uCiAgICAgICAgbm90ZXNbbm90ZXMubGVuZ3RoXSA9IGRpdjsKCiAgICAgICAgLy8gYW5kIGhpZGUgaXQKICAgICAgICB0aGlzLmFkZF9jbGFzcyhkaXYsICJoaWRkZW4iKTsKICAgICAgfQogICAgfQoKICAgIHRoaXMubm90ZXMgPSBub3RlczsKICB9LAoKICAvLyByZXR1cm4gbmV3IGFycmF5IG9mIGFsbCA8ZGl2IGNsYXNzPSJiYWNrZ3JvdW5kIj4KICAvLyBpbmNsdWRpbmcgbmFtZWQgYmFja2dyb3VuZHMgZS5nLiBjbGFzcz0iYmFja2dyb3VuZCB0aXRsZXBhZ2UiCiAgY29sbGVjdF9iYWNrZ3JvdW5kczogZnVuY3Rpb24gKCkgewogICAgdmFyIGJhY2tncm91bmRzID0gbmV3IEFycmF5KCk7CiAgICB2YXIgZGl2cyA9IGRvY3VtZW50LmJvZHkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImRpdiIpOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGl2cy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgZGl2ID0gZGl2cy5pdGVtKGkpOwoKICAgICAgaWYgKHRoaXMuaGFzX2NsYXNzKGRpdiwgImJhY2tncm91bmQiKSkKICAgICAgewogICAgICAgIC8vIGFkZCBiYWNrZ3JvdW5kIHRvIGNvbGxlY3Rpb24KICAgICAgICBiYWNrZ3JvdW5kc1tiYWNrZ3JvdW5kcy5sZW5ndGhdID0gZGl2OwoKICAgICAgICAvLyBhbmQgaGlkZSBpdAogICAgICAgIHRoaXMuYWRkX2NsYXNzKGRpdiwgImhpZGRlbiIpOwogICAgICB9CiAgICB9CgogICAgdGhpcy5iYWNrZ3JvdW5kcyA9IGJhY2tncm91bmRzOwogIH0sCgogIC8vIHNldCBjbGljayBoYW5kbGVycyBvbiBhbGwgYW5jaG9ycwogIHBhdGNoX2FuY2hvcnM6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBzZWxmID0gdzNjX3NsaWR5OwogICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHsKICAgICAgLy8gY29tcGFyZSB0aGlzLmhyZWYgd2l0aCBsb2NhdGlvbi5ocmVmCiAgICAgIC8vIGZvciBsaW5rIHRvIGFub3RoZXIgc2xpZGUgaW4gdGhpcyBkb2MKCiAgICAgIGlmIChzZWxmLnBhZ2VfYWRkcmVzcyh0aGlzLmhyZWYpID09IHNlbGYucGFnZV9hZGRyZXNzKGxvY2F0aW9uLmhyZWYpKQogICAgICB7CiAgICAgICAgLy8geWVzLCBzbyBmaW5kIG5ldyBzbGlkZSBudW1iZXIKICAgICAgICB2YXIgbmV3c2xpZGVudW0gPSBzZWxmLmZpbmRfc2xpZGVfbnVtYmVyKHRoaXMuaHJlZik7CgogICAgICAgIGlmIChuZXdzbGlkZW51bSAhPSBzZWxmLnNsaWRlX251bWJlcikKICAgICAgICB7CiAgICAgICAgICB2YXIgc2xpZGUgPSBzZWxmLnNsaWRlc1tzZWxmLnNsaWRlX251bWJlcl07CiAgICAgICAgICBzZWxmLmhpZGVfc2xpZGUoc2xpZGUpOwogICAgICAgICAgc2VsZi5zbGlkZV9udW1iZXIgPSBuZXdzbGlkZW51bTsKICAgICAgICAgIHNsaWRlID0gc2VsZi5zbGlkZXNbc2VsZi5zbGlkZV9udW1iZXJdOwogICAgICAgICAgc2VsZi5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgICAgIHNlbGYuc2V0X2xvY2F0aW9uKCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGVsc2UKICAgICAgICB3M2Nfc2xpZHkuc3RvcF9wcm9wYWdhdGlvbihldmVudCk7CgovLyAgICAgIGVsc2UgaWYgKHRoaXMudGFyZ2V0ID09IG51bGwpCi8vICAgICAgICBsb2NhdGlvbi5ocmVmID0gdGhpcy5ocmVmOwoKICAgICAgdGhpcy5ibHVyKCk7CiAgICAgIHNlbGYuZGlzYWJsZV9zbGlkZV9jbGljayA9IHRydWU7CiAgICB9OwoKICAgIHZhciBhbmNob3JzID0gZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYSIpOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5jaG9ycy5sZW5ndGg7ICsraSkKICAgIHsKICAgICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKQogICAgICAgIGFuY2hvcnNbaV0uYWRkRXZlbnRMaXN0ZW5lcigiY2xpY2siLCBoYW5kbGVyLCBmYWxzZSk7CiAgICAgIGVsc2UKICAgICAgICBhbmNob3JzW2ldLmF0dGFjaEV2ZW50KCJvbmNsaWNrIiwgaGFuZGxlcik7CiAgICB9CiAgfSwKCiAgLy8gIyMjIENIRUNLIE1FICMjIyBzZWUgd2hpY2ggZnVuY3Rpb25zIGFyZSBpbnZva2VkIHZpYSBzZXRUaW1lb3V0CiAgLy8gZWl0aGVyIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgZm9yIHVzZSBvZiB3M2Nfc2xpZHkgdnMgdGhpcwogIHNob3dfc2xpZGVfbnVtYmVyOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgdGltZXIgPSB3M2Nfc2xpZHkuZ2V0X3RpbWVyKCk7CiAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyX2VsZW1lbnQuaW5uZXJIVE1MID0gdGltZXIgKyB3M2Nfc2xpZHkubG9jYWxpemUoInNsaWRlIikgKyAiICIgKwogICAgICAgICAgICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyICsgMSkgKyAiLyIgKyB3M2Nfc2xpZHkuc2xpZGVzLmxlbmd0aDsKICB9LAoKICAvLyBldmVyeSAyMDBtUyBjaGVjayBpZiB0aGUgbG9jYXRpb24gaGFzIGJlZW4gY2hhbmdlZCBhcyBhCiAgLy8gcmVzdWx0IG9mIHRoZSB1c2VyIGFjdGl2YXRpbmcgdGhlIEJhY2sgYnV0dG9uL21lbnUgaXRlbQogIC8vIGRvZXNuJ3Qgd29yayBmb3IgT3BlcmEgPCA5LjUKICBjaGVja19sb2NhdGlvbjogZnVuY3Rpb24gKCkgewogICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoOwoKICAgIGlmICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyID4gMCAmJiAoaGFzaCA9PSAiIiB8fCBoYXNoID09ICIjIikpCiAgICAgIHczY19zbGlkeS5nb3RvX3NsaWRlKDApOwogICAgZWxzZSBpZiAoaGFzaC5sZW5ndGggPiAyICYmIGhhc2ggIT0gIiMoIisodzNjX3NsaWR5LnNsaWRlX251bWJlcisxKSsiKSIpCiAgICB7CiAgICAgIHZhciBudW0gPSBwYXJzZUludChsb2NhdGlvbi5oYXNoLnN1YnN0cigyKSk7CgogICAgICBpZiAoIWlzTmFOKG51bSkpCiAgICAgICAgdzNjX3NsaWR5LmdvdG9fc2xpZGUobnVtLTEpOwogICAgfQoKICAgIGlmICh3M2Nfc2xpZHkudGltZV9sZWZ0ICYmIHczY19zbGlkeS5zbGlkZV9udW1iZXIgPiAwKQogICAgewogICAgICB3M2Nfc2xpZHkuc2hvd19zbGlkZV9udW1iZXIoKTsKCiAgICAgIGlmICh3M2Nfc2xpZHkudGltZV9sZWZ0ID4gMCkKICAgICAgICB3M2Nfc2xpZHkudGltZV9sZWZ0IC09IDIwMDsKICAgIH0gCiAgfSwKCiAgZ2V0X3RpbWVyOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgdGltZXIgPSAiIjsKICAgIGlmICh3M2Nfc2xpZHkudGltZV9sZWZ0KQogICAgewogICAgICB2YXIgbWlucywgc2VjczsKICAgICAgc2VjcyA9IE1hdGguZmxvb3IodzNjX3NsaWR5LnRpbWVfbGVmdC8xMDAwKTsKICAgICAgbWlucyA9IE1hdGguZmxvb3Ioc2VjcyAvIDYwKTsKICAgICAgc2VjcyA9IHNlY3MgJSA2MDsKICAgICAgdGltZXIgPSAobWlucyA/IG1pbnMrIm0iIDogIiIpICsgc2VjcyArICJzICI7CiAgICB9CgogICAgcmV0dXJuIHRpbWVyOwogIH0sCgogIC8vIHRoaXMgZG9lc24ndCBwdXNoIGxvY2F0aW9uIG9udG8gaGlzdG9yeSBzdGFjayBmb3IgSUUKICAvLyBmb3Igd2hpY2ggYSBoaWRkZW4gaWZyYW1lIGhhY2sgaXMgbmVlZGVkOiBsb2FkIHBhZ2UgaW50bwogIC8vIHRoZSBpZnJhbWUgd2l0aCBzY3JpcHQgdGhhdCBzZXQncyBwYXJlbnQncyBsb2NhdGlvbi5oYXNoCiAgLy8gYnV0IHRoYXQgd29uJ3Qgd29yayBmb3Igc3RhbmRhbG9uZSB1c2UgdW5sZXNzIHdlIGNhbgogIC8vIGNyZWF0ZSB0aGUgcGFnZSBkeW5hbWljYWxseSB2aWEgYSBqYXZhc2NyaXB0OiBVUkwKICAvLyAjIyMgdXNlIGhpc3RvcnkucHVzaFN0YXRlIGlmIGF2YWlsYWJsZQogIHNldF9sb2NhdGlvbjogZnVuY3Rpb24gKCkgewogICAgIHZhciB1cmkgPSB3M2Nfc2xpZHkucGFnZV9hZGRyZXNzKGxvY2F0aW9uLmhyZWYpOwogICAgIHZhciBoYXNoID0gIiMoIiArICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyKzEpICsgIikiOwoKICAgICBpZiAodzNjX3NsaWR5LnNsaWRlX251bWJlciA+PSAwKQogICAgICAgdXJpID0gdXJpICsgaGFzaDsKCiAgICAgaWYgKHR5cGVvZihoaXN0b3J5LnB1c2hTdGF0ZSkgIT0gInVuZGVmaW5lZCIgJiYgbG9jYXRpb24ucHJvdG9jb2wgIT09ICJmaWxlOiIpCiAgICAgewogICAgICAgZG9jdW1lbnQudGl0bGUgPSB3M2Nfc2xpZHkudGl0bGUgKyAiICgiICsgKHczY19zbGlkeS5zbGlkZV9udW1iZXIrMSkgKyAiKSI7CiAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZSgwLCBkb2N1bWVudC50aXRsZSwgaGFzaCk7CiAgICAgICB3M2Nfc2xpZHkuc2hvd19zbGlkZV9udW1iZXIoKTsKICAgICAgIHczY19zbGlkeS5ub3RpZnlfb2JzZXJ2ZXJzKCk7CiAgICAgICByZXR1cm47CiAgICAgfQoKICAgICBpZiAodzNjX3NsaWR5LmllICYmICh3M2Nfc2xpZHkuaWU2IHx8IHczY19zbGlkeS5pZTcpKQogICAgICAgdzNjX3NsaWR5LnB1c2hfaGFzaChoYXNoKTsKCiAgICAgaWYgKHVyaSAhPSBsb2NhdGlvbi5ocmVmKSAvLyAmJiAha2h0bWwKICAgICAgICBsb2NhdGlvbi5ocmVmID0gdXJpOwoKICAgICBpZiAodGhpcy5raHRtbCkKICAgICAgICBoYXNoID0gIigiICsgKHczY19zbGlkeS5zbGlkZV9udW1iZXIrMSkgKyAiKSI7CgogICAgIGlmICghdGhpcy5pZSAmJiBsb2NhdGlvbi5oYXNoICE9IGhhc2ggJiYgbG9jYXRpb24uaGFzaCAhPSAiIikKICAgICAgIGxvY2F0aW9uLmhhc2ggPSBoYXNoOwoKICAgICBkb2N1bWVudC50aXRsZSA9IHczY19zbGlkeS50aXRsZSArICIgKCIgKyAodzNjX3NsaWR5LnNsaWRlX251bWJlcisxKSArICIpIjsKICAgICB3M2Nfc2xpZHkuc2hvd19zbGlkZV9udW1iZXIoKTsKICAgICB3M2Nfc2xpZHkubm90aWZ5X29ic2VydmVycygpOwogIH0sCgogIG5vdGlmeV9vYnNlcnZlcnM6IGZ1bmN0aW9uICgpCiAgewogICAgdmFyIHNsaWRlID0gdGhpcy5zbGlkZXNbdGhpcy5zbGlkZV9udW1iZXJdOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlcnMubGVuZ3RoOyArK2kpCiAgICAgIHRoaXMub2JzZXJ2ZXJzW2ldKHRoaXMuc2xpZGVfbnVtYmVyKzEsIHRoaXMuZmluZF9oZWFkaW5nKHNsaWRlKS5pbm5lclRleHQsIGxvY2F0aW9uLmhyZWYpOwogIH0sCgogIGFkZF9vYnNlcnZlcjogZnVuY3Rpb24gKG9ic2VydmVyKQogIHsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlcnMubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIGlmIChvYnNlcnZlciA9PSB0aGlzLm9ic2VydmVyc1tpXSkKICAgICAgICByZXR1cm47CiAgICB9CgogICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7CiAgfSwKCiAgcmVtb3ZlX29ic2VydmVyOiBmdW5jdGlvbiAobykKICB7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub2JzZXJ2ZXJzLmxlbmd0aDsgKytpKQogICAgewogICAgICBpZiAob2JzZXJ2ZXIgPT0gdGhpcy5vYnNlcnZlcnNbaV0pCiAgICAgIHsKICAgICAgICB0aGlzLm9ic2VydmVycy5zcGxpY2UoaSwxKTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgfQogIH0sCgogIHBhZ2VfYWRkcmVzczogZnVuY3Rpb24gKHVyaSkgewogICAgdmFyIGkgPSB1cmkuaW5kZXhPZigiIyIpOwoKICAgIGlmIChpIDwgMCkKICAgICAgaSA9IHVyaS5pbmRleE9mKCIlMjMiKTsKCiAgICAvLyBjaGVjayBpZiBhbmNob3IgaXMgZW50aXJlIHBhZ2UKCiAgICBpZiAoaSA8IDApCiAgICAgIHJldHVybiB1cmk7ICAvLyB5ZXMKCiAgICByZXR1cm4gdXJpLnN1YnN0cigwLCBpKTsKICB9LAoKICAvLyBvbmx5IHVzZWQgZm9yIElFNiBhbmQgSUU3CiAgb25fZnJhbWVfbG9hZGVkOiBmdW5jdGlvbiAoaGFzaCkgewogICAgbG9jYXRpb24uaGFzaCA9IGhhc2g7CiAgICB2YXIgdXJpID0gdzNjX3NsaWR5LnBhZ2VfYWRkcmVzcyhsb2NhdGlvbi5ocmVmKTsKICAgIGxvY2F0aW9uLmhyZWYgPSB1cmkgKyBoYXNoOwogIH0sCgogIC8vIGhpc3RvcnkgaGFjayB3aXRoIHRoYW5rcyB0byBCZXJ0cmFuZCBMZSBSb3kKICBwdXNoX2hhc2g6IGZ1bmN0aW9uIChoYXNoKSB7CiAgICBpZiAoaGFzaCA9PSAiIikgaGFzaCA9ICIjKDEpIjsKICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoOwoKICAgIHZhciBkb2MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiaGlzdG9yeUZyYW1lIikuY29udGVudFdpbmRvdy5kb2N1bWVudDsKICAgIGRvYy5vcGVuKCJqYXZhc2NyaXB0Oic8aHRtbD48L2h0bWw+JyIpOwogICAgZG9jLndyaXRlKCI8aHRtbD48aGVhZD48c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj53aW5kb3cucGFyZW50LnczY19zbGlkeS5vbl9mcmFtZV9sb2FkZWQoJyIrCiAgICAgIChoYXNoKSArICInKTs8L3NjcmlwdD48L2hlYWQ+PGJvZHk+aGVsbG8gbXVtPC9ib2R5PjwvaHRtbD4iKTsKICAgICAgZG9jLmNsb3NlKCk7CiAgfSwKCiAgLy8gZmluZCBjdXJyZW50IHNsaWRlIGJhc2VkIHVwb24gbG9jYXRpb24KICAvLyBmaXJzdCBmaW5kIHRhcmdldCBhbmNob3IgYW5kIHRoZW4gbG9vawogIC8vIGZvciBhc3NvY2lhdGVkIGRpdiBlbGVtZW50IGVuY2xvc2luZyBpdAogIC8vIGZpbmFsbHkgbWFwIHRoYXQgdG8gc2xpZGUgbnVtYmVyCiAgZmluZF9zbGlkZV9udW1iZXI6IGZ1bmN0aW9uICh1cmkpIHsKICAgIC8vIGZpcnN0IGdldCBhbmNob3IgZnJvbSBwYWdlIGxvY2F0aW9uCgogICAgdmFyIGkgPSB1cmkuaW5kZXhPZigiIyIpOwoKICAgIC8vIGNoZWNrIGlmIGFuY2hvciBpcyBlbnRpcmUgcGFnZQogICAgaWYgKGkgPCAwKQogICAgICByZXR1cm4gMDsgIC8vIHllcwoKICAgIHZhciBhbmNob3IgPSB1bmVzY2FwZSh1cmkuc3Vic3RyKGkrMSkpOwoKICAgIC8vIG5vdyB1c2UgYW5jaG9yIGFzIFhNTCBJRCB0byBmaW5kIHRhcmdldAogICAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGFuY2hvcik7CgogICAgaWYgKCF0YXJnZXQpCiAgICB7CiAgICAgIC8vIGRvZXMgYW5jaG9yIGxvb2sgbGlrZSAiKDIpIiBmb3Igc2xpZGUgMiA/PwogICAgICAvLyB3aGVyZSBmaXJzdCBzbGlkZSBpcyAoMSkKICAgICAgdmFyIHJlID0gL1woKFxkKStcKS87CgogICAgICBpZiAoYW5jaG9yLm1hdGNoKHJlKSkKICAgICAgewogICAgICAgIHZhciBudW0gPSBwYXJzZUludChhbmNob3Iuc3Vic3RyaW5nKDEsIGFuY2hvci5sZW5ndGgtMSkpOwoKICAgICAgICBpZiAobnVtID4gdGhpcy5zbGlkZXMubGVuZ3RoKQogICAgICAgICAgbnVtID0gMTsKCiAgICAgICAgaWYgKC0tbnVtIDwgMCkKICAgICAgICAgIG51bSA9IDA7CgogICAgICAgIHJldHVybiBudW07CiAgICAgIH0KCiAgICAgIC8vIGFjY2VwdCBbMl0gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5CiAgICAgIHJlID0gL1xbKFxkKStcXS87CgogICAgICBpZiAoYW5jaG9yLm1hdGNoKHJlKSkKICAgICAgewogICAgICAgICB2YXIgbnVtID0gcGFyc2VJbnQoYW5jaG9yLnN1YnN0cmluZygxLCBhbmNob3IubGVuZ3RoLTEpKTsKCiAgICAgICAgIGlmIChudW0gPiB0aGlzLnNsaWRlcy5sZW5ndGgpCiAgICAgICAgICAgIG51bSA9IDE7CgogICAgICAgICBpZiAoLS1udW0gPCAwKQogICAgICAgICAgICBudW0gPSAwOwoKICAgICAgICAgcmV0dXJuIG51bTsKICAgICAgfQoKICAgICAgLy8gb2ggZGVhciB1bmtub3duIGFuY2hvcgogICAgICByZXR1cm4gMDsKICAgIH0KCiAgICAvLyBzZWFyY2ggZm9yIGVuY2xvc2luZyBzbGlkZQoKICAgIHdoaWxlICh0cnVlKQogICAgewogICAgICAvLyBicm93c2VyIGNvZXJjZXMgaHRtbCBlbGVtZW50cyB0byB1cHBlcmNhc2UhCiAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSAiZGl2IiAmJgogICAgICAgICAgICB0aGlzLmhhc19jbGFzcyh0YXJnZXQsICJzbGlkZSIpKQogICAgICB7CiAgICAgICAgLy8gZm91bmQgdGhlIHNsaWRlIGVsZW1lbnQKICAgICAgICBicmVhazsKICAgICAgfQoKICAgICAgLy8gb3RoZXJ3aXNlIHRyeSBwYXJlbnQgZWxlbWVudCBpZiBhbnkKCiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlOwoKICAgICAgaWYgKCF0YXJnZXQpCiAgICAgIHsKICAgICAgICByZXR1cm4gMDsgICAvLyBubyBsdWNrIQogICAgICB9CiAgICB9OwoKICAgIGZvciAoaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyArK2kpCiAgICB7CiAgICAgIGlmIChzbGlkZXNbaV0gPT0gdGFyZ2V0KQogICAgICAgIHJldHVybiBpOyAgLy8gc3VjY2VzcwogICAgfQoKICAgIC8vIG9oIGRlYXIgc3RpbGwgbm8gbHVjawogICAgcmV0dXJuIDA7CiAgfSwKCiAgcHJldmlvdXNfc2xpZGU6IGZ1bmN0aW9uIChpbmNyZW1lbnRhbCkgewogICAgaWYgKCF3M2Nfc2xpZHkudmlld19hbGwpCiAgICB7CiAgICAgIHZhciBzbGlkZTsKCiAgICAgIGlmICgoaW5jcmVtZW50YWwgfHwgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9PSAwKSAmJiB3M2Nfc2xpZHkubGFzdF9zaG93biAhPSBudWxsKQogICAgICB7CiAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSB3M2Nfc2xpZHkuaGlkZV9wcmV2aW91c19pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKTsKICAgICAgICB3M2Nfc2xpZHkuc2V0X2Vvc19zdGF0dXMoZmFsc2UpOwogICAgICB9CiAgICAgIGVsc2UgaWYgKHczY19zbGlkeS5zbGlkZV9udW1iZXIgPiAwKQogICAgICB7CiAgICAgICAgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgIHczY19zbGlkeS5oaWRlX3NsaWRlKHNsaWRlKTsKCiAgICAgICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IHczY19zbGlkeS5zbGlkZV9udW1iZXIgLSAxOwogICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICB3M2Nfc2xpZHkuc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsKCJ2aXNpYmxlIik7CiAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSB3M2Nfc2xpZHkucHJldmlvdXNfaW5jcmVtZW50YWxfaXRlbShudWxsKTsKICAgICAgICB3M2Nfc2xpZHkuc2V0X2Vvc19zdGF0dXModHJ1ZSk7CiAgICAgICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgICB9CgogICAgICB3M2Nfc2xpZHkuc2V0X2xvY2F0aW9uKCk7CgogICAgICBpZiAoIXczY19zbGlkeS5uc19wb3MpCiAgICAgICAgdzNjX3NsaWR5LnJlZnJlc2hfdG9vbGJhcigyMDApOwogICAgfQogIH0sCgogIG5leHRfc2xpZGU6IGZ1bmN0aW9uIChpbmNyZW1lbnRhbCkgewogICAgaWYgKCF3M2Nfc2xpZHkudmlld19hbGwpCiAgICB7CiAgICAgIHZhciBzbGlkZSwgbGFzdCA9IHczY19zbGlkeS5sYXN0X3Nob3duOwoKICAgICAgaWYgKGluY3JlbWVudGFsIHx8IHczY19zbGlkeS5zbGlkZV9udW1iZXIgPT0gdzNjX3NsaWR5LnNsaWRlcy5sZW5ndGggLSAxKQogICAgICAgICB3M2Nfc2xpZHkubGFzdF9zaG93biA9IHczY19zbGlkeS5yZXZlYWxfbmV4dF9pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKTsKCiAgICAgIGlmICgoIWluY3JlbWVudGFsIHx8IHczY19zbGlkeS5sYXN0X3Nob3duID09IG51bGwpICYmCiAgICAgICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyIDwgdzNjX3NsaWR5LnNsaWRlcy5sZW5ndGggLSAxKQogICAgICB7CiAgICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwoKICAgICAgICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IHczY19zbGlkeS5zbGlkZV9udW1iZXIgKyAxOwogICAgICAgICBzbGlkZSA9IHczY19zbGlkeS5zbGlkZXNbdzNjX3NsaWR5LnNsaWRlX251bWJlcl07CiAgICAgICAgIHczY19zbGlkeS5sYXN0X3Nob3duID0gbnVsbDsKICAgICAgICAgdzNjX3NsaWR5LnNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbCgiaGlkZGVuIik7CiAgICAgICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgfQogICAgICBlbHNlIGlmICghdzNjX3NsaWR5Lmxhc3Rfc2hvd24pCiAgICAgIHsKICAgICAgICAgaWYgKGxhc3QgJiYgaW5jcmVtZW50YWwpCiAgICAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSBsYXN0OwogICAgICB9CgogICAgICB3M2Nfc2xpZHkuc2V0X2xvY2F0aW9uKCk7CgogICAgICB3M2Nfc2xpZHkuc2V0X2Vvc19zdGF0dXMoIXczY19zbGlkeS5uZXh0X2luY3JlbWVudGFsX2l0ZW0odzNjX3NsaWR5Lmxhc3Rfc2hvd24pKTsKCiAgICAgIGlmICghdzNjX3NsaWR5Lm5zX3BvcykKICAgICAgICAgdzNjX3NsaWR5LnJlZnJlc2hfdG9vbGJhcigyMDApOwogICAgIH0KICB9LAoKICAvLyB0byBmaXJzdCBzbGlkZSB3aXRoIG5vdGhpbmcgcmV2ZWFsZWQKICAvLyBpLmUuIHN0YXRlIGF0IHN0YXJ0IG9mIHByZXNlbnRhdGlvbgogIGZpcnN0X3NsaWRlOiBmdW5jdGlvbiAoKSB7CiAgICAgaWYgKCF3M2Nfc2xpZHkudmlld19hbGwpCiAgICAgewogICAgICAgdmFyIHNsaWRlOwoKICAgICAgIGlmICh3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyICE9IDApCiAgICAgICB7CiAgICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwoKICAgICAgICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IDA7CiAgICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSBudWxsOwogICAgICAgICB3M2Nfc2xpZHkuc2V0X3Zpc2liaWxpdHlfYWxsX2luY3JlbWVudGFsKCJoaWRkZW4iKTsKICAgICAgICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgICAgfQoKICAgICAgIHczY19zbGlkeS5zZXRfZW9zX3N0YXR1cygKICAgICAgICAgIXczY19zbGlkeS5uZXh0X2luY3JlbWVudGFsX2l0ZW0odzNjX3NsaWR5Lmxhc3Rfc2hvd24pKTsKICAgICAgIHczY19zbGlkeS5zZXRfbG9jYXRpb24oKTsKICAgICB9CiAgfSwKCiAgLy8gZ290byBsYXN0IHNsaWRlIHdpdGggZXZlcnl0aGluZyByZXZlYWxlZAogIC8vIGkuZS4gc3RhdGUgYXQgZW5kIG9mIHByZXNlbnRhdGlvbgogIGxhc3Rfc2xpZGU6IGZ1bmN0aW9uICgpIHsKICAgIGlmICghdzNjX3NsaWR5LnZpZXdfYWxsKQogICAgewogICAgICB2YXIgc2xpZGU7CgogICAgICB3M2Nfc2xpZHkubGFzdF9zaG93biA9IG51bGw7IC8vcmV2ZWFsTmV4dEl0ZW0obGFzdFNob3duKTsKCiAgICAgIGlmICh3M2Nfc2xpZHkubGFzdF9zaG93biA9PSBudWxsICYmCiAgICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyIDwgdzNjX3NsaWR5LnNsaWRlcy5sZW5ndGggLSAxKQogICAgICB7CiAgICAgICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgICAgICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwogICAgICAgICB3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyID0gdzNjX3NsaWR5LnNsaWRlcy5sZW5ndGggLSAxOwogICAgICAgICBzbGlkZSA9IHczY19zbGlkeS5zbGlkZXNbdzNjX3NsaWR5LnNsaWRlX251bWJlcl07CiAgICAgICAgIHczY19zbGlkeS5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoInZpc2libGUiKTsKICAgICAgICAgdzNjX3NsaWR5Lmxhc3Rfc2hvd24gPSB3M2Nfc2xpZHkucHJldmlvdXNfaW5jcmVtZW50YWxfaXRlbShudWxsKTsKCiAgICAgICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgfQogICAgICBlbHNlCiAgICAgIHsKICAgICAgICAgdzNjX3NsaWR5LnNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbCgidmlzaWJsZSIpOwogICAgICAgICB3M2Nfc2xpZHkubGFzdF9zaG93biA9IHczY19zbGlkeS5wcmV2aW91c19pbmNyZW1lbnRhbF9pdGVtKG51bGwpOwogICAgICB9CgogICAgICB3M2Nfc2xpZHkuc2V0X2Vvc19zdGF0dXModHJ1ZSk7CiAgICAgIHczY19zbGlkeS5zZXRfbG9jYXRpb24oKTsKICAgIH0KICB9LAoKCiAgLy8gIyMjIGNoZWNrIHRoaXMgYW5kIGNvbnNpZGVyIGFkZC9yZW1vdmUgY2xhc3MKICBzZXRfZW9zX3N0YXR1czogZnVuY3Rpb24gKHN0YXRlKSB7CiAgICBpZiAodGhpcy5lb3MpCiAgICAgIHRoaXMuZW9zLnN0eWxlLmNvbG9yID0gKHN0YXRlID8gInJnYigyNDAsMjQwLDI0MCkiIDogInJlZCIpOwogIH0sCgogIC8vIGZpcnN0IHNsaWRlIGlzIDAKICBnb3RvX3NsaWRlOiBmdW5jdGlvbiAobnVtKSB7CiAgICAvL2FsZXJ0KCJnb2luZyB0byBzbGlkZSAiICsgKG51bSsxKSk7CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwogICAgdzNjX3NsaWR5LnNsaWRlX251bWJlciA9IG51bTsKICAgIHNsaWRlID0gdzNjX3NsaWR5LnNsaWRlc1t3M2Nfc2xpZHkuc2xpZGVfbnVtYmVyXTsKICAgIHczY19zbGlkeS5sYXN0X3Nob3duID0gbnVsbDsKICAgIHczY19zbGlkeS5zZXRfdmlzaWJpbGl0eV9hbGxfaW5jcmVtZW50YWwoImhpZGRlbiIpOwogICAgdzNjX3NsaWR5LnNldF9lb3Nfc3RhdHVzKCF3M2Nfc2xpZHkubmV4dF9pbmNyZW1lbnRhbF9pdGVtKHczY19zbGlkeS5sYXN0X3Nob3duKSk7CiAgICBkb2N1bWVudC50aXRsZSA9IHczY19zbGlkeS50aXRsZSArICIgKCIgKyAodzNjX3NsaWR5LnNsaWRlX251bWJlcisxKSArICIpIjsKICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgIHczY19zbGlkeS5zaG93X3NsaWRlX251bWJlcigpOwogIH0sCgoKICBzaG93X3NsaWRlOiBmdW5jdGlvbiAoc2xpZGUpIHsKICAgIHRoaXMuc3luY19iYWNrZ3JvdW5kKHNsaWRlKTsKICAgIHRoaXMucmVtb3ZlX2NsYXNzKHNsaWRlLCAiaGlkZGVuIik7CgogICAgLy8gd29yayBhcm91bmQgSUU5IG9iamVjdCByZW5kZXJpbmcgYnVnCiAgICBzZXRUaW1lb3V0KCJ3aW5kb3cuc2Nyb2xsVG8oMCwwKTsiLCAxKTsKICB9LAoKICBoaWRlX3NsaWRlOiBmdW5jdGlvbiAoc2xpZGUpIHsKICAgIHRoaXMuYWRkX2NsYXNzKHNsaWRlLCAiaGlkZGVuIik7CiAgfSwKCiAgc2V0X2ZvY3VzOiBmdW5jdGlvbiAoZWxlbWVudCkKICB7CiAgICBpZiAoZWxlbWVudCkKICAgICAgZWxlbWVudC5mb2N1cygpOwogICAgZWxzZQogICAgewogICAgICB3M2Nfc2xpZHkuaGVscF9hbmNob3IuZm9jdXMoKTsKCiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAgICAgICAgdzNjX3NsaWR5LmhlbHBfYW5jaG9yLmJsdXIoKTsKICAgICAgfSwgMSk7CiAgICB9CiAgfSwKCiAgLy8gc2hvdyBqdXN0IHRoZSBiYWNrZ3JvdW5kcyBwZXJ0aW5lbnQgdG8gdGhpcyBzbGlkZQogIC8vIHdoZW4gc2xpZGUgYmFja2dyb3VuZC1jb2xvciBpcyB0cmFuc3BhcmVudAogIC8vIHRoaXMgc2hvdWxkIG5vdyB3b3JrIHdpdGggcmdiYSBjb2xvciB2YWx1ZXMKICBzeW5jX2JhY2tncm91bmQ6IGZ1bmN0aW9uIChzbGlkZSkgewogICAgdmFyIGJhY2tncm91bmQ7CiAgICB2YXIgYmdDb2xvcjsKCiAgICBpZiAoc2xpZGUuY3VycmVudFN0eWxlKQogICAgICBiZ0NvbG9yID0gc2xpZGUuY3VycmVudFN0eWxlWyJiYWNrZ3JvdW5kQ29sb3IiXTsKICAgIGVsc2UgaWYgKGRvY3VtZW50LmRlZmF1bHRWaWV3KQogICAgewogICAgICB2YXIgc3R5bGVzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShzbGlkZSxudWxsKTsKCiAgICAgIGlmIChzdHlsZXMpCiAgICAgICAgYmdDb2xvciA9IHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCJiYWNrZ3JvdW5kLWNvbG9yIik7CiAgICAgIGVsc2UgLy8gYnJva2VuIGltcGxlbWVudGF0aW9uIHByb2JhYmx5IGR1ZSBTYWZhcmkgb3IgS29ucXVlcm9yCiAgICAgIHsKICAgICAgICAvL2FsZXJ0KCJkZWZlY3RpdmUgaW1wbGVtZW50YXRpb24gb2YgZ2V0Q29tcHV0ZWRTdHlsZSgpIik7CiAgICAgICAgYmdDb2xvciA9ICJ0cmFuc3BhcmVudCI7CiAgICAgIH0KICAgIH0KICAgIGVsc2UKICAgICAgYmdDb2xvciA9PSAidHJhbnNwYXJlbnQiOwoKICAgIGlmIChiZ0NvbG9yID09ICJ0cmFuc3BhcmVudCIgfHwKICAgICAgICBiZ0NvbG9yLmluZGV4T2YoInJnYmEiKSA+PSAwIHx8CiAgICAgICAgYmdDb2xvci5pbmRleE9mKCJvcGFjaXR5IikgPj0gMCkKICAgIHsKICAgICAgdmFyIHNsaWRlQ2xhc3MgPSB0aGlzLmdldF9jbGFzc19saXN0KHNsaWRlKTsKCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5iYWNrZ3JvdW5kcy5sZW5ndGg7IGkrKykKICAgICAgewogICAgICAgIGJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmRzW2ldOwoKICAgICAgICB2YXIgYmdDbGFzcyA9IHRoaXMuZ2V0X2NsYXNzX2xpc3QoYmFja2dyb3VuZCk7CgogICAgICAgIGlmICh0aGlzLm1hdGNoaW5nX2JhY2tncm91bmQoc2xpZGVDbGFzcywgYmdDbGFzcykpCiAgICAgICAgICB0aGlzLnJlbW92ZV9jbGFzcyhiYWNrZ3JvdW5kLCAiaGlkZGVuIik7CiAgICAgICAgZWxzZQogICAgICAgICAgdGhpcy5hZGRfY2xhc3MoYmFja2dyb3VuZCwgImhpZGRlbiIpOwogICAgICB9CiAgICB9CiAgICBlbHNlIC8vIGZvcmNpYmx5IGhpZGUgYWxsIGJhY2tncm91bmRzCiAgICAgIHRoaXMuaGlkZV9iYWNrZ3JvdW5kcygpOwogIH0sCgogIGhpZGVfYmFja2dyb3VuZHM6IGZ1bmN0aW9uICgpIHsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5iYWNrZ3JvdW5kcy5sZW5ndGg7IGkrKykKICAgIHsKICAgICAgYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZHNbaV07CiAgICAgIHRoaXMuYWRkX2NsYXNzKGJhY2tncm91bmQsICJoaWRkZW4iKTsKICAgIH0KICB9LAoKICAvLyBjb21wYXJlIGNsYXNzZXMgZm9yIHNsaWRlIGFuZCBiYWNrZ3JvdW5kCiAgbWF0Y2hpbmdfYmFja2dyb3VuZDogZnVuY3Rpb24gKHNsaWRlQ2xhc3MsIGJnQ2xhc3MpIHsKICAgIHZhciBpLCBjb3VudCwgcGF0dGVybiwgcmVzdWx0OwoKICAgIC8vIGRlZmluZSBwYXR0ZXJuIGFzIHJlZ3VsYXIgZXhwcmVzc2lvbgogICAgcGF0dGVybiA9IC9cdysvZzsKCiAgICAvLyBjaGVjayBiYWNrZ3JvdW5kIGNsYXNzIG5hbWVzCiAgICByZXN1bHQgPSBiZ0NsYXNzLm1hdGNoKHBhdHRlcm4pOwoKICAgIGZvciAoaSA9IGNvdW50ID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykKICAgIHsKICAgICAgaWYgKHJlc3VsdFtpXSA9PSAiaGlkZGVuIikKICAgICAgICBjb250aW51ZTsKCiAgICAgIGlmIChyZXN1bHRbaV0gPT0gImJhY2tncm91bmQiKQoJY29udGludWU7CgogICAgICArK2NvdW50OwogICAgfQoKICAgIGlmIChjb3VudCA9PSAwKSAgLy8gZGVmYXVsdCBtYXRjaAogICAgICByZXR1cm4gdHJ1ZTsKCiAgICAvLyBjaGVjayBmb3IgbWF0Y2hlcyBhbmQgcGxhY2UgcmVzdWx0IGluIGFycmF5CiAgICByZXN1bHQgPSBzbGlkZUNsYXNzLm1hdGNoKHBhdHRlcm4pOwoKICAgIC8vIG5vdyBjaGVjayBpZiBkZXNpcmVkIG5hbWUgaXMgcHJlc2VudCBmb3IgYmFja2dyb3VuZAogICAgZm9yIChpID0gY291bnQgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKQogICAgewogICAgICBpZiAocmVzdWx0W2ldID09ICJoaWRkZW4iKQogICAgICAgIGNvbnRpbnVlOwoKICAgICAgaWYgKHRoaXMuaGFzX3Rva2VuKGJnQ2xhc3MsIHJlc3VsdFtpXSkpCiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgcmV0dXJuIGZhbHNlOwogIH0sCgogIHJlc2l6ZWQ6IGZ1bmN0aW9uICgpIHsKICAgICB2YXIgd2lkdGggPSAwOwoKICAgICBpZiAoIHR5cGVvZiggd2luZG93LmlubmVyV2lkdGggKSA9PSAnbnVtYmVyJyApCiAgICAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoOyAgLy8gTm9uIElFIGJyb3dzZXIKICAgICBlbHNlIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKQogICAgICAgd2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7ICAvLyBJRTYKICAgICBlbHNlIGlmIChkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgpCiAgICAgICB3aWR0aCA9IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7IC8vIElFNAoKICAgICB2YXIgaGVpZ2h0ID0gMDsKCiAgICAgaWYgKCB0eXBlb2YoIHdpbmRvdy5pbm5lckhlaWdodCApID09ICdudW1iZXInICkKICAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDsgIC8vIE5vbiBJRSBicm93c2VyCiAgICAgZWxzZSBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpCiAgICAgICBoZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0OyAgLy8gSUU2CiAgICAgZWxzZSBpZiAoZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCkKICAgICAgIGhlaWdodCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyAvLyBJRTQKCiAgICAgaWYgKGhlaWdodCAmJiAod2lkdGgvaGVpZ2h0ID4gMS4wNSoxMDI0Lzc2OCkpCiAgICAgewogICAgICAgd2lkdGggPSBoZWlnaHQgKiAxMDI0LjAvNzY4OwogICAgIH0KCiAgICAgLy8gSUUgZmlyZXMgb25yZXNpemUgZXZlbiB3aGVuIG9ubHkgZm9udCBzaXplIGlzIGNoYW5nZWQhCiAgICAgLy8gc28gd2UgZG8gYSBjaGVjayB0byBhdm9pZCBibG9ja2luZyA8IGFuZCA+IGFjdGlvbnMKICAgICBpZiAod2lkdGggIT0gdzNjX3NsaWR5Lmxhc3Rfd2lkdGggfHwgaGVpZ2h0ICE9IHczY19zbGlkeS5sYXN0X2hlaWdodCkKICAgICB7CiAgICAgICBpZiAod2lkdGggPj0gMTEwMCkKICAgICAgICAgdzNjX3NsaWR5LnNpemVfaW5kZXggPSA1OyAgICAvLyA0CiAgICAgICBlbHNlIGlmICh3aWR0aCA+PSAxMDAwKQogICAgICAgICB3M2Nfc2xpZHkuc2l6ZV9pbmRleCA9IDQ7ICAgIC8vIDMKICAgICAgIGVsc2UgaWYgKHdpZHRoID49IDgwMCkKICAgICAgICAgdzNjX3NsaWR5LnNpemVfaW5kZXggPSAzOyAgICAvLyAyCiAgICAgICBlbHNlIGlmICh3aWR0aCA+PSA2MDApCiAgICAgICAgIHczY19zbGlkeS5zaXplX2luZGV4ID0gMjsgICAgLy8gMQogICAgICAgZWxzZSBpZiAod2lkdGgpCiAgICAgICAgIHczY19zbGlkeS5zaXplX2luZGV4ID0gMDsKCiAgICAgICAvLyBhZGQgaW4gZm9udCBzaXplIGFkanVzdG1lbnQgZnJvbSBtZXRhIGVsZW1lbnQgZS5nLgogICAgICAgLy8gPG1ldGEgbmFtZT0iZm9udC1zaXplLWFkanVzdG1lbnQiIGNvbnRlbnQ9Ii0yIiAvPgogICAgICAgLy8gdXNlZnVsIHdoZW4gc2xpZGVzIGhhdmUgdG9vIG11Y2ggY29udGVudCA7LSkKCiAgICAgICBpZiAoMCA8PSB3M2Nfc2xpZHkuc2l6ZV9pbmRleCArIHczY19zbGlkeS5zaXplX2FkanVzdG1lbnQgJiYKICAgICAgICAgICAgIHczY19zbGlkeS5zaXplX2luZGV4ICsgdzNjX3NsaWR5LnNpemVfYWRqdXN0bWVudCA8IHczY19zbGlkeS5zaXplcy5sZW5ndGgpCiAgICAgICAgIHczY19zbGlkeS5zaXplX2luZGV4ID0gdzNjX3NsaWR5LnNpemVfaW5kZXggKyB3M2Nfc2xpZHkuc2l6ZV9hZGp1c3RtZW50OwoKICAgICAgIC8vIGVuYWJsZXMgY3Jvc3MgYnJvd3NlciB1c2Ugb2YgcmVsYXRpdmUgd2lkdGgvaGVpZ2h0CiAgICAgICAvLyBvbiBvYmplY3QgZWxlbWVudHMgZm9yIHVzZSB3aXRoIFNWRyBhbmQgRmxhc2ggbWVkaWEKICAgICAgIHczY19zbGlkeS5hZGp1c3Rfb2JqZWN0X2RpbWVuc2lvbnMod2lkdGgsIGhlaWdodCk7CgogICAgICAgaWYgKGRvY3VtZW50LmJvZHkuc3R5bGUuZm9udFNpemUgIT0gdzNjX3NsaWR5LnNpemVzW3czY19zbGlkeS5zaXplX2luZGV4XSkKICAgICAgIHsKICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5mb250U2l6ZSA9IHczY19zbGlkeS5zaXplc1t3M2Nfc2xpZHkuc2l6ZV9pbmRleF07CiAgICAgICB9CgogICAgICAgdzNjX3NsaWR5Lmxhc3Rfd2lkdGggPSB3aWR0aDsKICAgICAgIHczY19zbGlkeS5sYXN0X2hlaWdodCA9IGhlaWdodDsKCiAgICAgICAvLyBmb3JjZSByZWZsb3cgdG8gd29yayBhcm91bmQgTW96aWxsYSBidWcKICAgICAgIGlmICh3M2Nfc2xpZHkubnNfcG9zKQogICAgICAgewogICAgICAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgICAgICB3M2Nfc2xpZHkuaGlkZV9zbGlkZShzbGlkZSk7CiAgICAgICAgIHczY19zbGlkeS5zaG93X3NsaWRlKHNsaWRlKTsKICAgICAgIH0KCiAgICAgICAvLyBmb3JjZSBjb3JyZWN0IHBvc2l0aW9uaW5nIG9mIHRvb2xiYXIKICAgICAgIHczY19zbGlkeS5yZWZyZXNoX3Rvb2xiYXIoMjAwKTsKICAgICB9CiAgfSwKCiAgc2Nyb2xsZWQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh3M2Nfc2xpZHkudG9vbGJhciAmJiAhdzNjX3NsaWR5Lm5zX3BvcyAmJiAhdzNjX3NsaWR5LmllNykKICAgIHsKICAgICAgdzNjX3NsaWR5LmhhY2tfb2Zmc2V0ID0gdzNjX3NsaWR5LnNjcm9sbF94X29mZnNldCgpOwogICAgICAvLyBoaWRlIHRvb2xiYXIKICAgICAgdzNjX3NsaWR5LnRvb2xiYXIuc3R5bGUuZGlzcGxheSA9ICJub25lIjsKCiAgICAgIC8vIG1ha2UgaXQgcmVhcHBlYXIgbGF0ZXIKICAgICAgaWYgKHczY19zbGlkeS5zY3JvbGxoYWNrID09IDAgJiYgIXczY19zbGlkeS52aWV3X2FsbCkKICAgICAgewogICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge3czY19zbGlkeS5zaG93X3Rvb2xiYXIoKTsgfSwgMTAwMCk7CiAgICAgICAgdzNjX3NsaWR5LnNjcm9sbGhhY2sgPSAxOwogICAgICB9CiAgICB9CiAgfSwKCiAgaGlkZV90b29sYmFyOiBmdW5jdGlvbiAoKSB7CiAgICB3M2Nfc2xpZHkuYWRkX2NsYXNzKHczY19zbGlkeS50b29sYmFyLCAiaGlkZGVuIik7CiAgICB3aW5kb3cuZm9jdXMoKTsKICB9LAoKICAvLyB1c2VkIHRvIGVuc3VyZSBJRSByZWZyZXNoZXMgdG9vbGJhciBpbiBjb3JyZWN0IHBvc2l0aW9uCiAgcmVmcmVzaF90b29sYmFyOiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHsKICAgIGlmICghdzNjX3NsaWR5Lm5zX3BvcyAmJiAhdzNjX3NsaWR5LmllNykKICAgIHsKICAgICAgdzNjX3NsaWR5LmhpZGVfdG9vbGJhcigpOwogICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHt3M2Nfc2xpZHkuc2hvd190b29sYmFyKCk7fSwgaW50ZXJ2YWwpOwogICAgfQogIH0sCgogIC8vIHJlc3RvcmVzIHRvb2xiYXIgYWZ0ZXIgc2hvcnQgZGVsYXkKICBzaG93X3Rvb2xiYXI6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh3M2Nfc2xpZHkud2FudF90b29sYmFyKQogICAgewogICAgICB3M2Nfc2xpZHkudG9vbGJhci5zdHlsZS5kaXNwbGF5ID0gImJsb2NrIjsKCiAgICAgIGlmICghdzNjX3NsaWR5Lm5zX3BvcykKICAgICAgewogICAgICAgIC8vIGFkanVzdCBwb3NpdGlvbiB0byBhbGxvdyBmb3Igc2Nyb2xsaW5nCiAgICAgICAgdmFyIHhvZmZzZXQgPSB3M2Nfc2xpZHkuc2Nyb2xsX3hfb2Zmc2V0KCk7CiAgICAgICAgdzNjX3NsaWR5LnRvb2xiYXIuc3R5bGUubGVmdCA9IHhvZmZzZXQ7CiAgICAgICAgdzNjX3NsaWR5LnRvb2xiYXIuc3R5bGUucmlnaHQgPSB4b2Zmc2V0OwoKICAgICAgICAvLyBkZXRlcm1pbmUgdmVydGljYWwgc2Nyb2xsIG9mZnNldAogICAgICAgIC8vdmFyIHlvZmZzZXQgPSBzY3JvbGxZT2Zmc2V0KCk7CgogICAgICAgIC8vIGJvdHRvbSBpcyBkb2MgaGVpZ2h0IC0gd2luZG93IGhlaWdodCAtIHNjcm9sbCBvZmZzZXQKICAgICAgICAvL3ZhciBib3R0b20gPSBkb2N1bWVudEhlaWdodCgpIC0gbGFzdEhlaWdodCAtIHlvZmZzZXQKCiAgICAgICAgLy9pZiAoeW9mZnNldCA+IDAgfHwgZG9jdW1lbnRIZWlnaHQoKSA+IGxhc3RIZWlnaHQpCiAgICAgICAgLy8gICBib3R0b20gKz0gMTY7ICAvLyBhbGxvdyBmb3IgaGVpZ2h0IG9mIHNjcm9sbGJhcgoKICAgICAgICB3M2Nfc2xpZHkudG9vbGJhci5zdHlsZS5ib3R0b20gPSAwOyAvL2JvdHRvbTsKICAgICAgfQoKICAgICAgdzNjX3NsaWR5LnJlbW92ZV9jbGFzcyh3M2Nfc2xpZHkudG9vbGJhciwgImhpZGRlbiIpOwogICAgfQoKICAgIHczY19zbGlkeS5zY3JvbGxoYWNrID0gMDsKCgogICAgLy8gc2V0IHRoZSBrZXlib2FyZCBmb2N1cyB0byB0aGUgaGVscCBsaW5rIG9uIHRoZQogICAgLy8gdG9vbGJhciB0byBlbnN1cmUgdGhhdCBkb2N1bWVudCBoYXMgdGhlIGZvY3VzCiAgICAvLyBJRSBkb2Vzbid0IGFsd2F5cyB3b3JrIHdpdGggd2luZG93LmZvY3VzKCkKICAgIC8vIGFuZCB0aGlzIGhhY2sgaGFzIGJlbmVmaXQgb2YgRW50ZXIgZm9yIGhlbHAKCiAgICB0cnkKICAgIHsKICAgICAgaWYgKCF3M2Nfc2xpZHkub3BlcmEpCiAgICAgICAgdzNjX3NsaWR5LnNldF9mb2N1cygpOwogICAgfQogICAgY2F0Y2ggKGUpCiAgICB7CiAgICB9CiAgfSwKCi8vIGludm9rZWQgdmlhIEYga2V5CiAgdG9nZ2xlX3Rvb2xiYXI6IGZ1bmN0aW9uICgpIHsKICAgIGlmICghdzNjX3NsaWR5LnZpZXdfYWxsKQogICAgewogICAgICBpZiAodzNjX3NsaWR5Lmhhc19jbGFzcyh3M2Nfc2xpZHkudG9vbGJhciwgImhpZGRlbiIpKQogICAgICB7CiAgICAgICAgdzNjX3NsaWR5LnJlbW92ZV9jbGFzcyh3M2Nfc2xpZHkudG9vbGJhciwgImhpZGRlbiIpCiAgICAgICAgdzNjX3NsaWR5LndhbnRfdG9vbGJhciA9IDE7CiAgICAgIH0KICAgICAgZWxzZQogICAgICB7CiAgICAgICAgdzNjX3NsaWR5LmFkZF9jbGFzcyh3M2Nfc2xpZHkudG9vbGJhciwgImhpZGRlbiIpCiAgICAgICAgdzNjX3NsaWR5LndhbnRfdG9vbGJhciA9IDA7CiAgICAgIH0KICAgIH0KICB9LAoKICBzY3JvbGxfeF9vZmZzZXQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh3aW5kb3cucGFnZVhPZmZzZXQpCiAgICAgIHJldHVybiBzZWxmLnBhZ2VYT2Zmc2V0OwoKICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgCiAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCkKICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0OwoKICAgIGlmIChkb2N1bWVudC5ib2R5KQogICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0OwoKICAgIHJldHVybiAwOwogIH0sCgogIHNjcm9sbF95X29mZnNldDogZnVuY3Rpb24gKCkgewogICAgaWYgKHdpbmRvdy5wYWdlWU9mZnNldCkKICAgICAgcmV0dXJuIHNlbGYucGFnZVlPZmZzZXQ7CgogICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAKICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApCiAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wOwoKICAgIGlmIChkb2N1bWVudC5ib2R5KQogICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7CgogICAgcmV0dXJuIDA7CiAgfSwKCiAgLy8gbG9va2luZyBmb3IgYSB3YXkgdG8gZGV0ZXJtaW5lIGhlaWdodCBvZiBzbGlkZSBjb250ZW50CiAgLy8gdGhlIHNsaWRlIGl0c2VsZiBpcyBzZXQgdG8gdGhlIGhlaWdodCBvZiB0aGUgd2luZG93CiAgb3B0aW1pemVfZm9udF9zaXplOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwoKICAgIC8vdmFyIGRoID0gZG9jdW1lbnRIZWlnaHQoKTsgLy9nZXREb2NIZWlnaHQoZG9jdW1lbnQpOwogICAgdmFyIGRoID0gc2xpZGUuc2Nyb2xsSGVpZ2h0OwogICAgdmFyIHdoID0gZ2V0V2luZG93SGVpZ2h0KCk7CiAgICB2YXIgdSA9IDEwMCAqIGRoIC8gd2g7CgogICAgYWxlcnQoIndpbmRvdyB1dGlsaXphdGlvbiA9ICIgKyB1ICsgIiUgKGRvYyAiCiAgICAgICsgZGggKyAiIHdpbiAiICsgd2ggKyAiKSIpOwogIH0sCgogIC8vIGZyb20gZG9jdW1lbnQgb2JqZWN0CiAgZ2V0X2RvY19oZWlnaHQ6IGZ1bmN0aW9uIChkb2MpIHsKICAgIGlmICghZG9jKQogICAgICBkb2MgPSBkb2N1bWVudDsKCiAgICBpZiAoZG9jICYmIGRvYy5ib2R5ICYmIGRvYy5ib2R5Lm9mZnNldEhlaWdodCkKICAgICAgcmV0dXJuIGRvYy5ib2R5Lm9mZnNldEhlaWdodDsgIC8vIG5zL2dlY2tvIHN5bnRheAoKICAgIGlmIChkb2MgJiYgZG9jLmJvZHkgJiYgZG9jLmJvZHkuc2Nyb2xsSGVpZ2h0KQogICAgICByZXR1cm4gZG9jLmJvZHkuc2Nyb2xsSGVpZ2h0OwoKICAgIGFsZXJ0KCJjb3VsZG4ndCBkZXRlcm1pbmUgZG9jdW1lbnQgaGVpZ2h0Iik7CiAgfSwKCiAgZ2V0X3dpbmRvd19oZWlnaHQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICggdHlwZW9mKCB3aW5kb3cuaW5uZXJIZWlnaHQgKSA9PSAnbnVtYmVyJyApCiAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQ7ICAvLyBOb24gSUUgYnJvd3NlcgoKICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkKICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7ICAvLyBJRTYKCiAgICBpZiAoZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCkKICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyAvLyBJRTQKICB9LAoKICBkb2N1bWVudF9oZWlnaHQ6IGZ1bmN0aW9uICgpIHsKICAgIHZhciBzaCwgb2g7CgogICAgc2ggPSBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodDsKICAgIG9oID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7CgogICAgaWYgKHNoICYmIG9oKQogICAgewogICAgICByZXR1cm4gKHNoID4gb2ggPyBzaCA6IG9oKTsKICAgIH0KCiAgICAvLyBubyBpZGVhIQogICAgcmV0dXJuIDA7CiAgfSwKCiAgc21hbGxlcjogZnVuY3Rpb24gKCkgewogICAgaWYgKHczY19zbGlkeS5zaXplX2luZGV4ID4gMCkKICAgIHsKICAgICAgLS13M2Nfc2xpZHkuc2l6ZV9pbmRleDsKICAgIH0KCiAgICB3M2Nfc2xpZHkudG9vbGJhci5zdHlsZS5kaXNwbGF5ID0gIm5vbmUiOwogICAgZG9jdW1lbnQuYm9keS5zdHlsZS5mb250U2l6ZSA9IHczY19zbGlkeS5zaXplc1t3M2Nfc2xpZHkuc2l6ZV9pbmRleF07CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwogICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7dzNjX3NsaWR5LnNob3dfdG9vbGJhcigpOyB9LCA1MCk7CiAgfSwKCiAgYmlnZ2VyOiBmdW5jdGlvbiAoKSB7CiAgICBpZiAodzNjX3NsaWR5LnNpemVfaW5kZXggPCB3M2Nfc2xpZHkuc2l6ZXMubGVuZ3RoIC0gMSkKICAgIHsKICAgICAgKyt3M2Nfc2xpZHkuc2l6ZV9pbmRleDsKICAgIH0KCiAgICB3M2Nfc2xpZHkudG9vbGJhci5zdHlsZS5kaXNwbGF5ID0gIm5vbmUiOwogICAgZG9jdW1lbnQuYm9keS5zdHlsZS5mb250U2l6ZSA9IHczY19zbGlkeS5zaXplc1t3M2Nfc2xpZHkuc2l6ZV9pbmRleF07CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwogICAgdzNjX3NsaWR5LmhpZGVfc2xpZGUoc2xpZGUpOwogICAgdzNjX3NsaWR5LnNob3dfc2xpZGUoc2xpZGUpOwogICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7dzNjX3NsaWR5LnNob3dfdG9vbGJhcigpOyB9LCA1MCk7CiAgfSwKCiAgLy8gZW5hYmxlcyBjcm9zcyBicm93c2VyIHVzZSBvZiByZWxhdGl2ZSB3aWR0aC9oZWlnaHQKICAvLyBvbiBvYmplY3QgZWxlbWVudHMgZm9yIHVzZSB3aXRoIFNWRyBhbmQgRmxhc2ggbWVkaWEKICAvLyB3aXRoIHRoYW5rcyB0byBJdmFuIEhlcm1hbiBmb3IgdGhlIHN1Z2dlc3Rpb24KICBhZGp1c3Rfb2JqZWN0X2RpbWVuc2lvbnM6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7CiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHczY19zbGlkeS5vYmplY3RzLmxlbmd0aDsgaSsrICkKICAgIHsKICAgICAgdmFyIG9iaiA9IHRoaXMub2JqZWN0c1tpXTsKICAgICAgdmFyIG1pbWVUeXBlID0gb2JqLmdldEF0dHJpYnV0ZSgidHlwZSIpOwoKICAgICAgaWYgKG1pbWVUeXBlID09ICJpbWFnZS9zdmcreG1sIiB8fCBtaW1lVHlwZSA9PSAiYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2giKQogICAgICB7CiAgICAgICAgaWYgKCAhb2JqLmluaXRpYWxXaWR0aCApIAogICAgICAgICAgb2JqLmluaXRpYWxXaWR0aCA9IG9iai5nZXRBdHRyaWJ1dGUoIndpZHRoIik7CgogICAgICAgIGlmICggIW9iai5pbml0aWFsSGVpZ2h0ICkgCiAgICAgICAgICBvYmouaW5pdGlhbEhlaWdodCA9IG9iai5nZXRBdHRyaWJ1dGUoImhlaWdodCIpOwoKICAgICAgICBpZiAoIG9iai5pbml0aWFsV2lkdGggJiYgb2JqLmluaXRpYWxXaWR0aC5jaGFyQXQob2JqLmluaXRpYWxXaWR0aC5sZW5ndGgtMSkgPT0gIiUiICkKICAgICAgICB7CiAgICAgICAgICB2YXIgdyA9IHBhcnNlSW50KG9iai5pbml0aWFsV2lkdGguc2xpY2UoMCwgb2JqLmluaXRpYWxXaWR0aC5sZW5ndGgtMSkpOwogICAgICAgICAgdmFyIG5ld1cgPSB3aWR0aCAqICh3LzEwMC4wKTsKICAgICAgICAgIG9iai5zZXRBdHRyaWJ1dGUoIndpZHRoIixuZXdXKTsKICAgICAgICB9CgogICAgICAgIGlmICggb2JqLmluaXRpYWxIZWlnaHQgJiYKICAgICAgICAgICAgIG9iai5pbml0aWFsSGVpZ2h0LmNoYXJBdChvYmouaW5pdGlhbEhlaWdodC5sZW5ndGgtMSkgPT0gIiUiICkKICAgICAgICB7CiAgICAgICAgICB2YXIgaCA9IHBhcnNlSW50KG9iai5pbml0aWFsSGVpZ2h0LnNsaWNlKDAsIG9iai5pbml0aWFsSGVpZ2h0Lmxlbmd0aC0xKSk7CiAgICAgICAgICB2YXIgbmV3SCA9IGhlaWdodCAqIChoLzEwMC4wKTsKICAgICAgICAgIG9iai5zZXRBdHRyaWJ1dGUoImhlaWdodCIsIG5ld0gpOwogICAgICAgIH0KICAgICAgfQogICAgfQogIH0sCgogIC8vIG5lZWRlZCBmb3IgT3BlcmEgdG8gaW5oaWJpdCBkZWZhdWx0IGJlaGF2aW9yCiAgLy8gc2luY2UgT3BlcmEgZGVsaXZlcnMga2V5UHJlc3MgZXZlbiBpZiBrZXlEb3duCiAgLy8gd2FzIGNhbmNlbGxlZAogIGtleV9wcmVzczogZnVuY3Rpb24gKGV2ZW50KSB7CiAgICBpZiAoIWV2ZW50KQogICAgICBldmVudCA9IHdpbmRvdy5ldmVudDsKCiAgICBpZiAoIXczY19zbGlkeS5rZXlfd2FudGVkKQogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CgogICAgcmV0dXJuIHRydWU7CiAgfSwKCiAgLy8gIFNlZSBlLmcuIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzL2tleXMuaHRtbCBmb3Iga2V5Y29kZXMKICBrZXlfZG93bjogZnVuY3Rpb24gKGV2ZW50KSB7CiAgICB2YXIga2V5LCB0YXJnZXQsIHRhZzsKCiAgICB3M2Nfc2xpZHkua2V5X3dhbnRlZCA9IHRydWU7CgogICAgaWYgKCFldmVudCkKICAgICAgZXZlbnQgPSB3aW5kb3cuZXZlbnQ7CgogICAgLy8ga2x1ZGdlIGFyb3VuZCBOUy9JRSBkaWZmZXJlbmNlcyAKICAgIGlmICh3aW5kb3cuZXZlbnQpCiAgICB7CiAgICAgIGtleSA9IHdpbmRvdy5ldmVudC5rZXlDb2RlOwogICAgICB0YXJnZXQgPSB3aW5kb3cuZXZlbnQuc3JjRWxlbWVudDsKICAgIH0KICAgIGVsc2UgaWYgKGV2ZW50LndoaWNoKQogICAgewogICAgICBrZXkgPSBldmVudC53aGljaDsKICAgICAgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0OwogICAgfQogICAgZWxzZQogICAgICByZXR1cm4gdHJ1ZTsgLy8gWWlrZXMhIHVua25vd24gYnJvd3NlcgoKICAgIC8vIGlnbm9yZSBldmVudCBpZiBrZXkgdmFsdWUgaXMgemVybwogICAgLy8gYXMgZm9yIGFsdCBvbiBPcGVyYSBhbmQgS29ucXVlcm9yCiAgICBpZiAoIWtleSkKICAgICAgIHJldHVybiB0cnVlOwoKICAgIC8vIGF2b2lkIGludGVyZmVyaW5nIHdpdGgga2V5c3Ryb2tlCiAgICAvLyBiZWhhdmlvciBmb3Igbm9uLXNsaWR5IGNocm9tZSBlbGVtZW50cwogICAgaWYgKCF3M2Nfc2xpZHkuc2xpZHlfY2hyb21lKHRhcmdldCkgJiYKICAgICAgICB3M2Nfc2xpZHkuc3BlY2lhbF9lbGVtZW50KHRhcmdldCkpCiAgICAgIHJldHVybiB0cnVlOwoKICAgIC8vIGNoZWNrIGZvciBjb25jdXJyZW50IGNvbnRyb2wvY29tbWFuZC9hbHQga2V5CiAgICAvLyBidXQgYXJlIHRoZXNlIG9ubHkgcHJlc2VudCBvbiBtb3VzZSBldmVudHM/CgogICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkpCiAgICAgICByZXR1cm4gdHJ1ZTsKCiAgICAvLyBkaXNtaXNzIHRhYmxlIG9mIGNvbnRlbnRzIGlmIHZpc2libGUKICAgIGlmICh3M2Nfc2xpZHkuaXNfc2hvd25fdG9jKCkgJiYga2V5ICE9IDkgJiYga2V5ICE9IDE2ICYmIGtleSAhPSAzOCAmJiBrZXkgIT0gNDApCiAgICB7CiAgICAgIHczY19zbGlkeS5oaWRlX3RhYmxlX29mX2NvbnRlbnRzKHRydWUpOwoKICAgICAgaWYgKGtleSA9PSAyNyB8fCBrZXkgPT0gODQgfHwga2V5ID09IDY3KQogICAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KCiAgICBpZiAoa2V5ID09IDM0KSAvLyBQYWdlIERvd24KICAgIHsKICAgICAgaWYgKHczY19zbGlkeS52aWV3X2FsbCkKICAgICAgICByZXR1cm4gdHJ1ZTsKCiAgICAgIHczY19zbGlkeS5uZXh0X3NsaWRlKGZhbHNlKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDMzKSAvLyBQYWdlIFVwCiAgICB7CiAgICAgIGlmICh3M2Nfc2xpZHkudmlld19hbGwpCiAgICAgICAgcmV0dXJuIHRydWU7CgogICAgICB3M2Nfc2xpZHkucHJldmlvdXNfc2xpZGUoZmFsc2UpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMzIpIC8vIHNwYWNlIGJhcgogICAgewogICAgICB3M2Nfc2xpZHkubmV4dF9zbGlkZSh0cnVlKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDM3KSAvLyBMZWZ0IGFycm93CiAgICB7CiAgICAgIHczY19zbGlkeS5wcmV2aW91c19zbGlkZSghZXZlbnQuc2hpZnRLZXkpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMzYpIC8vIEhvbWUKICAgIHsKICAgICAgdzNjX3NsaWR5LmZpcnN0X3NsaWRlKCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSAzNSkgLy8gRW5kCiAgICB7CiAgICAgIHczY19zbGlkeS5sYXN0X3NsaWRlKCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSAzOSkgLy8gUmlnaHQgYXJyb3cKICAgIHsKICAgICAgdzNjX3NsaWR5Lm5leHRfc2xpZGUoIWV2ZW50LnNoaWZ0S2V5KTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDEzKSAvLyBFbnRlcgogICAgewogICAgICBpZiAodzNjX3NsaWR5Lm91dGxpbmUpCiAgICAgIHsKICAgICAgICBpZiAodzNjX3NsaWR5Lm91dGxpbmUudmlzaWJsZSkKICAgICAgICAgIHczY19zbGlkeS5mb2xkKHczY19zbGlkeS5vdXRsaW5lKTsKICAgICAgICBlbHNlCiAgICAgICAgICB3M2Nfc2xpZHkudW5mb2xkKHczY19zbGlkeS5vdXRsaW5lKTsKICAgICAgICAgIAogICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgICB9CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMTg4KSAgLy8gPCBmb3Igc21hbGxlciBmb250cwogICAgewogICAgICB3M2Nfc2xpZHkuc21hbGxlcigpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMTkwKSAgLy8gPiBmb3IgbGFyZ2VyIGZvbnRzCiAgICB7CiAgICAgIHczY19zbGlkeS5iaWdnZXIoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDE4OSB8fCBrZXkgPT0gMTA5KSAgLy8gLSBmb3Igc21hbGxlciBmb250cwogICAgewogICAgICB3M2Nfc2xpZHkuc21hbGxlcigpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gMTg3IHx8IGtleSA9PSAxOTEgfHwga2V5ID09IDEwNykgIC8vID0gKyAgZm9yIGxhcmdlciBmb250cwogICAgewogICAgICB3M2Nfc2xpZHkuYmlnZ2VyKCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSA4MykgIC8vIFMgZm9yIHNtYWxsZXIgZm9udHMKICAgIHsKICAgICAgdzNjX3NsaWR5LnNtYWxsZXIoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDY2KSAgLy8gQiBmb3IgbGFyZ2VyIGZvbnRzCiAgICB7CiAgICAgIHczY19zbGlkeS5iaWdnZXIoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDkwKSAgLy8gWiBmb3IgbGFzdCBzbGlkZQogICAgewogICAgICB3M2Nfc2xpZHkubGFzdF9zbGlkZSgpOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICBlbHNlIGlmIChrZXkgPT0gNzApICAvLyBGIGZvciB0b2dnbGUgdG9vbGJhcgogICAgewogICAgICB3M2Nfc2xpZHkudG9nZ2xlX3Rvb2xiYXIoKTsKICAgICAgcmV0dXJuIHczY19zbGlkeS5jYW5jZWwoZXZlbnQpOwogICAgfQogICAgZWxzZSBpZiAoa2V5ID09IDY1KSAgLy8gQSBmb3IgdG9nZ2xlIHZpZXcgc2luZ2xlL2FsbCBzbGlkZXMKICAgIHsKICAgICAgdzNjX3NsaWR5LnRvZ2dsZV92aWV3KCk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSA3NSkgIC8vIHRvZ2dsZSBhY3Rpb24gb2YgbGVmdCBjbGljayBmb3IgbmV4dCBwYWdlCiAgICB7CiAgICAgIHczY19zbGlkeS5tb3VzZV9jbGlja19lbmFibGVkID0gIXczY19zbGlkeS5tb3VzZV9jbGlja19lbmFibGVkOwogICAgICB2YXIgYWxlcnRfbXNnID0gKHczY19zbGlkeS5tb3VzZV9jbGlja19lbmFibGVkID8KICAgICAgICAgICAgICAgICJlbmFibGVkIiA6ICJkaXNhYmxlZCIpICsgICIgbW91c2UgY2xpY2sgYWR2YW5jZSI7CgogICAgICBhbGVydCh3M2Nfc2xpZHkubG9jYWxpemUoYWxlcnRfbXNnKSk7CiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSA4NCB8fCBrZXkgPT0gNjcpICAvLyBUIG9yIEMgZm9yIHRhYmxlIG9mIGNvbnRlbnRzCiAgICB7CiAgICAgIGlmICh3M2Nfc2xpZHkudG9jKQogICAgICAgIHczY19zbGlkeS50b2dnbGVfdGFibGVfb2ZfY29udGVudHMoKTsKCiAgICAgIHJldHVybiB3M2Nfc2xpZHkuY2FuY2VsKGV2ZW50KTsKICAgIH0KICAgIGVsc2UgaWYgKGtleSA9PSA3MikgLy8gSCBmb3IgaGVscAogICAgewogICAgICB3aW5kb3cubG9jYXRpb24gPSB3M2Nfc2xpZHkuaGVscF9wYWdlOwogICAgICByZXR1cm4gdzNjX3NsaWR5LmNhbmNlbChldmVudCk7CiAgICB9CiAgICAvL2Vsc2UgYWxlcnQoImtleSBjb2RlIGlzICIrIGtleSk7CgogICAgcmV0dXJuIHRydWU7CiAgfSwKCiAgLy8gc2FmZSBmb3IgYm90aCB0ZXh0L2h0bWwgYW5kIGFwcGxpY2F0aW9uL3hodG1sK3htbAogIGNyZWF0ZV9lbGVtZW50OiBmdW5jdGlvbiAobmFtZSkgewogICAgaWYgKHRoaXMueGh0bWwgJiYgKHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgIT0gJ3VuZGVmaW5lZCcpKQogICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiwgbmFtZSkKCiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTsKICB9LAoKICBnZXRfZWxlbWVudF9zdHlsZTogZnVuY3Rpb24gKGVsZW0sIElFU3R5bGVQcm9wLCBDU1NTdHlsZVByb3ApIHsKICAgIGlmIChlbGVtLmN1cnJlbnRTdHlsZSkKICAgIHsKICAgICAgcmV0dXJuIGVsZW0uY3VycmVudFN0eWxlW0lFU3R5bGVQcm9wXTsKICAgIH0KICAgIGVsc2UgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKQogICAgewogICAgICB2YXIgY29tcFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSwgIiIpOwogICAgICByZXR1cm4gY29tcFN0eWxlLmdldFByb3BlcnR5VmFsdWUoQ1NTU3R5bGVQcm9wKTsKICAgIH0KICAgIHJldHVybiAiIjsKICB9LAoKICAvLyB0aGUgc3RyaW5nIHN0ciBpcyBhIHdoaXRlc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgdG9rZW5zCiAgLy8gdGVzdCBpZiBzdHIgY29udGFpbnMgYSBwYXJ0aWN1bGFyIHRva2VuLCBlLmcuICJzbGlkZSIKICBoYXNfdG9rZW46IGZ1bmN0aW9uIChzdHIsIHRva2VuKSB7CiAgICBpZiAoc3RyKQogICAgewogICAgICAvLyBkZWZpbmUgcGF0dGVybiBhcyByZWd1bGFyIGV4cHJlc3Npb24KICAgICAgdmFyIHBhdHRlcm4gPSAvXHcrL2c7CgogICAgICAvLyBjaGVjayBmb3IgbWF0Y2hlcwogICAgICAvLyBwbGFjZSByZXN1bHQgaW4gYXJyYXkKICAgICAgdmFyIHJlc3VsdCA9IHN0ci5tYXRjaChwYXR0ZXJuKTsKCiAgICAgIC8vIG5vdyBjaGVjayBpZiBkZXNpcmVkIHRva2VuIGlzIHByZXNlbnQKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspCiAgICAgIHsKICAgICAgICBpZiAocmVzdWx0W2ldID09IHRva2VuKQogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gZmFsc2U7CiAgfSwKCiAgZ2V0X2NsYXNzX2xpc3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7CiAgICBpZiAodHlwZW9mIGVsZW1lbnQuY2xhc3NOYW1lICE9ICd1bmRlZmluZWQnKQogICAgICByZXR1cm4gZWxlbWVudC5jbGFzc05hbWU7CgogICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCJjbGFzcyIpOwogIH0sCgogIGhhc19jbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHsKICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9IDEpCiAgICAgIHJldHVybiBmYWxzZTsKCiAgICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgiKF58ICkiICsgbmFtZSArICJcVyoiKTsKCiAgICBpZiAodHlwZW9mIGVsZW1lbnQuY2xhc3NOYW1lICE9ICd1bmRlZmluZWQnKQogICAgICByZXR1cm4gcmVnZXhwLnRlc3QoZWxlbWVudC5jbGFzc05hbWUpOwoKICAgIHJldHVybiByZWdleHAudGVzdChlbGVtZW50LmdldEF0dHJpYnV0ZSgiY2xhc3MiKSk7CiAgfSwKCiAgcmVtb3ZlX2NsYXNzOiBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkgewogICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoIihefCApIiArIG5hbWUgKyAiXFcqIik7CiAgICB2YXIgY2xzdmFsID0gIiI7CgogICAgaWYgKHR5cGVvZiBlbGVtZW50LmNsYXNzTmFtZSAhPSAndW5kZWZpbmVkJykKICAgIHsKICAgICAgY2xzdmFsID0gZWxlbWVudC5jbGFzc05hbWU7CgogICAgICBpZiAoY2xzdmFsKQogICAgICB7CiAgICAgICAgY2xzdmFsID0gY2xzdmFsLnJlcGxhY2UocmVnZXhwLCAiIik7CiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbHN2YWw7CiAgICAgIH0KICAgIH0KICAgIGVsc2UKICAgIHsKICAgICAgY2xzdmFsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoImNsYXNzIik7CgogICAgICBpZiAoY2xzdmFsKQogICAgICB7CiAgICAgICAgY2xzdmFsID0gY2xzdmFsLnJlcGxhY2UocmVnZXhwLCAiIik7CiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoImNsYXNzIiwgY2xzdmFsKTsKICAgICAgfQogICAgfQogIH0sCgogIGFkZF9jbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHsKICAgIGlmICghdGhpcy5oYXNfY2xhc3MoZWxlbWVudCwgbmFtZSkpCiAgICB7CiAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgIT0gJ3VuZGVmaW5lZCcpCiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gIiAiICsgbmFtZTsKICAgICAgZWxzZQogICAgICB7CiAgICAgICAgdmFyIGNsc3ZhbCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCJjbGFzcyIpOwogICAgICAgIGNsc3ZhbCA9IGNsc3ZhbCA/IGNsc3ZhbCArICIgIiArIG5hbWUgOiBuYW1lOwogICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCJjbGFzcyIsIGNsc3ZhbCk7CiAgICAgIH0KICAgIH0KICB9LAoKICAvLyBIVE1MIGVsZW1lbnRzIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBjbGFzcz0iaW5jcmVtZW50YWwiCiAgLy8gbm90ZSB0aGF0IHlvdSBjYW4gYWxzbyBwdXQgdGhlIGNsYXNzIG9uIGNvbnRhaW5lcnMgbGlrZQogIC8vIHVwLCBvbCwgZGwsIGFuZCBkaXYgdG8gbWFrZSB0aGVpciBjb250ZW50cyBhcHBlYXIKICAvLyBpbmNyZW1lbnRhbGx5LiBVcHBlciBjYXNlIGlzIHVzZWQgc2luY2UgdGhpcyBpcyB3aGF0CiAgLy8gYnJvd3NlcnMgcmVwb3J0IGZvciBIVE1MIG5vZGUgbmFtZXMgKHRleHQvaHRtbCkuCiAgaW5jcmVtZW50YWxfZWxlbWVudHM6IG51bGwsCiAgb2theV9mb3JfaW5jcmVtZW50YWw6IGZ1bmN0aW9uIChuYW1lKSB7CiAgICBpZiAoIXRoaXMuaW5jcmVtZW50YWxfZWxlbWVudHMpCiAgICB7CiAgICAgIHZhciBpbmNsaXN0ID0gbmV3IEFycmF5KCk7CiAgICAgIGluY2xpc3RbInAiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbInByZSJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsibGkiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbImJsb2NrcXVvdGUiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbImR0Il0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJkZCJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsiaDIiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbImgzIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJoNCJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsiaDUiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbImg2Il0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJzcGFuIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJhZGRyZXNzIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJ0YWJsZSJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsidHIiXSA9IHRydWU7CiAgICAgIGluY2xpc3RbInRoIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJ0ZCJdID0gdHJ1ZTsKICAgICAgaW5jbGlzdFsiaW1nIl0gPSB0cnVlOwogICAgICBpbmNsaXN0WyJvYmplY3QiXSA9IHRydWU7CiAgICAgIHRoaXMuaW5jcmVtZW50YWxfZWxlbWVudHMgPSBpbmNsaXN0OwogICAgfQogICAgcmV0dXJuIHRoaXMuaW5jcmVtZW50YWxfZWxlbWVudHNbbmFtZS50b0xvd2VyQ2FzZSgpXTsKICB9LAoKICBuZXh0X2luY3JlbWVudGFsX2l0ZW06IGZ1bmN0aW9uIChub2RlKSB7CiAgICB2YXIgYnIgPSB0aGlzLmlzX3hodG1sID8gImJyIiA6ICJCUiI7CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwoKICAgIGZvciAoOzspCiAgICB7CiAgICAgIG5vZGUgPSB3M2Nfc2xpZHkubmV4dF9ub2RlKHNsaWRlLCBub2RlKTsKCiAgICAgIGlmIChub2RlID09IG51bGwgfHwgbm9kZS5wYXJlbnROb2RlID09IG51bGwpCiAgICAgICAgYnJlYWs7CgogICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSAgLy8gRUxFTUVOVAogICAgICB7CiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gYnIpCiAgICAgICAgICBjb250aW51ZTsKCiAgICAgICAgaWYgKHczY19zbGlkeS5oYXNfY2xhc3Mobm9kZSwgImluY3JlbWVudGFsIikKICAgICAgICAgICAgICYmIHczY19zbGlkeS5va2F5X2Zvcl9pbmNyZW1lbnRhbChub2RlLm5vZGVOYW1lKSkKICAgICAgICAgIHJldHVybiBub2RlOwoKICAgICAgICBpZiAodzNjX3NsaWR5Lmhhc19jbGFzcyhub2RlLnBhcmVudE5vZGUsICJpbmNyZW1lbnRhbCIpCiAgICAgICAgICAgICAmJiAhdzNjX3NsaWR5Lmhhc19jbGFzcyhub2RlLCAibm9uLWluY3JlbWVudGFsIikpCiAgICAgICAgICByZXR1cm4gbm9kZTsKICAgICAgfQogICAgfQoKICAgIHJldHVybiBub2RlOwogIH0sCgogIHByZXZpb3VzX2luY3JlbWVudGFsX2l0ZW06IGZ1bmN0aW9uIChub2RlKSB7CiAgICB2YXIgYnIgPSB0aGlzLmlzX3hodG1sID8gImJyIiA6ICJCUiI7CiAgICB2YXIgc2xpZGUgPSB3M2Nfc2xpZHkuc2xpZGVzW3czY19zbGlkeS5zbGlkZV9udW1iZXJdOwoKICAgIGZvciAoOzspCiAgICB7CiAgICAgIG5vZGUgPSB3M2Nfc2xpZHkucHJldmlvdXNfbm9kZShzbGlkZSwgbm9kZSk7CgogICAgICBpZiAobm9kZSA9PSBudWxsIHx8IG5vZGUucGFyZW50Tm9kZSA9PSBudWxsKQogICAgICAgIGJyZWFrOwoKICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkKICAgICAgewogICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IGJyKQogICAgICAgICAgY29udGludWU7CgogICAgICAgIGlmICh3M2Nfc2xpZHkuaGFzX2NsYXNzKG5vZGUsICJpbmNyZW1lbnRhbCIpCiAgICAgICAgICAgICAmJiB3M2Nfc2xpZHkub2theV9mb3JfaW5jcmVtZW50YWwobm9kZS5ub2RlTmFtZSkpCiAgICAgICAgICByZXR1cm4gbm9kZTsKCiAgICAgICAgaWYgKHczY19zbGlkeS5oYXNfY2xhc3Mobm9kZS5wYXJlbnROb2RlLCAiaW5jcmVtZW50YWwiKQogICAgICAgICAgICAgJiYgIXczY19zbGlkeS5oYXNfY2xhc3Mobm9kZSwgIm5vbi1pbmNyZW1lbnRhbCIpKQogICAgICAgICAgcmV0dXJuIG5vZGU7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gbm9kZTsKICB9LAoKICAvLyBzZXQgdmlzaWJpbGl0eSBmb3IgYWxsIGVsZW1lbnRzIG9uIGN1cnJlbnQgc2xpZGUgd2l0aAogIC8vIGEgcGFyZW50IGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgY2xhc3M9ImluY3JlbWVudGFsIgogIHNldF92aXNpYmlsaXR5X2FsbF9pbmNyZW1lbnRhbDogZnVuY3Rpb24gKHZhbHVlKSB7CiAgICB2YXIgbm9kZSA9IHRoaXMubmV4dF9pbmNyZW1lbnRhbF9pdGVtKG51bGwpOwoKICAgIGlmICh2YWx1ZSA9PSAiaGlkZGVuIikKICAgIHsKICAgICAgd2hpbGUgKG5vZGUpCiAgICAgIHsKICAgICAgICB3M2Nfc2xpZHkuYWRkX2NsYXNzKG5vZGUsICJpbnZpc2libGUiKTsKICAgICAgICBub2RlID0gdzNjX3NsaWR5Lm5leHRfaW5jcmVtZW50YWxfaXRlbShub2RlKTsKICAgICAgfQogICAgfQogICAgZWxzZSAvLyB2YWx1ZSA9PSAidmlzaWJsZSIKICAgIHsKICAgICAgd2hpbGUgKG5vZGUpCiAgICAgIHsKICAgICAgICB3M2Nfc2xpZHkucmVtb3ZlX2NsYXNzKG5vZGUsICJpbnZpc2libGUiKTsKICAgICAgICBub2RlID0gdzNjX3NsaWR5Lm5leHRfaW5jcmVtZW50YWxfaXRlbShub2RlKTsKICAgICAgfQogICAgfQogIH0sCgogIC8vIHJldmVhbCB0aGUgbmV4dCBoaWRkZW4gaXRlbSBvbiB0aGUgc2xpZGUKICAvLyBub2RlIGlzIG51bGwgb3IgdGhlIG5vZGUgdGhhdCB3YXMgbGFzdCByZXZlYWxlZAogIHJldmVhbF9uZXh0X2l0ZW06IGZ1bmN0aW9uIChub2RlKSB7CiAgICBub2RlID0gdzNjX3NsaWR5Lm5leHRfaW5jcmVtZW50YWxfaXRlbShub2RlKTsKCiAgICBpZiAobm9kZSAmJiBub2RlLm5vZGVUeXBlID09IDEpICAvLyBhbiBlbGVtZW50CiAgICAgIHczY19zbGlkeS5yZW1vdmVfY2xhc3Mobm9kZSwgImludmlzaWJsZSIpOwoKICAgIHJldHVybiBub2RlOwogIH0sCgogIC8vIGV4YWN0IGludmVyc2Ugb2YgcmV2ZWFsTmV4dEl0ZW0obm9kZSkKICBoaWRlX3ByZXZpb3VzX2l0ZW06IGZ1bmN0aW9uIChub2RlKSB7CiAgICBpZiAobm9kZSAmJiBub2RlLm5vZGVUeXBlID09IDEpICAvLyBhbiBlbGVtZW50CiAgICAgIHczY19zbGlkeS5hZGRfY2xhc3Mobm9kZSwgImludmlzaWJsZSIpOwoKICAgIHJldHVybiB0aGlzLnByZXZpb3VzX2luY3JlbWVudGFsX2l0ZW0obm9kZSk7CiAgfSwKCiAgLy8gbGVmdCB0byByaWdodCB0cmF2ZXJzYWwgb2Ygcm9vdCdzIGNvbnRlbnQKICBuZXh0X25vZGU6IGZ1bmN0aW9uIChyb290LCBub2RlKSB7CiAgICBpZiAobm9kZSA9PSBudWxsKQogICAgICByZXR1cm4gcm9vdC5maXJzdENoaWxkOwoKICAgIGlmIChub2RlLmZpcnN0Q2hpbGQpCiAgICAgIHJldHVybiBub2RlLmZpcnN0Q2hpbGQ7CgogICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpCiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nOwoKICAgIGZvciAoOzspCiAgICB7CiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7CgogICAgICBpZiAoIW5vZGUgfHwgbm9kZSA9PSByb290KQogICAgICAgIGJyZWFrOwoKICAgICAgaWYgKG5vZGUgJiYgbm9kZS5uZXh0U2libGluZykKICAgICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZzsKICAgIH0KCiAgICByZXR1cm4gbnVsbDsKICB9LAoKICAvLyByaWdodCB0byBsZWZ0IHRyYXZlcnNhbCBvZiByb290J3MgY29udGVudAogIHByZXZpb3VzX25vZGU6IGZ1bmN0aW9uIChyb290LCBub2RlKSB7CiAgICBpZiAobm9kZSA9PSBudWxsKQogICAgewogICAgICBub2RlID0gcm9vdC5sYXN0Q2hpbGQ7CgogICAgICBpZiAobm9kZSkKICAgICAgewogICAgICAgIHdoaWxlIChub2RlLmxhc3RDaGlsZCkKICAgICAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDsKICAgICAgfQoKICAgICAgcmV0dXJuIG5vZGU7CiAgICB9CgogICAgaWYgKG5vZGUucHJldmlvdXNTaWJsaW5nKQogICAgewogICAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7CgogICAgICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpCiAgICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkOwoKICAgICAgcmV0dXJuIG5vZGU7CiAgICB9CgogICAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPSByb290KQogICAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlOwoKICAgIHJldHVybiBudWxsOwogIH0sCgogIHByZXZpb3VzX3NpYmxpbmdfZWxlbWVudDogZnVuY3Rpb24gKGVsKSB7CiAgICBlbCA9IGVsLnByZXZpb3VzU2libGluZzsKCiAgICB3aGlsZSAoZWwgJiYgZWwubm9kZVR5cGUgIT0gMSkKICAgICAgZWwgPSBlbC5wcmV2aW91c1NpYmxpbmc7CgogICAgcmV0dXJuIGVsOwogIH0sCgogIG5leHRfc2libGluZ19lbGVtZW50OiBmdW5jdGlvbiAoZWwpIHsKICAgIGVsID0gZWwubmV4dFNpYmxpbmc7CgogICAgd2hpbGUgKGVsICYmIGVsLm5vZGVUeXBlICE9IDEpCiAgICAgIGVsID0gZWwubmV4dFNpYmxpbmc7CgogICAgcmV0dXJuIGVsOwogIH0sCgogIGZpcnN0X2NoaWxkX2VsZW1lbnQ6IGZ1bmN0aW9uIChlbCkgewogICAgdmFyIG5vZGU7CgogICAgZm9yIChub2RlID0gZWwuZmlyc3RDaGlsZDsgbm9kZTsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpCiAgICB7CiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpCiAgICAgICAgYnJlYWs7CiAgICB9CgogICAgcmV0dXJuIG5vZGU7CiAgfSwKCiAgZmlyc3RfdGFnOiBmdW5jdGlvbiAoZWxlbWVudCwgdGFnKSB7CiAgICB2YXIgbm9kZTsKCiAgICBpZiAoIXRoaXMuaXNfeGh0bWwpCiAgICAgIHRhZyA9IHRhZy50b1VwcGVyQ2FzZSgpOwoKICAgIGZvciAobm9kZSA9IGVsZW1lbnQuZmlyc3RDaGlsZDsgbm9kZTsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpCiAgICB7CiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5ub2RlTmFtZSA9PSB0YWcpCiAgICAgICAgYnJlYWs7CiAgICB9CgogICAgcmV0dXJuIG5vZGU7CiAgfSwKCiAgaGlkZV9zZWxlY3Rpb246IGZ1bmN0aW9uICgpIHsKICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSAvLyBGaXJlZm94LCBDaHJvbWl1bSwgU2FmYXJpLCBPcGVyYQogICAgewogICAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpOwoKICAgICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkKICAgICAgewogICAgICAgIHZhciByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApOwogICAgICAgIHJhbmdlLmNvbGxhcHNlIChmYWxzZSk7CiAgICAgIH0KICAgIH0KICAgIGVsc2UgLy8gSW50ZXJuZXQgRXhwbG9yZXIKICAgIHsKICAgICAgdmFyIHRleHRSYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSAoKTsKICAgICAgdGV4dFJhbmdlLmNvbGxhcHNlIChmYWxzZSk7CiAgICB9CiAgfSwKCiAgZ2V0X3NlbGVjdGVkX3RleHQ6IGZ1bmN0aW9uICgpIHsKICAgIHRyeQogICAgewogICAgICBpZiAod2luZG93LmdldFNlbGVjdGlvbikKICAgICAgICByZXR1cm4gd2luZG93LmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCk7CgogICAgICBpZiAoZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKQogICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpOwoKICAgICAgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikKICAgICAgICByZXR1cm4gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkudGV4dDsKICAgIH0KICAgIGNhdGNoIChlKQogICAgewogICAgfQoKICAgIHJldHVybiAiIjsKICB9LAoKICAvLyBtYWtlIG5vdGUgb2YgbGVuZ3RoIG9mIHNlbGVjdGVkIHRleHQKICAvLyBhcyB0aGlzIGV2YWx1YXRlcyB0byB6ZXJvIGluIGNsaWNrIGV2ZW50CiAgbW91c2VfYnV0dG9uX3VwOiBmdW5jdGlvbiAoZSkgewogICAgdzNjX3NsaWR5LnNlbGVjdGVkX3RleHRfbGVuID0gdzNjX3NsaWR5LmdldF9zZWxlY3RlZF90ZXh0KCkubGVuZ3RoOwogIH0sCgogIG1vdXNlX2J1dHRvbl9kb3duOiBmdW5jdGlvbiAoZSkgewogICAgdzNjX3NsaWR5LnNlbGVjdGVkX3RleHRfbGVuID0gdzNjX3NsaWR5LmdldF9zZWxlY3RlZF90ZXh0KCkubGVuZ3RoOwogICAgdzNjX3NsaWR5Lm1vdXNlX3ggPSBlLmNsaWVudFg7CiAgICB3M2Nfc2xpZHkubW91c2VfeSA9IGUuY2xpZW50WTsKICB9LAoKICAvLyByaWdodCBtb3VzZSBidXR0b24gY2xpY2sgaXMgcmVzZXJ2ZWQgZm9yIGNvbnRleHQgbWVudXMKICAvLyBpdCBpcyBtb3JlIHJlbGlhYmxlIHRvIGRldGVjdCByaWdodGNsaWNrIHRoYW4gbGVmdGNsaWNrCiAgbW91c2VfYnV0dG9uX2NsaWNrOiBmdW5jdGlvbiAoZSkgewogICAgaWYgKCFlKQogICAgICB2YXIgZSA9IHdpbmRvdy5ldmVudDsKCiAgICBpZiAoTWF0aC5hYnMoZS5jbGllbnRYIC13M2Nfc2xpZHkubW91c2VfeCkgKwogICAgICAgIE1hdGguYWJzKGUuY2xpZW50WSAtdzNjX3NsaWR5Lm1vdXNlX3kpID4gMTApCiAgICAgIHJldHVybiB0cnVlOwoKICAgIGlmICh3M2Nfc2xpZHkuc2VsZWN0ZWRfdGV4dF9sZW4gPiAwKQogICAgICByZXR1cm4gdHJ1ZTsKCiAgICB2YXIgcmlnaHRjbGljayA9IGZhbHNlOwogICAgdmFyIGxlZnRjbGljayA9IGZhbHNlOwogICAgdmFyIG1pZGRsZWNsaWNrID0gZmFsc2U7CiAgICB2YXIgdGFyZ2V0OwoKICAgIGlmICghZSkKICAgICAgdmFyIGUgPSB3aW5kb3cuZXZlbnQ7CgogICAgaWYgKGUudGFyZ2V0KQogICAgICB0YXJnZXQgPSBlLnRhcmdldDsKICAgIGVsc2UgaWYgKGUuc3JjRWxlbWVudCkKICAgICAgdGFyZ2V0ID0gZS5zcmNFbGVtZW50OwoKICAgIC8vIHdvcmsgYXJvdW5kIFNhZmFyaSBidWcKICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT0gMykKICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7CgogICAgaWYgKGUud2hpY2gpIC8vIGFsbCBicm93c2VycyBleGNlcHQgSUUKICAgIHsKICAgICAgbGVmdGNsaWNrID0gKGUud2hpY2ggPT0gMSk7CiAgICAgIG1pZGRsZWNsaWNrID0gKGUud2hpY2ggPT0gMik7CiAgICAgIHJpZ2h0Y2xpY2sgPSAoZS53aGljaCA9PSAzKTsKICAgIH0KICAgIGVsc2UgaWYgKGUuYnV0dG9uKQogICAgewogICAgICAvLyBLb25xdWVyb3IgZ2l2ZXMgMSBmb3IgbGVmdCwgNCBmb3IgbWlkZGxlCiAgICAgIC8vIElFNiBnaXZlcyAwIGZvciBsZWZ0IGFuZCBub3QgMSBhcyBJIGV4cGVjdGVkCgogICAgICBpZiAoZS5idXR0b24gPT0gNCkKICAgICAgICBtaWRkbGVjbGljayA9IHRydWU7CgogICAgICAvLyBhbGwgYnJvd3NlcnMgYWdyZWUgb24gMiBmb3IgcmlnaHQgYnV0dG9uCiAgICAgIHJpZ2h0Y2xpY2sgPSAoZS5idXR0b24gPT0gMik7CiAgICB9CiAgICBlbHNlCiAgICAgIGxlZnRjbGljayA9IHRydWU7CgogICAgaWYgKHczY19zbGlkeS5zZWxlY3RlZF90ZXh0X2xlbiA+IDApCiAgICB7CiAgICAgIHczY19zbGlkeS5zdG9wX3Byb3BhZ2F0aW9uKGUpOwogICAgICBlLmNhbmNlbCA9IHRydWU7CiAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQoKICAgIC8vIGRpc21pc3MgdGFibGUgb2YgY29udGVudHMKICAgIHczY19zbGlkeS5oaWRlX3RhYmxlX29mX2NvbnRlbnRzKGZhbHNlKTsKCiAgICAvLyBjaGVjayBpZiB0YXJnZXQgaXMgc29tZXRoaW5nIHRoYXQgcHJvYmFibHkgd2FudCdzIGNsaWNrcwogICAgLy8gZS5nLiBhLCBlbWJlZCwgb2JqZWN0LCBpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdCwgb3B0aW9uCiAgICB2YXIgdGFnID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7CgogICAgaWYgKHczY19zbGlkeS5tb3VzZV9jbGlja19lbmFibGVkICYmIGxlZnRjbGljayAmJgogICAgICAgICF3M2Nfc2xpZHkuc3BlY2lhbF9lbGVtZW50KHRhcmdldCkgJiYKICAgICAgICAhdGFyZ2V0Lm9uY2xpY2spCiAgICB7CiAgICAgIHczY19zbGlkeS5uZXh0X3NsaWRlKHRydWUpOwogICAgICB3M2Nfc2xpZHkuc3RvcF9wcm9wYWdhdGlvbihlKTsKICAgICAgZS5jYW5jZWwgPSB0cnVlOwogICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KCiAgICByZXR1cm4gdHJ1ZTsKICB9LAoKICBzcGVjaWFsX2VsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7CiAgICBpZiAodGhpcy5oYXNfY2xhc3MoZWxlbWVudCwgIm5vbi1pbnRlcmFjdGl2ZSIpKQogICAgICByZXR1cm4gZmFsc2U7CgogICAgdmFyIHRhZyA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTsKCiAgICByZXR1cm4gZWxlbWVudC5vbmtleWRvd24gfHwKICAgICAgZWxlbWVudC5vbmNsaWNrIHx8CiAgICAgIHRhZyA9PSAiYSIgfHwKICAgICAgdGFnID09ICJlbWJlZCIgfHwKICAgICAgdGFnID09ICJvYmplY3QiIHx8CiAgICAgIHRhZyA9PSAidmlkZW8iIHx8CiAgICAgIHRhZyA9PSAiYXVkaW8iIHx8CiAgICAgIHRhZyA9PSAic3ZnIiB8fAogICAgICB0YWcgPT0gImNhbnZhcyIgfHwKICAgICAgdGFnID09ICJpbnB1dCIgfHwKICAgICAgdGFnID09ICJ0ZXh0YXJlYSIgfHwKICAgICAgdGFnID09ICJzZWxlY3QiIHx8CiAgICAgIHRhZyA9PSAib3B0aW9uIjsKICB9LAoKICBzbGlkeV9jaHJvbWU6IGZ1bmN0aW9uIChlbCkgewogICAgd2hpbGUgKGVsKQogICAgewogICAgICBpZiAoZWwgPT0gdzNjX3NsaWR5LnRvYyB8fAogICAgICAgICAgZWwgPT0gdzNjX3NsaWR5LnRvb2xiYXIgfHwKICAgICAgICAgIHczY19zbGlkeS5oYXNfY2xhc3MoZWwsICJvdXRsaW5lIikpCiAgICAgICAgcmV0dXJuIHRydWU7CgogICAgICBlbCA9IGVsLnBhcmVudE5vZGU7CiAgICB9CgogICAgcmV0dXJuIGZhbHNlOwogIH0sCgogIGdldF9rZXk6IGZ1bmN0aW9uIChlKQogIHsKICAgIHZhciBrZXk7CgogICAgLy8ga2x1ZGdlIGFyb3VuZCBOUy9JRSBkaWZmZXJlbmNlcyAKICAgIGlmICh0eXBlb2Ygd2luZG93LmV2ZW50ICE9ICJ1bmRlZmluZWQiKQogICAgICBrZXkgPSB3aW5kb3cuZXZlbnQua2V5Q29kZTsKICAgIGVsc2UgaWYgKGUud2hpY2gpCiAgICAgIGtleSA9IGUud2hpY2g7CgogICAgcmV0dXJuIGtleTsKICB9LAoKICBnZXRfdGFyZ2V0OiBmdW5jdGlvbiAoZSkgewogICAgdmFyIHRhcmdldDsKCiAgICBpZiAoIWUpCiAgICAgIGUgPSB3aW5kb3cuZXZlbnQ7CgogICAgaWYgKGUudGFyZ2V0KQogICAgICB0YXJnZXQgPSBlLnRhcmdldDsKICAgIGVsc2UgaWYgKGUuc3JjRWxlbWVudCkKICAgICAgdGFyZ2V0ID0gZS5zcmNFbGVtZW50OwoKICAgIGlmICh0YXJnZXQubm9kZVR5cGUgIT0gMSkKICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7CgogICAgcmV0dXJuIHRhcmdldDsKICB9LAoKICAvLyBkb2VzIGRpc3BsYXkgcHJvcGVydHkgcHJvdmlkZSBjb3JyZWN0IGRlZmF1bHRzPwogIGlzX2Jsb2NrOiBmdW5jdGlvbiAoZWxlbSkgewogICAgdmFyIHRhZyA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTsKCiAgICByZXR1cm4gdGFnID09ICJvbCIgfHwgdGFnID09ICJ1bCIgfHwgdGFnID09ICJwIiB8fCB0YWcgPT0gImRsIiB8fAogICAgICAgICAgIHRhZyA9PSAibGkiIHx8IHRhZyA9PSAidGFibGUiIHx8IHRhZyA9PSAicHJlIiB8fAogICAgICAgICAgIHRhZyA9PSAiaDEiIHx8IHRhZyA9PSAiaDIiIHx8IHRhZyA9PSAiaDMiIHx8CiAgICAgICAgICAgdGFnID09ICJoNCIgfHwgdGFnID09ICJoNSIgfHwgdGFnID09ICJoNiIgfHwKICAgICAgICAgICB0YWcgPT0gImJsb2NrcXVvdGUiIHx8IHRhZyA9PSAiYWRkcmVzcyI7IAogIH0sCgogIGFkZF9saXN0ZW5lcjogZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyKSB7CiAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpCiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgZmFsc2UpOwogICAgZWxzZQogICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KCJvbiIrZXZlbnQsIGhhbmRsZXIpOwogIH0sCgogIC8vIHVzZWQgdG8gcHJldmVudCBldmVudCBwcm9wYWdhdGlvbiBmcm9tIGZpZWxkIGNvbnRyb2xzCiAgc3RvcF9wcm9wYWdhdGlvbjogZnVuY3Rpb24gKGV2ZW50KSB7CiAgICBldmVudCA9IGV2ZW50ID8gZXZlbnQgOiB3aW5kb3cuZXZlbnQ7CiAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlOyAgLy8gZm9yIElFCgogICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikKICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7CgogICAgcmV0dXJuIHRydWU7CiAgfSwKCiAgY2FuY2VsOiBmdW5jdGlvbiAoZXZlbnQpIHsKICAgIGlmIChldmVudCkKICAgIHsKICAgICAgIGV2ZW50LmNhbmNlbCA9IHRydWU7CiAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlOwoKICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KQogICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7CiAgICB9CgogICAgdzNjX3NsaWR5LmtleV93YW50ZWQgPSBmYWxzZTsKICAgIHJldHVybiBmYWxzZTsKICB9LAoKLy8gZm9yIGVhY2ggbGFuZ3VhZ2UgZGVmaW5lIGFuIGFzc29jaWF0aXZlIGFycmF5Ci8vIGFuZCBhbHNvIHRoZSBoZWxwIHRleHQgd2hpY2ggaXMgbG9uZ2VyCgogIHN0cmluZ3NfZXM6IHsKICAgICJzbGlkZSI6InDDoWcuIiwKICAgICJoZWxwPyI6IkF5dWRhIiwKICAgICJjb250ZW50cz8iOiLDjW5kaWNlIiwKICAgICJ0YWJsZSBvZiBjb250ZW50cyI6InRhYmxhIGRlIGNvbnRlbmlkb3MiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoiVGFibGEgZGUgQ29udGVuaWRvcyIsCiAgICAicmVzdGFydCBwcmVzZW50YXRpb24iOiJSZWluaWNpYXIgcHJlc2VudGFjacOzbiIsCiAgICAicmVzdGFydD8iOiJJbmljaW8iCiAgfSwKICBoZWxwX2VzOgogICAgIlV0aWxpY2UgZWwgcmF0w7NuLCBiYXJyYSBlc3BhY2lhZG9yYSwgdGVjbGFzIEl6ZGEvRGNoYSwgIiArCiAgICAibyBSZSBww6FnIHkgQXYgcMOhZy4gVXNlIFMgeSBCIHBhcmEgY2FtYmlhciBlbCB0YW1hw7FvIGRlIGZ1ZW50ZS4iLAoKICBzdHJpbmdzX2NhOiB7CiAgICAic2xpZGUiOiJww6BnLi4iLAogICAgImhlbHA/IjoiQWp1ZGEiLAogICAgImNvbnRlbnRzPyI6IsONbmRleCIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJ0YXVsYSBkZSBjb250aW5ndXRzIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IlRhdWxhIGRlIENvbnRpbmd1dHMiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoiUmVpbmljaWFyIHByZXNlbnRhY2nDsyIsCiAgICAicmVzdGFydD8iOiJJbmljaSIKICB9LAogIGhlbHBfY2E6CiAgICAiVXRpbGl0emkgZWwgcmF0b2zDrSwgYmFycmEgZXNwYWlhZG9yYSwgdGVjbGVzIEVzcS4vRHRhLiAiICsKICAgICJvIFJlIHDDoGcgeSBBdiBww6BnLiBVc2kgUyBpIEIgcGVyIGNhbnZpYXIgZ3JhbmTDoHJpYSBkZSBmb250LiIsCgogIHN0cmluZ3NfY3M6IHsKICAgICJzbGlkZSI6InNuw61tZWsiLAogICAgImhlbHA/IjoibsOhcG92xJtkYSIsCiAgICAiY29udGVudHM/Ijoib2JzYWgiLAogICAgInRhYmxlIG9mIGNvbnRlbnRzIjoib2JzYWggcHJlemVudGFjZSIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiJPYnNhaCBwcmV6ZW50YWNlIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6Inpub3Z1IHNwdXN0aXQgcHJlemVudGFjaSIsCiAgICAicmVzdGFydD8iOiJyZXN0YXJ0IgogIH0sCiAgaGVscF9jczoKICAgICJQcmV6ZW50YWNpIG3Fr8W+ZXRlIHByb2Now6F6ZXQgcG9tb2PDrSBrbGlrbnV0w60gbXnFoWksIG1lemVybsOta3UsICIgKwogICAgIsWhaXBlayB2bGV2byBhIHZwcmF2byBuZWJvIGtsw6F2ZXMgUGFnZVVwIGEgUGFnZURvd24uIFDDrXNtbyBzZSAiICsKICAgICJkw6EgenbEm3TFoWl0IGEgem1lbsWhaXQgcG9tb2PDrSBrbMOhdmVzIEIgYSBTLiIsCgogIHN0cmluZ3Nfbmw6IHsKICAgICJzbGlkZSI6InBhZ2luYSIsCiAgICAiaGVscD8iOiJIZWxwPyIsCiAgICAiY29udGVudHM/IjoiSW5ob3VkPyIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJpbmhvdWRzb3BnYXZlIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IkluaG91ZHNvcGdhdmUiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoiaGVyc3RhcnQgcHJlc2VudGF0aWUiLAogICAgInJlc3RhcnQ/IjoiSGVyc3RhcnQ/IgogIH0sCiAgaGVscF9ubDoKICAgICAiTmF2aWdlZXIgZC5tLnYuIGhldCBtdWlzLCBzcGF0aWViYXIsIExpbmtzL1JlY2h0cyB0b2V0c2VuLCAiICsKICAgICAib2YgUGdVcCBlbiBQZ0RuLiBHZWJydWlrIFMgZW4gQiBvbSBkZSBrYXJha3Rlcmdyb290dGUgdGUgdmVyYW5kZXJlbi4iLAoKICBzdHJpbmdzX2RlOiB7CiAgICAic2xpZGUiOiJTZWl0ZSIsCiAgICAiaGVscD8iOiJIaWxmZSIsCiAgICAiY29udGVudHM/Ijoiw5xiZXJzaWNodCIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJJbmhhbHRzdmVyemVpY2huaXMiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoiSW5oYWx0c3ZlcnplaWNobmlzIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6IlByw6RzZW50YXRpb24gbmV1IHN0YXJ0ZW4iLAogICAgInJlc3RhcnQ/IjoiTmV1c3RhcnQiCiAgfSwKICBoZWxwX2RlOgogICAgIkJlbnV0emVuIFNpZSBkaWUgTWF1cywgTGVlcnNjaGxhZywgZGllIEN1cnNvcnRhc3RlbiBsaW5rcy9yZWNodHMgb2RlciAiICsKICAgICJQYWdlIHVwL1BhZ2UgRG93biB6dW0gV2VjaHNlbG4gZGVyIFNlaXRlbiB1bmQgUyB1bmQgQiBmw7xyIGRpZSBTY2hyaWZ0Z3LDtnNzZS4iLAoKICBzdHJpbmdzX3BsOiB7CiAgICAic2xpZGUiOiJzbGFqZCIsCiAgICAiaGVscD8iOiJwb21vYz8iLAogICAgImNvbnRlbnRzPyI6InNwaXMgdHJlxZtjaT8iLAogICAgInRhYmxlIG9mIGNvbnRlbnRzIjoic3BpcyB0cmXFm2NpIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IlNwaXMgVHJlxZtjaSIsCiAgICAicmVzdGFydCBwcmVzZW50YXRpb24iOiJSZXN0YXJ0dWogcHJlemVudGFjasSZIiwKICAgICJyZXN0YXJ0PyI6InJlc3RhcnQ/IgogIH0sCiAgaGVscF9wbDoKICAgICJabWllbmlhaiBzbGFqZHkga2xpa2FqxIVjIG15c3rEhSwgbmFjaXNrYWrEhWMgc3BhY2rEmSwgc3RyemHFgmtpIGxld28vcHJhd28iICsKICAgICJsdWIgUGdVcCAvIFBnRG4uIFXFvHlqIGtsYXdpc3p5IFMgaSBCLCBhYnkgem1pZW5pxIcgcm96bWlhciBjemN6aW9ua2kuIiwKCiAgc3RyaW5nc19mcjogewogICAgInNsaWRlIjoicGFnZSIsCiAgICAiaGVscD8iOiJBaWRlIiwKICAgICJjb250ZW50cz8iOiJJbmRleCIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJ0YWJsZSBkZXMgbWF0acOocmVzIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IlRhYmxlIGRlcyBtYXRpw6hyZXMiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoiUmVjb21tZW5jZXIgbCdleHBvc8OpIiwKICAgICJyZXN0YXJ0PyI6IkTDqWJ1dCIKICB9LAogIGhlbHBfZnI6CiAgICAiTmF2aWd1ZXogYXZlYyBsYSBzb3VyaXMsIGxhIGJhcnJlIGQnZXNwYWNlLCBsZXMgZmzDqGNoZXMgIiArCiAgICAiZ2F1Y2hlL2Ryb2l0ZSBvdSBsZXMgdG91Y2hlcyBQZyBVcCwgUGcgRG4uIFV0aWxpc2V6ICIgKwogICAgImxlcyB0b3VjaGVzIFMgZXQgQiBwb3VyIG1vZGlmaWVyIGxhIHRhaWxsZSBkZSBsYSBwb2xpY2UuIiwKCiAgc3RyaW5nc19odTogewogICAgInNsaWRlIjoib2xkYWwiLAogICAgImhlbHA/Ijoic2Vnw610c8OpZyIsCiAgICAiY29udGVudHM/IjoidGFydGFsb20iLAogICAgInRhYmxlIG9mIGNvbnRlbnRzIjoidGFydGFsb21qZWd5esOpayIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiJUYXJ0YWxvbWplZ3l6w6lrIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6ImJlbXV0YXTDsyDDumpyYWluZMOtdMOhc2EiLAogICAgInJlc3RhcnQ/Ijoiw7pqcmFpbmTDrXTDoXMiCiAgfSwKICBoZWxwX2h1OgogICAgIkF6IG9sZGFsYWsga8O2enRpIGzDqXBrZWTDqXNoZXoga2F0dGludHNvbiBheiBlZ8OpcnJlbCwgdmFneSAiICsKICAgICJoYXN6bsOhbGphIGEgc3rDs2vDtnosIGEgYmFsLCB2YWd5IGEgam9iYiBuecOtbCwgaWxsZXR2ZSBhIFBhZ2UgRG93biwgIiArCiAgICAiUGFnZSBVcCBiaWxsZW50ecWxa2V0LiBBeiBTIMOpcyBhIEIgYmlsbGVudHnFsWtrZWwgdsOhbHRvenRhdGhhdGphICIgKwogICAgImEgc3rDtnZlZyBtw6lyZXTDqXQuIiwKCiAgc3RyaW5nc19pdDogewogICAgInNsaWRlIjoicGFnLiIsCiAgICAiaGVscD8iOiJBaXV0byIsCiAgICAiY29udGVudHM/IjoiSW5kaWNlIiwKICAgICJ0YWJsZSBvZiBjb250ZW50cyI6ImluZGljZSIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiJJbmRpY2UiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoiUmljb21pbmNpYXJlIGxhIHByZXNlbnRhemlvbmUiLAogICAgInJlc3RhcnQ/IjoiSW5pemlvIgogIH0sCiAgaGVscF9pdDoKICAgICJOYXZpZ2FyZSBjb24gbW91c2UsIGJhcnJhIHNwYXppbywgZnJlY2NlIHNpbmlzdHJhL2Rlc3RyYSBvICIgKwogICAgIlBnVXAgZSBQZ0RuLiBVc2FyZSBTIGUgQiBwZXIgY2FtYmlhcmUgbGEgZGltZW5zaW9uZSBkZWkgY2FyYXR0ZXJpLiIsCgogIHN0cmluZ3NfZWw6IHsKICAgICJzbGlkZSI6Is+DzrXOu86vzrTOsSIsCiAgICAiaGVscD8iOiLOss6/zq7OuM61zrnOsTsiLAogICAgImNvbnRlbnRzPyI6Is+AzrXPgc65zrXPh8+MzrzOtc69zrE7IiwKICAgICJ0YWJsZSBvZiBjb250ZW50cyI6Is+Azq/Ovc6xzrrOsc+CIM+AzrXPgc65zrXPh86/zrzOrc69z4nOvSIsCiAgICAiVGFibGUgb2YgQ29udGVudHMiOiLOoM6vzr3Osc66zrHPgiDOoM61z4HOuc61z4fOv868zq3Ovc+Jzr0iLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoizrXPgM6xzr3Otc66zrrOr869zrfPg863IM+AzrHPgc6/z4XPg86vzrHPg863z4IiLAogICAgInJlc3RhcnQ/IjoizrXPgM6xzr3Otc66zrrOr869zrfPg863OyIKICB9LAogIGhlbHBfZWw6CiAgICAizqDOu86/zrfOs863zrjOtc6vz4TOtSDOvM61IM+Ezr8gzrrOu86vzrogz4TOv8+FIM+Azr/Ovc+EzrnOus65zr/PjSwgz4TOvyBzcGFjZSwgz4TOsSDOss6tzrvOtyDOsc+BzrnPg8+EzrXPgc6sL860zrXOvs65zqwsICIgKwogICAgIs6uIFBhZ2UgVXAgzrrOsc65IFBhZ2UgRG93bi4gzqfPgc63z4POuc68zr/PgM6/zrnOrs+Dz4TOtSDPhM6xIM+AzrvOrs66z4TPgc6xIFMgzrrOsc65IEIgzrPOuc6xIM69zrEgzrHOu867zqzOvs61z4TOtSAiICsKICAgICLPhM6/IM68zq3Os861zrjOv8+CIM+EzrfPgiDOs8+BzrHOvM68zrHPhM6/z4POtc65z4HOrM+CLiIsCgogIHN0cmluZ3NfamE6IHsKICAgICJzbGlkZSI6IuOCueODqeOCpOODiSIsCiAgICAiaGVscD8iOiLjg5jjg6vjg5ciLAogICAgImNvbnRlbnRzPyI6IuebruasoSIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiLnm67mrKHjgpLooajnpLoiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoi55uu5qyhIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6IuacgOWIneOBi+OCieWGjeeUnyIsCiAgICAicmVzdGFydD8iOiLmnIDliJ3jgYvjgokiCiAgfSwKICBoZWxwX2phOgogICAgICLjg57jgqbjgrnlt6bjgq/jg6rjg4Pjgq8g44O7IOOCueODmuODvOOCuSDjg7sg5bem5Y+z44Kt44O8ICIgKwogICAgICLjgb7jgZ/jga8gUGFnZSBVcCDjg7sgUGFnZSBEb3du44Gn5pON5L2c77yMIFMg44O7IELjgafjg5Xjgqnjg7Pjg4jjgrXjgqTjgrrlpInmm7QiLAoKICBzdHJpbmdzX3poOiB7CiAgICAic2xpZGUiOiLlubvnga/niYciLAogICAgImhlbHA/Ijoi5biu5YqpPyIsCiAgICAiY29udGVudHM/Ijoi5YaF5a65PyIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiLnm67lvZUiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoi55uu5b2VIiwKICAgICJyZXN0YXJ0IHByZXNlbnRhdGlvbiI6IumHjeaWsOWQr+WKqOWxleekuiIsCiAgICAicmVzdGFydD8iOiLph43mlrDlkK/liqg/IgogIH0sCiAgaGVscF96aDoKICAgICLnlKjpvKDmoIfngrnlh7ssIOepuuagvOadoSwg5bem5Y+z566t5aS0LCBQZyBVcCDlkowgUGcgRG4g5a+86IiqLiAiICsKICAgICLnlKggUywgQiDmlLnlj5jlrZfkvZPlpKflsI8uIiwKCiAgc3RyaW5nc19ydTogewogICAgInNsaWRlIjoi0YHQu9Cw0LnQtCIsCiAgICAiaGVscD8iOiLQv9C+0LzQvtGJ0Yw/IiwKICAgICJjb250ZW50cz8iOiLRgdC+0LTQtdGA0LbQsNC90LjQtT8iLAogICAgInRhYmxlIG9mIGNvbnRlbnRzIjoi0L7Qs9C70LDQstC70LXQvdC40LUiLAogICAgIlRhYmxlIG9mIENvbnRlbnRzIjoi0J7Qs9C70LDQstC70LXQvdC40LUiLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoi0L/QtdGA0LXQt9Cw0L/Rg9GB0YLQuNGC0Ywg0L/RgNC10LfQtdC90YLQsNGG0LjRjiIsCiAgICAicmVzdGFydD8iOiLQv9C10YDQtdC30LDQv9GD0YHQuj8iCiAgfSwKICBoZWxwX3J1OgogICAgItCf0LXRgNC10LzQtdGJ0LDQudGC0LXRgdGMINC60LvQuNC60LDRjyDQvNGL0YjQutC+0LksINC40YHQv9C+0LvRjNC30YPRjyDQutC70LDQstC40YjRgyDQv9GA0L7QsdC10LssINGB0YLRgNC10LvQutC4IiArCiAgICAi0LLQu9C10LLQvi/QstC/0YDQsNCy0L4g0LjQu9C4IFBnIFVwINC4IFBnIERuLiDQmtC70LDQstC40YjQuCBTINC4IEIg0LzQtdC90Y/RjtGCINGA0LDQt9C80LXRgCDRiNGA0LjRhNGC0LAuIiwKCiAgc3RyaW5nc19zdjogewogICAgInNsaWRlIjoic2lkYSIsCiAgICAiaGVscD8iOiJoasOkbHAiLAogICAgImNvbnRlbnRzPyI6ImlubmVow6VsbCIsCiAgICAidGFibGUgb2YgY29udGVudHMiOiJpbm5laMOlbGxzZsO2cnRlY2tuaW5nIiwKICAgICJUYWJsZSBvZiBDb250ZW50cyI6IklubmVow6VsbHNmw7ZydGVja25pbmciLAogICAgInJlc3RhcnQgcHJlc2VudGF0aW9uIjoidmlzYSBwcmVzZW50YXRpb25lbiBmcsOlbiBiw7ZyamFuIiwKICAgICJyZXN0YXJ0PyI6ImLDtnJqYSBvbSIKICB9LAogIGhlbHBfc3Y6CiAgICAiQmzDpGRkcmEgbWVkIGV0dCBrbGljayBtZWQgdsOkbnN0cmEgbXVza25hcHBlbiwgbWVsbGFuc2xhZ3N0YW5nZW50ZW4sICIgKwogICAgInbDpG5zdGVyLSBvY2ggaMO2Z2VycGlsdGFuZ2VudGVybmEgZWxsZXIgdGFuZ2VudGVybmEgUGcgVXAsIFBnIERuLiAiICsKICAgICJBbnbDpG5kIHRhbmdlbnRlcm5hIFMgb2NoIEIgZsO2ciBhdHQgw6RuZHJhIHRleHRlbnMgc3Rvcmxlay4iLAoKICBzdHJpbmdzOiB7IH0sCgogIGxvY2FsaXplOiBmdW5jdGlvbiAoc3JjKSB7CiAgICBpZiAoc3JjID09ICIiKQogICAgICByZXR1cm4gc3JjOwoKICAgICAvLyB0cnkgZnVsbCBsYW5ndWFnZSBjb2RlLCBlLmcuIGVuLVVTCiAgICAgdmFyIHMsIGxvb2t1cCA9IHczY19zbGlkeS5zdHJpbmdzW3czY19zbGlkeS5sYW5nXTsKCiAgICAgaWYgKGxvb2t1cCkKICAgICB7CiAgICAgICBzID0gbG9va3VwW3NyY107CgogICAgICAgaWYgKHMpCiAgICAgICAgcmV0dXJuIHM7CiAgICAgfQoKICAgICAvLyBzdHJpcCBjb3VudHJ5IGNvZGUgc3VmZml4LCBlLmcuCiAgICAgLy8gdHJ5IGVuIGlmIHVuZGVmaW5lZCBmb3IgZW4tVVMKICAgICB2YXIgbGcgPSB3M2Nfc2xpZHkubGFuZy5zcGxpdCgiLSIpOwoKICAgICBpZiAobGcubGVuZ3RoID4gMSkKICAgICB7CiAgICAgICBsb29rdXAgPSB3M2Nfc2xpZHkuc3RyaW5nc1tsZ1swXV07CgogICAgICAgaWYgKGxvb2t1cCkKICAgICAgIHsKICAgICAgICAgcyA9IGxvb2t1cFtzcmNdOwoKICAgICAgICAgaWYgKHMpCiAgICAgICAgICByZXR1cm4gczsKICAgICAgIH0KICAgICB9CgogICAgIC8vIG90aGVyd2lzZSBzdHJpbmcgYXMgaXMKICAgICByZXR1cm4gc3JjOwogIH0sCgogIGluaXRfbG9jYWxpemF0aW9uOiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgaTE4biA9IHczY19zbGlkeTsKICAgIHZhciBoZWxwX3RleHQgPSB3M2Nfc2xpZHkuaGVscF90ZXh0OwoKICAgIC8vIGVhY2ggc3VjaCBsYW5ndWFnZSBhcnJheSBpcyBkZWNsYXJlZCBpbiB0aGUgbG9jYWxpemUgYXJyYXkKICAgIC8vIHRoaXMgaXMgdXNlZCBhcyBpbiAgdzNjX3NsaWR5LmxvY2FsaXplKCJmb28iKTsKICAgIHRoaXMuc3RyaW5ncyA9IHsKICAgICAgImVzIjp0aGlzLnN0cmluZ3NfZXMsCiAgICAgICJjYSI6dGhpcy5zdHJpbmdzX2NhLAogICAgICAiY3MiOnRoaXMuc3RyaW5nc19jcywKICAgICAgIm5sIjp0aGlzLnN0cmluZ3NfbmwsCiAgICAgICJkZSI6dGhpcy5zdHJpbmdzX2RlLAogICAgICAicGwiOnRoaXMuc3RyaW5nc19wbCwKICAgICAgImZyIjp0aGlzLnN0cmluZ3NfZnIsCiAgICAgICJodSI6dGhpcy5zdHJpbmdzX2h1LAogICAgICAiaXQiOnRoaXMuc3RyaW5nc19pdCwKICAgICAgImVsIjp0aGlzLnN0cmluZ3NfZWwsCiAgICAgICJqcCI6dGhpcy5zdHJpbmdzX2phLAogICAgICAiemgiOnRoaXMuc3RyaW5nc196aCwKICAgICAgInJ1Ijp0aGlzLnN0cmluZ3NfcnUsCiAgICAgICJzdiI6dGhpcy5zdHJpbmdzX3N2CiAgICB9LAoKICAgIGkxOG4uc3RyaW5nc19lc1toZWxwX3RleHRdID0gaTE4bi5oZWxwX2VzOwogICAgaTE4bi5zdHJpbmdzX2NhW2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfY2E7CiAgICBpMThuLnN0cmluZ3NfY3NbaGVscF90ZXh0XSA9IGkxOG4uaGVscF9jczsKICAgIGkxOG4uc3RyaW5nc19ubFtoZWxwX3RleHRdID0gaTE4bi5oZWxwX25sOwogICAgaTE4bi5zdHJpbmdzX2RlW2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfZGU7CiAgICBpMThuLnN0cmluZ3NfcGxbaGVscF90ZXh0XSA9IGkxOG4uaGVscF9wbDsKICAgIGkxOG4uc3RyaW5nc19mcltoZWxwX3RleHRdID0gaTE4bi5oZWxwX2ZyOwogICAgaTE4bi5zdHJpbmdzX2h1W2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfaHU7CiAgICBpMThuLnN0cmluZ3NfaXRbaGVscF90ZXh0XSA9IGkxOG4uaGVscF9pdDsKICAgIGkxOG4uc3RyaW5nc19lbFtoZWxwX3RleHRdID0gaTE4bi5oZWxwX2VsOwogICAgaTE4bi5zdHJpbmdzX2phW2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfamE7CiAgICBpMThuLnN0cmluZ3NfemhbaGVscF90ZXh0XSA9IGkxOG4uaGVscF96aDsKICAgIGkxOG4uc3RyaW5nc19ydVtoZWxwX3RleHRdID0gaTE4bi5oZWxwX3J1OwogICAgaTE4bi5zdHJpbmdzX3N2W2hlbHBfdGV4dF0gPSBpMThuLmhlbHBfc3Y7CgogICAgdzNjX3NsaWR5LmxhbmcgPSBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCJsYW5nIik7CgogICAgaWYgKCF3M2Nfc2xpZHkubGFuZykKICAgICAgdzNjX3NsaWR5LmxhbmcgPSBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCJ4bWw6bGFuZyIpOwoKICAgIGlmICghdzNjX3NsaWR5LmxhbmcpCiAgICAgIHczY19zbGlkeS5sYW5nID0gImVuIjsKICB9Cn07CgovLyBoYWNrIGZvciBiYWNrIGJ1dHRvbiBiZWhhdmlvcgppZiAodzNjX3NsaWR5LmllNiB8fCB3M2Nfc2xpZHkuaWU3KQp7CiAgZG9jdW1lbnQud3JpdGUoIjxpZnJhbWUgaWQ9J2hpc3RvcnlGcmFtZScgIiArCiAgInNyYz0namF2YXNjcmlwdDpcIjxodG1sIisiPjwvIisiaHRtbD5cIicgIiArCiAgImhlaWdodD0nMScgd2lkdGg9JzEnICIgKwogICJzdHlsZT0ncG9zaXRpb246YWJzb2x1dGU7bGVmdDotODAwcHgnPjwvaWZyYW1lPiIpOwp9CgovLyBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzIGZvciBpbml0aWFsaXphdGlvbgp3M2Nfc2xpZHkuc2V0X3VwKCk7CgovLyBoaWRlIHRoZSBzbGlkZXMgYXMgc29vbiBhcyBib2R5IGVsZW1lbnQgaXMgYXZhaWxhYmxlCi8vIHRvIHJlZHVjZSBhbm5veWluZyBzY3JlZW4gbWVzcyBiZWZvcmUgdGhlIG9ubG9hZCBldmVudApzZXRUaW1lb3V0KHczY19zbGlkeS5oaWRlX3NsaWRlcywgNTApOwoK"></script>
  <script>(function() {
  if (!window.w3c_slidy) return;
  if (!window.Shiny) return;
  if (!window.$) return;
  // whenever a slide changes, tell shiny to recalculate what is displayed
  window.w3c_slidy.add_observer(function (slide_num) {
    // slide_num starts at position 1
    $(w3c_slidy.slides[slide_num - 1]).trigger("shown");
  });
})()
</script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Analyzing Financial and Economic Data with R</h1>
  <h1 class="subtitle">Chapter 07 - Basic Object Classes</h1>
  <p class="author">
Marcelo S. Perlin
  </p>
  <p class="date">2020-02-15</p>
</div>
<div id="introduction" class="slide section level2">
<h1>Introduction</h1>
<p>In this chapter, we will study Rs basic object classes with depth, including the manipulation of their content. It includes the following types of objects:</p>
<ul>
<li>Numeric (<code>numeric</code>)</li>
<li>Text (<code>character</code>)</li>
<li>Factors (<code>factor</code>)</li>
<li>Logical Values (<code>logical</code>)</li>
<li>Dates and Time (<code>Date</code> and <code>timedate</code>)</li>
<li>Missing Data (<code>NA</code>)</li>
</ul>
</div>
<div id="numeric-objects" class="slide section level2">
<h1><code>Numeric</code> Objects</h1>
<p>The objects of type <code>numeric</code> represent quantities and, unsurprisingly, are one of the most used objects in data research.</p>
<h3 id="creating-and-manipulating-numeric-objects">Creating and Manipulating <code>numeric</code> Objects</h3>
<p>It is easy to create and manipulate the <code>numeric</code> objects. As expected, we can use the common symbols of mathematical operations, such as sum (<code>+</code>), difference (<code>-</code>), division (<code>/</code>) and multiplication (<code>*</code>).</p>
<p>When working with <code>numeric</code> vectors, all mathematical operations are carried out using an <strong>element by element</strong> orientation and using vector notation.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># create numeric vectors</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>y &lt;-<span class="st"> </span><span class="dv">2</span><span class="op">:</span><span class="dv">6</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co"># print sum</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">print</span>(x<span class="op">+</span>y)</span></code></pre></div>
<pre><code>## [1]  3  5  7  9 11</code></pre>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># print multiplication</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">print</span>(x<span class="op">*</span>y)</span></code></pre></div>
<pre><code>## [1]  2  6 12 20 30</code></pre>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># print division</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">print</span>(x<span class="op">/</span>y)</span></code></pre></div>
<pre><code>## [1] 0.5000000 0.6666667 0.7500000 0.8000000 0.8333333</code></pre>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="co"># print exponentiation</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">print</span>(x<span class="op">^</span>y)</span></code></pre></div>
<pre><code>## [1]     1     8    81  1024 15625</code></pre>
<p>The difference between R and other programming languages is that operations between vectors of different sizes are accepted.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># set x with 4 elements and y with 2</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">4</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>y &lt;-<span class="st"> </span><span class="dv">2</span><span class="op">:</span><span class="dv">1</span></span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="co"># print multiplication</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="kw">print</span>(x <span class="op">+</span><span class="st"> </span>y)</span></code></pre></div>
<pre><code>## [1] 3 3 5 5</code></pre>
<p>The result of <code>x + y</code> is equivalent to <code>1:4 + c(2, 1, 2, 1)</code>.</p>
<p>Elements of a <code>numeric</code> vector can also be named. See an example next, where we create a vector with several named items.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># create named vector</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">item1 =</span> <span class="dv">10</span>, </span>
<span id="cb11-3"><a href="#cb11-3"></a>       <span class="dt">item2 =</span> <span class="dv">14</span>, </span>
<span id="cb11-4"><a href="#cb11-4"></a>       <span class="dt">item3 =</span> <span class="dv">9</span>, </span>
<span id="cb11-5"><a href="#cb11-5"></a>       <span class="dt">item4 =</span> <span class="dv">2</span>)</span>
<span id="cb11-6"><a href="#cb11-6"></a></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="co"># print it</span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="kw">print</span>(x)</span></code></pre></div>
<pre><code>## item1 item2 item3 item4 
##    10    14     9     2</code></pre>
<h3 id="creating-a-numeric-sequence">Creating a <code>numeric</code> Sequence</h3>
<p>In R, you have two ways to create a sequence of numerical values. The first with operator <code>:</code> as in <code>my_seq &lt;- 1:10</code>. This method is practical because the notation is clear and direct.</p>
<p>A more powerful version for the creation of sequences is the use of function <code>seq.</code></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a><span class="co"># create sequence with seq</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>my_seq &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="dv">-10</span>, </span>
<span id="cb13-3"><a href="#cb13-3"></a>              <span class="dt">to =</span> <span class="dv">10</span>, </span>
<span id="cb13-4"><a href="#cb13-4"></a>              <span class="dt">by =</span> <span class="dv">2</span>)</span>
<span id="cb13-5"><a href="#cb13-5"></a></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="co"># print it</span></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="kw">print</span>(my_seq)</span></code></pre></div>
<pre><code>##  [1] -10  -8  -6  -4  -2   0   2   4   6   8  10</code></pre>
<p>Another interesting feature of function <code>seq</code> is the possibility of creating equally spaced vectors with an initial value, a final value, and the desired number of elements.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a><span class="co"># create sequence with defined number of elements</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>desired_len &lt;-<span class="st"> </span><span class="dv">20</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>my_seq &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="dv">0</span>, </span>
<span id="cb15-4"><a href="#cb15-4"></a>              <span class="dt">to =</span> <span class="dv">10</span>, </span>
<span id="cb15-5"><a href="#cb15-5"></a>              <span class="dt">length.out =</span> desired_len)</span>
<span id="cb15-6"><a href="#cb15-6"></a></span>
<span id="cb15-7"><a href="#cb15-7"></a><span class="co"># print it</span></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="kw">print</span>(my_seq)</span></code></pre></div>
<pre><code>##  [1]  0.0000000  0.5263158  1.0526316  1.5789474  2.1052632  2.6315789
##  [7]  3.1578947  3.6842105  4.2105263  4.7368421  5.2631579  5.7894737
## [13]  6.3157895  6.8421053  7.3684211  7.8947368  8.4210526  8.9473684
## [19]  9.4736842 10.0000000</code></pre>
<p>The final number of elements in object <code>my_seq</code> is exactly 20. Function <code>seq</code> automatically calculates and sets the difference of 0.5263 between the adjacent elements.</p>
<h3 id="creating-vectors-with-repeated-elements">Creating Vectors with Repeated Elements</h3>
<p>Another way to create <code>numeric</code> vectors is by using repetition.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a><span class="co"># repeat vector three times</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>my_x &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">times =</span> <span class="dv">10</span>)</span>
<span id="cb17-3"><a href="#cb17-3"></a></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="co"># print it</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="kw">print</span>(my_x)</span></code></pre></div>
<pre><code>##  [1] 1 1 1 1 1 1 1 1 1 1</code></pre>
<p>It also works with vectors. For example, lets say you need to create a vector with the repeated values of <code>c(1, 2)</code>. The result should be equal to <code>c(1, 2, 1, 2, 1, 2)</code>. For that, we use <code>rep</code> the same way:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a><span class="co"># created a vector with repeated elements</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>my_x &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), </span>
<span id="cb19-3"><a href="#cb19-3"></a>            <span class="dt">times =</span> <span class="dv">3</span>)</span>
<span id="cb19-4"><a href="#cb19-4"></a></span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="co"># print it</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="kw">print</span>(my_x)</span></code></pre></div>
<pre><code>## [1] 1 2 1 2 1 2</code></pre>
<h3 id="creating-vectors-with-random-numbers">Creating Vectors with Random Numbers</h3>
<p>Function <code>rnorm</code> generates random numbers from the Normal distribution, with options for the mean and standard deviation. The <code>mean</code> will set the point with the highest frequency and <code>sd</code> (standard deviation) will change the dispersion of the histogram.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">library</span>(tidyverse)</span></code></pre></div>
<pre><code>##  Attaching packages  tidyverse 1.3.0 </code></pre>
<pre><code>##  ggplot2 3.2.1      purrr   0.3.3
##  tibble  2.1.3      dplyr   0.8.4
##  tidyr   1.0.2      stringr 1.4.0
##  readr   1.3.1      forcats 0.4.0</code></pre>
<pre><code>##  Conflicts  tidyverse_conflicts() 
## x dplyr::filter() masks stats::filter()
## x dplyr::lag()    masks stats::lag()</code></pre>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a><span class="co"># generate 10 random numbers from a Normal distribution</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>my_rnd_vec &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dt">n =</span> <span class="dv">10000</span>, </span>
<span id="cb25-3"><a href="#cb25-3"></a>                    <span class="dt">mean =</span> <span class="dv">0</span>, </span>
<span id="cb25-4"><a href="#cb25-4"></a>                    <span class="dt">sd =</span> <span class="dv">1</span>)</span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="co"># print it</span></span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="kw">glimpse</span>(my_rnd_vec)</span></code></pre></div>
<pre><code>##  num [1:10000] -1.409 1.109 0.066 -0.323 -0.105 ...</code></pre>
<p>We generated ten thousand random numbers from a Normal distribution, with mean zero and standard deviation equal to one. Lets see if its distribution of numbers looks close to the Normal, a bell shaped distribution:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a>p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="kw">tibble</span>(<span class="dt">x =</span> my_rnd_vec), <span class="kw">aes</span>(<span class="dt">x =</span> x)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="st">  </span><span class="kw">geom_histogram</span>()</span>
<span id="cb27-3"><a href="#cb27-3"></a></span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="kw">print</span>(p)</span></code></pre></div>
<p><img src="data:image/png;base64,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" width="768" /></p>
<p>Yes, it is pretty close. You can change the parameters <code>mean</code> and <code>sd</code> for different shapes of a Normal distribution.</p>
<p>Function <code>runif</code> generates random values uniformly distributed between a maximum and a minimum.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1"></a><span class="co"># create a random vector with minimum and maximum</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>my_rnd_vec &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dt">n =</span> <span class="dv">10</span>, </span>
<span id="cb28-3"><a href="#cb28-3"></a>                    <span class="dt">min =</span> <span class="dv">-5</span>, </span>
<span id="cb28-4"><a href="#cb28-4"></a>                    <span class="dt">max =</span> <span class="dv">5</span>)</span>
<span id="cb28-5"><a href="#cb28-5"></a></span>
<span id="cb28-6"><a href="#cb28-6"></a><span class="co"># print it</span></span>
<span id="cb28-7"><a href="#cb28-7"></a><span class="kw">print</span>(my_rnd_vec)</span></code></pre></div>
<pre><code>##  [1] -1.5482312 -3.8641854  3.3141156  0.9576968  2.0249665 -0.3087305
##  [7]  4.7772406 -2.1573012 -3.8385482 -3.9555131</code></pre>
<p>Note that both functions, <code>rnorm</code> and <code>runif,</code> are limited to their respective distribution. An alternative and flexible way to generate random values is to use the <code>sample</code> function.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1"></a><span class="co"># create sequence</span></span>
<span id="cb30-2"><a href="#cb30-2"></a>my_vec &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="dv">0</span>, <span class="dt">to =</span> <span class="dv">25</span>, <span class="dt">by=</span><span class="dv">5</span>)</span>
<span id="cb30-3"><a href="#cb30-3"></a></span>
<span id="cb30-4"><a href="#cb30-4"></a><span class="co"># sample sequence</span></span>
<span id="cb30-5"><a href="#cb30-5"></a>my_rnd_vec &lt;-<span class="st"> </span><span class="kw">sample</span>(my_vec)</span>
<span id="cb30-6"><a href="#cb30-6"></a></span>
<span id="cb30-7"><a href="#cb30-7"></a><span class="co"># print it</span></span>
<span id="cb30-8"><a href="#cb30-8"></a><span class="kw">print</span>(my_rnd_vec)</span></code></pre></div>
<pre><code>## [1]  5  0 20 25 10 15</code></pre>
<p>Function <code>sample</code> also allows the random selection of a fixed number of elements. If we wanted to select only one element of <code>my_vec</code> randomly, we could write the code as:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1"></a><span class="co"># sample one element of my_vec</span></span>
<span id="cb32-2"><a href="#cb32-2"></a>my_rnd_vec &lt;-<span class="st"> </span><span class="kw">sample</span>(my_vec, <span class="dt">size =</span> <span class="dv">1</span>)</span>
<span id="cb32-3"><a href="#cb32-3"></a></span>
<span id="cb32-4"><a href="#cb32-4"></a><span class="co"># print it</span></span>
<span id="cb32-5"><a href="#cb32-5"></a><span class="kw">print</span>(my_rnd_vec)</span></code></pre></div>
<pre><code>## [1] 0</code></pre>
<p>If we wanted two random elements from <code>my_rnd_vec</code>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1"></a><span class="co"># sample two elements of my_vec</span></span>
<span id="cb34-2"><a href="#cb34-2"></a>my_rnd_vec &lt;-<span class="st"> </span><span class="kw">sample</span>(my_vec, <span class="dt">size =</span> <span class="dv">2</span>)</span>
<span id="cb34-3"><a href="#cb34-3"></a></span>
<span id="cb34-4"><a href="#cb34-4"></a><span class="co"># print it</span></span>
<span id="cb34-5"><a href="#cb34-5"></a><span class="kw">print</span>(my_rnd_vec)</span></code></pre></div>
<pre><code>## [1] 0 5</code></pre>
<h3 id="accessing-the-elements-of-a-numeric-vector">Accessing the Elements of a <code>numeric</code> Vector</h3>
<p>All elements of a numerical vector can be accessed with brackets (<code>[]</code>). For example, if we wanted only the first element of <code>x,</code> we can use <code>x[1]</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1"></a><span class="co"># set vector</span></span>
<span id="cb36-2"><a href="#cb36-2"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">-9</span>, <span class="dv">2</span>)</span>
<span id="cb36-3"><a href="#cb36-3"></a></span>
<span id="cb36-4"><a href="#cb36-4"></a><span class="co"># get first element</span></span>
<span id="cb36-5"><a href="#cb36-5"></a>first_elem_x &lt;-<span class="st"> </span>x[<span class="dv">1</span>]</span>
<span id="cb36-6"><a href="#cb36-6"></a></span>
<span id="cb36-7"><a href="#cb36-7"></a><span class="co"># print it</span></span>
<span id="cb36-8"><a href="#cb36-8"></a><span class="kw">print</span>(first_elem_x)</span></code></pre></div>
<pre><code>## [1] -1</code></pre>
<p>The same notation is used to extract parts of a vector. If we wanted to create a sub-vector with the first and second element of <code>x,</code> we can achieve this goal with the next chunk of code:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1"></a><span class="co"># sub-vector of x</span></span>
<span id="cb38-2"><a href="#cb38-2"></a>sub_x &lt;-<span class="st"> </span>x[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>]</span>
<span id="cb38-3"><a href="#cb38-3"></a></span>
<span id="cb38-4"><a href="#cb38-4"></a><span class="co"># print it</span></span>
<span id="cb38-5"><a href="#cb38-5"></a><span class="kw">print</span>(sub_x)</span></code></pre></div>
<pre><code>## [1] -1  4</code></pre>
<p>To access named elements of a numeric array, simply use its name as a <code>character</code> value or vector inside the brackets.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1"></a><span class="co"># set named vector</span></span>
<span id="cb40-2"><a href="#cb40-2"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">item1 =</span> <span class="dv">10</span>, <span class="dt">item2 =</span> <span class="dv">14</span>, <span class="dt">item3 =</span> <span class="dv">-9</span>, <span class="dt">item4 =</span> <span class="dv">-2</span>)</span>
<span id="cb40-3"><a href="#cb40-3"></a></span>
<span id="cb40-4"><a href="#cb40-4"></a><span class="co"># access elements by name</span></span>
<span id="cb40-5"><a href="#cb40-5"></a><span class="kw">print</span>(x[<span class="st">&#39;item2&#39;</span>])</span></code></pre></div>
<pre><code>## item2 
##    14</code></pre>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1"></a><span class="kw">print</span>(x[<span class="kw">c</span>(<span class="st">&#39;item2&#39;</span>,<span class="st">&#39;item4&#39;</span>)])</span></code></pre></div>
<pre><code>## item2 item4 
##    14    -2</code></pre>
<h3 id="modifying-and-removing-elements-of-a-numeric-vector">Modifying and Removing Elements of a <code>numeric</code> Vector</h3>
<p>The modification of a vector is very simple. Just indicate the changes with the <em>assign</em> symbol (<code>&lt;-</code>): </p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1"></a><span class="co"># set vector</span></span>
<span id="cb44-2"><a href="#cb44-2"></a>my_x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">4</span></span>
<span id="cb44-3"><a href="#cb44-3"></a></span>
<span id="cb44-4"><a href="#cb44-4"></a><span class="co"># modify first element to 5</span></span>
<span id="cb44-5"><a href="#cb44-5"></a>my_x[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">5</span></span>
<span id="cb44-6"><a href="#cb44-6"></a></span>
<span id="cb44-7"><a href="#cb44-7"></a><span class="co"># print result</span></span>
<span id="cb44-8"><a href="#cb44-8"></a><span class="kw">print</span>(my_x)</span></code></pre></div>
<pre><code>## [1] 5 2 3 4</code></pre>
<p>This modification can also be performed block-wise:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1"></a><span class="co"># set vector</span></span>
<span id="cb46-2"><a href="#cb46-2"></a>my_x &lt;-<span class="st"> </span><span class="dv">0</span><span class="op">:</span><span class="dv">5</span></span>
<span id="cb46-3"><a href="#cb46-3"></a></span>
<span id="cb46-4"><a href="#cb46-4"></a><span class="co"># set the first three elements to 5</span></span>
<span id="cb46-5"><a href="#cb46-5"></a>my_x[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>] &lt;-<span class="st"> </span><span class="dv">5</span></span>
<span id="cb46-6"><a href="#cb46-6"></a></span>
<span id="cb46-7"><a href="#cb46-7"></a><span class="co"># print result</span></span>
<span id="cb46-8"><a href="#cb46-8"></a><span class="kw">print</span>(my_x)</span></code></pre></div>
<pre><code>## [1] 5 5 5 3 4 5</code></pre>
<p>Using conditions to change values in a vector is also possible:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1"></a><span class="co"># set vector</span></span>
<span id="cb48-2"><a href="#cb48-2"></a>my_x &lt;-<span class="st"> </span><span class="dv">-5</span><span class="op">:</span><span class="dv">5</span></span>
<span id="cb48-3"><a href="#cb48-3"></a></span>
<span id="cb48-4"><a href="#cb48-4"></a><span class="co"># set any value lower than 2 to 0</span></span>
<span id="cb48-5"><a href="#cb48-5"></a>my_x[my_x<span class="op">&lt;</span><span class="dv">2</span>] &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb48-6"><a href="#cb48-6"></a></span>
<span id="cb48-7"><a href="#cb48-7"></a><span class="co"># print result</span></span>
<span id="cb48-8"><a href="#cb48-8"></a><span class="kw">print</span>(my_x)</span></code></pre></div>
<pre><code>##  [1] 0 0 0 0 0 0 0 2 3 4 5</code></pre>
<p>The removal of elements of a vector is carried out using a negative index:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1"></a><span class="co"># create vector</span></span>
<span id="cb50-2"><a href="#cb50-2"></a>my_x &lt;-<span class="st"> </span><span class="dv">-5</span><span class="op">:</span><span class="dv">5</span></span>
<span id="cb50-3"><a href="#cb50-3"></a></span>
<span id="cb50-4"><a href="#cb50-4"></a><span class="co"># remove first and second element of my_x</span></span>
<span id="cb50-5"><a href="#cb50-5"></a>my_x &lt;-<span class="st"> </span>my_x[<span class="op">-</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>)]</span>
<span id="cb50-6"><a href="#cb50-6"></a></span>
<span id="cb50-7"><a href="#cb50-7"></a><span class="co"># show result</span></span>
<span id="cb50-8"><a href="#cb50-8"></a><span class="kw">print</span>(my_x)</span></code></pre></div>
<pre><code>## [1] -3 -2 -1  0  1  2  3  4  5</code></pre>
<p>Notice how using negative index simply returns the original vector, without the elements in the brackets.</p>
</div>
<div id="character-objects" class="slide section level2">
<h1><code>Character</code> Objects</h1>
<p>The <code>character</code> class, or simply text class, is used to store textual information.</p>
<h3 id="creating-a-simple-character-object">Creating a Simple <code>character</code> Object</h3>
<p>In R, every <code>character</code> object is created by encapsulating a text with double quotation marks (&quot; &quot;) or single ( ).</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1"></a>tickers &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;MMM&#39;</span>, <span class="st">&#39;FB&#39;</span>, <span class="st">&#39;ICE&#39;</span>)</span>
<span id="cb52-2"><a href="#cb52-2"></a><span class="kw">print</span>(tickers)</span></code></pre></div>
<pre><code>## [1] &quot;MMM&quot; &quot;FB&quot;  &quot;ICE&quot;</code></pre>
<p>We can confirm the class of the created object with function <code>class</code>: </p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1"></a><span class="kw">class</span>(tickers)</span></code></pre></div>
<pre><code>## [1] &quot;character&quot;</code></pre>
<h3 id="creating-structured-character-objects">Creating Structured <code>character</code> Objects</h3>
<p>We can also use R to create a text vector with some sort of structure. For example, vector <code>c(&#39;ticker 1&#39;, &#39;ticker 2&#39;, ..., &#39;ticker 19&#39;, &#39;ticker 20&#39;)</code> has a clear logic. It combines a text <code>ticker</code> with values from a vector that starts in 1 and ends in 20.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1"></a><span class="kw">library</span>(stringr)</span>
<span id="cb56-2"><a href="#cb56-2"></a></span>
<span id="cb56-3"><a href="#cb56-3"></a><span class="co"># create sequence and tex</span></span>
<span id="cb56-4"><a href="#cb56-4"></a>my_seq &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">20</span></span>
<span id="cb56-5"><a href="#cb56-5"></a>my_text &lt;-<span class="st"> &#39;text&#39;</span></span>
<span id="cb56-6"><a href="#cb56-6"></a></span>
<span id="cb56-7"><a href="#cb56-7"></a><span class="co"># paste objects together (without space)</span></span>
<span id="cb56-8"><a href="#cb56-8"></a>my_char &lt;-<span class="st"> </span><span class="kw">str_c</span>(my_text, my_seq)</span>
<span id="cb56-9"><a href="#cb56-9"></a><span class="kw">print</span>(my_char)</span></code></pre></div>
<pre><code>##  [1] &quot;text1&quot;  &quot;text2&quot;  &quot;text3&quot;  &quot;text4&quot;  &quot;text5&quot;  &quot;text6&quot;  &quot;text7&quot;  &quot;text8&quot; 
##  [9] &quot;text9&quot;  &quot;text10&quot; &quot;text11&quot; &quot;text12&quot; &quot;text13&quot; &quot;text14&quot; &quot;text15&quot; &quot;text16&quot;
## [17] &quot;text17&quot; &quot;text18&quot; &quot;text19&quot; &quot;text20&quot;</code></pre>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1"></a><span class="co"># paste objects together (with space)</span></span>
<span id="cb58-2"><a href="#cb58-2"></a>my_char &lt;-<span class="st"> </span><span class="kw">str_c</span>(my_text, </span>
<span id="cb58-3"><a href="#cb58-3"></a>                 my_seq, </span>
<span id="cb58-4"><a href="#cb58-4"></a>                 <span class="dt">sep =</span> <span class="st">&#39; &#39;</span>)</span>
<span id="cb58-5"><a href="#cb58-5"></a><span class="kw">print</span>(my_char)</span></code></pre></div>
<pre><code>##  [1] &quot;text 1&quot;  &quot;text 2&quot;  &quot;text 3&quot;  &quot;text 4&quot;  &quot;text 5&quot;  &quot;text 6&quot;  &quot;text 7&quot; 
##  [8] &quot;text 8&quot;  &quot;text 9&quot;  &quot;text 10&quot; &quot;text 11&quot; &quot;text 12&quot; &quot;text 13&quot; &quot;text 14&quot;
## [15] &quot;text 15&quot; &quot;text 16&quot; &quot;text 17&quot; &quot;text 18&quot; &quot;text 19&quot; &quot;text 20&quot;</code></pre>
<p>We can do the same procedure with text vectors:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1"></a><span class="co"># set character value</span></span>
<span id="cb60-2"><a href="#cb60-2"></a>my_x &lt;-<span class="st"> &#39;My name is&#39;</span></span>
<span id="cb60-3"><a href="#cb60-3"></a></span>
<span id="cb60-4"><a href="#cb60-4"></a><span class="co"># set character vector</span></span>
<span id="cb60-5"><a href="#cb60-5"></a>my_names &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;Marcelo&#39;</span>, <span class="st">&#39;Ricardo&#39;</span>, <span class="st">&#39;Tarcizio&#39;</span>)</span>
<span id="cb60-6"><a href="#cb60-6"></a></span>
<span id="cb60-7"><a href="#cb60-7"></a><span class="co"># paste and print</span></span>
<span id="cb60-8"><a href="#cb60-8"></a><span class="kw">print</span>(<span class="kw">str_c</span>(my_x, my_names, <span class="dt">sep =</span> <span class="st">&#39; &#39;</span>))</span></code></pre></div>
<pre><code>## [1] &quot;My name is Marcelo&quot;  &quot;My name is Ricardo&quot;  &quot;My name is Tarcizio&quot;</code></pre>
<h3 id="selecting-pieces-of-a-text-object">Selecting Pieces of a Text Object</h3>
<p>A common beginners mistake is to select characters of a text using brackets, as it is done for selecting elements of a vector. Consider the following code:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1"></a><span class="co"># set char object</span></span>
<span id="cb62-2"><a href="#cb62-2"></a>my_char &lt;-<span class="st"> &#39;ABCDE&#39;</span></span>
<span id="cb62-3"><a href="#cb62-3"></a></span>
<span id="cb62-4"><a href="#cb62-4"></a><span class="co"># print its second element (WRONG - RESULT is NA)</span></span>
<span id="cb62-5"><a href="#cb62-5"></a><span class="kw">print</span>(my_char[<span class="dv">2</span>])</span></code></pre></div>
<pre><code>## [1] NA</code></pre>
<p>The <code>NA</code> value indicates the second element of <code>my_char</code> does not exist. This happens because using square brackets is reserved for accessing the elements of an atomic vector, not characters within a larger text. Watch what happens when we use <code>my_char[1]</code>:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1"></a><span class="kw">print</span>(my_char[<span class="dv">1</span>])</span></code></pre></div>
<pre><code>## [1] &quot;ABCDE&quot;</code></pre>
<p>The result is simply the <em>ABCDE</em> text, on the first item of <code>my_char</code>. To select pieces of text, we need to use function <code>stringr::str_sub</code> or <code>base::substr</code>:  </p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1"></a><span class="co"># print third and fourth characters</span></span>
<span id="cb66-2"><a href="#cb66-2"></a>my_substr &lt;-<span class="st"> </span><span class="kw">str_sub</span>(<span class="dt">string =</span> my_char,</span>
<span id="cb66-3"><a href="#cb66-3"></a>                     <span class="dt">start =</span> <span class="dv">2</span>,</span>
<span id="cb66-4"><a href="#cb66-4"></a>                     <span class="dt">end =</span> <span class="dv">2</span>)</span>
<span id="cb66-5"><a href="#cb66-5"></a><span class="kw">print</span>(my_substr)</span></code></pre></div>
<pre><code>## [1] &quot;B&quot;</code></pre>
<p>These functions also work for atomic vectors. Lets assume you imported text data, and the raw dataset contains a 3-letter identifier of a company, always in the same location of the string. Lets simulate the situation in R:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1"></a><span class="co"># build char vec</span></span>
<span id="cb68-2"><a href="#cb68-2"></a>my_char_vec &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="kw">c</span>(<span class="st">&#39;ABC&#39;</span>,<span class="st">&#39;VBC&#39;</span>,<span class="st">&#39;ZMN&#39;</span>),</span>
<span id="cb68-3"><a href="#cb68-3"></a>                      <span class="st">&#39; - other ignorable text&#39;</span>)</span>
<span id="cb68-4"><a href="#cb68-4"></a><span class="kw">print</span>(my_char_vec)</span></code></pre></div>
<pre><code>## [1] &quot;ABC - other ignorable text&quot; &quot;VBC - other ignorable text&quot;
## [3] &quot;ZMN - other ignorable text&quot;</code></pre>
<p>Here, we want the information in the first three characters of each element only in <code>my_char_vec.</code> To select them, we can use the same functions as before.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1"></a><span class="co"># get ids with stringr::str_sub</span></span>
<span id="cb70-2"><a href="#cb70-2"></a>ids_vec &lt;-<span class="st"> </span><span class="kw">str_sub</span>(my_char_vec, <span class="dv">1</span>, <span class="dv">3</span>)</span>
<span id="cb70-3"><a href="#cb70-3"></a><span class="kw">print</span>(ids_vec)</span></code></pre></div>
<pre><code>## [1] &quot;ABC&quot; &quot;VBC&quot; &quot;ZMN&quot;</code></pre>
<p><strong>Vector operations in character objects are very common in R</strong>. Almost anything you can do to a single element can be expanded to vectors. This facilitates the development of research scripts as you can easily perform complicated tasks to a series of elements in a single line of code.</p>
<h3 id="finding-and-replacing-characters-of-a-text">Finding and Replacing Characters of a Text</h3>
<p>A useful operation in handling texts is to locate specific patterns of text within a <code>character</code> object with functions <code>stringr::str_locate</code>/<code>base::regexpr</code> and <code>stringr::str_locate_all</code>/<code>base::gregexpr</code>.</p>
<p>The following example shows how to find the <em>D</em> character from a range of characters.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1"></a><span class="co"># set character object</span></span>
<span id="cb72-2"><a href="#cb72-2"></a>my_char &lt;-<span class="st"> &#39;ABCDEF-ABCDEF-ABC&#39;</span></span>
<span id="cb72-3"><a href="#cb72-3"></a></span>
<span id="cb72-4"><a href="#cb72-4"></a><span class="co"># find position of &#39;D&#39; using str_locate</span></span>
<span id="cb72-5"><a href="#cb72-5"></a>pos &lt;-<span class="st"> </span><span class="kw">str_locate</span>(my_char, <span class="kw">fixed</span>(<span class="st">&#39;D&#39;</span>))</span>
<span id="cb72-6"><a href="#cb72-6"></a><span class="kw">print</span>(pos)</span></code></pre></div>
<pre><code>##      start end
## [1,]     4   4</code></pre>
<p>Note the <code>str_locate</code> function returns only the <strong>first occurrence</strong> of <em>D</em>. To locate all instances, we use function <code>str_locate_all</code>.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1"></a><span class="co"># set object</span></span>
<span id="cb74-2"><a href="#cb74-2"></a>my_char &lt;-<span class="st"> &#39;ABCDEF-ABCDEF-ABC&#39;</span></span>
<span id="cb74-3"><a href="#cb74-3"></a></span>
<span id="cb74-4"><a href="#cb74-4"></a><span class="co"># find position of ALL &#39;D&#39; using str_locate_all</span></span>
<span id="cb74-5"><a href="#cb74-5"></a>pos &lt;-<span class="st"> </span><span class="kw">str_locate_all</span>(my_char, <span class="kw">fixed</span>(<span class="st">&#39;D&#39;</span>))</span>
<span id="cb74-6"><a href="#cb74-6"></a><span class="kw">print</span>(pos)</span></code></pre></div>
<pre><code>## [[1]]
##      start end
## [1,]     4   4
## [2,]    11  11</code></pre>
<p>To replace characters in a text, use functions <code>str_replace</code> and <code>str_replace_all</code> from <code>stringr</code> or <code>sub</code> and <code>gsub</code> from the base package.</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1"></a><span class="co"># set char object</span></span>
<span id="cb76-2"><a href="#cb76-2"></a>my_char &lt;-<span class="st"> &#39;ABCDEF-ABCDEF-ABC&#39;</span></span>
<span id="cb76-3"><a href="#cb76-3"></a></span>
<span id="cb76-4"><a href="#cb76-4"></a><span class="co"># substitute the FIRST &#39;ABC&#39; for &#39;XXX&#39; with str_replace</span></span>
<span id="cb76-5"><a href="#cb76-5"></a>my_char &lt;-<span class="st"> </span><span class="kw">str_replace</span>(<span class="dt">string =</span> my_char,</span>
<span id="cb76-6"><a href="#cb76-6"></a>                       <span class="dt">pattern =</span> <span class="st">&#39;ABC&#39;</span>,</span>
<span id="cb76-7"><a href="#cb76-7"></a>                       <span class="dt">replacement =</span> <span class="st">&#39;XXX&#39;</span>)</span>
<span id="cb76-8"><a href="#cb76-8"></a><span class="kw">print</span>(my_char)</span></code></pre></div>
<pre><code>## [1] &quot;XXXDEF-ABCDEF-ABC&quot;</code></pre>
<p>And now, we globally substitute characters.</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1"></a><span class="co"># set char object</span></span>
<span id="cb78-2"><a href="#cb78-2"></a>my_char &lt;-<span class="st"> &#39;ABCDEF-ABCDEF-ABC&#39;</span></span>
<span id="cb78-3"><a href="#cb78-3"></a></span>
<span id="cb78-4"><a href="#cb78-4"></a><span class="co"># substitute ALL &#39;ABC&#39; for &#39;XXX&#39; with str_replace_all</span></span>
<span id="cb78-5"><a href="#cb78-5"></a>my_char &lt;-<span class="st"> </span><span class="kw">str_replace_all</span>(<span class="dt">string =</span> my_char,</span>
<span id="cb78-6"><a href="#cb78-6"></a>                           <span class="dt">pattern =</span> <span class="st">&#39;ABC&#39;</span>,</span>
<span id="cb78-7"><a href="#cb78-7"></a>                           <span class="dt">replacement =</span> <span class="st">&#39;XXX&#39;</span>)</span>
<span id="cb78-8"><a href="#cb78-8"></a></span>
<span id="cb78-9"><a href="#cb78-9"></a><span class="co"># print result</span></span>
<span id="cb78-10"><a href="#cb78-10"></a><span class="kw">print</span>(my_char)</span></code></pre></div>
<pre><code>## [1] &quot;XXXDEF-XXXDEF-XXX&quot;</code></pre>
<p>Again, it is worth pointing out that the operations of replacements of strings also work for vectors. Have a look at the next example.</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1"></a><span class="co"># set char object</span></span>
<span id="cb80-2"><a href="#cb80-2"></a>my_char &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;ABCDEF&#39;</span>,<span class="st">&#39;DBCFE&#39;</span>,<span class="st">&#39;ABC&#39;</span>)</span>
<span id="cb80-3"><a href="#cb80-3"></a></span>
<span id="cb80-4"><a href="#cb80-4"></a><span class="co"># create an example of vector</span></span>
<span id="cb80-5"><a href="#cb80-5"></a>my_char_vec &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="kw">sample</span>(my_char, <span class="dv">5</span>, <span class="dt">replace =</span> T),</span>
<span id="cb80-6"><a href="#cb80-6"></a>                     <span class="kw">sample</span>(my_char, <span class="dv">5</span>, <span class="dt">replace =</span> T),</span>
<span id="cb80-7"><a href="#cb80-7"></a>                     <span class="dt">sep =</span> <span class="st">&#39; - &#39;</span>)</span>
<span id="cb80-8"><a href="#cb80-8"></a></span>
<span id="cb80-9"><a href="#cb80-9"></a><span class="co"># show it</span></span>
<span id="cb80-10"><a href="#cb80-10"></a><span class="kw">print</span>(my_char_vec)</span></code></pre></div>
<pre><code>## [1] &quot;DBCFE - ABCDEF&quot;  &quot;ABCDEF - DBCFE&quot;  &quot;DBCFE - DBCFE&quot;   &quot;ABCDEF - ABCDEF&quot;
## [5] &quot;ABC - ABCDEF&quot;</code></pre>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1"></a><span class="co"># substitute all occurrences of &#39;ABC&#39;</span></span>
<span id="cb82-2"><a href="#cb82-2"></a>my_char_vec &lt;-<span class="st"> </span><span class="kw">str_replace_all</span>(<span class="dt">string =</span> my_char_vec,</span>
<span id="cb82-3"><a href="#cb82-3"></a>                               <span class="dt">pattern =</span> <span class="st">&#39;ABC&#39;</span>,</span>
<span id="cb82-4"><a href="#cb82-4"></a>                               <span class="dt">replacement =</span> <span class="st">&#39;XXX&#39;</span>)</span>
<span id="cb82-5"><a href="#cb82-5"></a></span>
<span id="cb82-6"><a href="#cb82-6"></a><span class="co"># print result</span></span>
<span id="cb82-7"><a href="#cb82-7"></a><span class="kw">print</span>(my_char_vec)</span></code></pre></div>
<pre><code>## [1] &quot;DBCFE - XXXDEF&quot;  &quot;XXXDEF - DBCFE&quot;  &quot;DBCFE - DBCFE&quot;   &quot;XXXDEF - XXXDEF&quot;
## [5] &quot;XXX - XXXDEF&quot;</code></pre>
<h3 id="splitting-text">Splitting Text</h3>
<p>Eventually, you will need to break a text into different parts.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1"></a><span class="co"># set char</span></span>
<span id="cb84-2"><a href="#cb84-2"></a>my_char &lt;-<span class="st"> &#39;ABC;ABC;BCD&#39;</span></span>
<span id="cb84-3"><a href="#cb84-3"></a></span>
<span id="cb84-4"><a href="#cb84-4"></a><span class="co"># split it based on &#39;;&#39; and using stringr::str_split</span></span>
<span id="cb84-5"><a href="#cb84-5"></a>splitted_char &lt;-<span class="st"> </span><span class="kw">str_split</span>(my_char, <span class="st">&#39;;&#39;</span>)</span>
<span id="cb84-6"><a href="#cb84-6"></a></span>
<span id="cb84-7"><a href="#cb84-7"></a><span class="co"># print result</span></span>
<span id="cb84-8"><a href="#cb84-8"></a><span class="kw">print</span>(splitted_char)</span></code></pre></div>
<pre><code>## [[1]]
## [1] &quot;ABC&quot; &quot;ABC&quot; &quot;BCD&quot;</code></pre>
<p>The output of this function is an object of type <code>list</code>. To access the text <code>BCD</code> in object <code>splitted_char,</code> we can use the following code:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1"></a><span class="kw">print</span>(splitted_char[[<span class="dv">1</span>]][<span class="dv">3</span>])</span></code></pre></div>
<pre><code>## [1] &quot;BCD&quot;</code></pre>
<p>For an example of a split in character vectors, see the next code.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1"></a><span class="co"># set char</span></span>
<span id="cb88-2"><a href="#cb88-2"></a>my_char_vec &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;ABCDEF&#39;</span>,<span class="st">&#39;DBCFE&#39;</span>,<span class="st">&#39;ABFC&#39;</span>,<span class="st">&#39;ACD&#39;</span>)</span>
<span id="cb88-3"><a href="#cb88-3"></a></span>
<span id="cb88-4"><a href="#cb88-4"></a><span class="co"># split it based on &#39;B&#39; and using stringr::strsplit</span></span>
<span id="cb88-5"><a href="#cb88-5"></a>splitted_char &lt;-<span class="st"> </span><span class="kw">str_split</span>(my_char_vec, <span class="st">&#39;B&#39;</span>)</span>
<span id="cb88-6"><a href="#cb88-6"></a></span>
<span id="cb88-7"><a href="#cb88-7"></a><span class="co"># print result</span></span>
<span id="cb88-8"><a href="#cb88-8"></a><span class="kw">print</span>(splitted_char)</span></code></pre></div>
<pre><code>## [[1]]
## [1] &quot;A&quot;    &quot;CDEF&quot;
## 
## [[2]]
## [1] &quot;D&quot;   &quot;CFE&quot;
## 
## [[3]]
## [1] &quot;A&quot;  &quot;FC&quot;
## 
## [[4]]
## [1] &quot;ACD&quot;</code></pre>
<p>Notice how, again, an object of type <code>list</code> is returned, where each element is the split text from the input vector.</p>
<h3 id="finding-the-number-of-characters-in-a-text">Finding the Number of Characters in a Text</h3>
<p>If we want to discover the number of characters in a <code>character</code> object, you can use functions <code>stringr::str_length</code> and <code>base::nchar</code>.</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1"></a><span class="co"># set char</span></span>
<span id="cb90-2"><a href="#cb90-2"></a>my_char &lt;-<span class="st"> &#39;abcdef&#39;</span></span>
<span id="cb90-3"><a href="#cb90-3"></a></span>
<span id="cb90-4"><a href="#cb90-4"></a><span class="co"># print number of characters using stringr::str_length</span></span>
<span id="cb90-5"><a href="#cb90-5"></a><span class="kw">print</span>(<span class="kw">str_length</span>(my_char))</span></code></pre></div>
<pre><code>## [1] 6</code></pre>
<p>And now an example with vectors.</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1"></a><span class="co">#set char</span></span>
<span id="cb92-2"><a href="#cb92-2"></a>my_char &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;ab&#39;</span>, <span class="st">&#39;abc&#39;</span>)</span>
<span id="cb92-3"><a href="#cb92-3"></a></span>
<span id="cb92-4"><a href="#cb92-4"></a><span class="co"># print number of characters using stringr::str_length</span></span>
<span id="cb92-5"><a href="#cb92-5"></a><span class="kw">print</span>(<span class="kw">str_length</span>(my_char))</span></code></pre></div>
<pre><code>## [1] 1 2 3</code></pre>
<h3 id="generating-combinations-of-text">Generating Combinations of Text</h3>
<p>One useful trick in R is to use functions <code>outer</code> and <code>expand.grid</code> to create all possible combinations of elements in different objects.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb94-1"><a href="#cb94-1"></a><span class="co"># set char vecs</span></span>
<span id="cb94-2"><a href="#cb94-2"></a>my_vec_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>,<span class="st">&#39;b&#39;</span>)</span>
<span id="cb94-3"><a href="#cb94-3"></a>my_vec_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;A&#39;</span>,<span class="st">&#39;B&#39;</span>)</span>
<span id="cb94-4"><a href="#cb94-4"></a></span>
<span id="cb94-5"><a href="#cb94-5"></a><span class="co"># combine in matrix</span></span>
<span id="cb94-6"><a href="#cb94-6"></a>comb_mat &lt;-<span class="st"> </span><span class="kw">outer</span>(my_vec_<span class="dv">1</span>, my_vec_<span class="dv">2</span>, paste, <span class="dt">sep=</span><span class="st">&#39;-&#39;</span>)</span>
<span id="cb94-7"><a href="#cb94-7"></a></span>
<span id="cb94-8"><a href="#cb94-8"></a><span class="co"># print it!</span></span>
<span id="cb94-9"><a href="#cb94-9"></a><span class="kw">print</span>(comb_mat)</span></code></pre></div>
<pre><code>##      [,1]  [,2] 
## [1,] &quot;a-A&quot; &quot;a-B&quot;
## [2,] &quot;b-A&quot; &quot;b-B&quot;</code></pre>
<p>The output of <code>outer</code> is a <code>matrix</code> type of object. If we wanted to change <code>comb_mat</code> to an atomic vector, we can use function <code>as.character</code>:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb96-1"><a href="#cb96-1"></a><span class="kw">print</span>(<span class="kw">as.character</span>(comb_mat))</span></code></pre></div>
<pre><code>## [1] &quot;a-A&quot; &quot;b-A&quot; &quot;a-B&quot; &quot;b-B&quot;</code></pre>
<p>Another way to reach the same objective is by using function <code>expand.grid.</code> Look at the next example, where we create different phrases based on all combinations of character vectors.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1"></a><span class="kw">library</span>(tidyverse)</span>
<span id="cb98-2"><a href="#cb98-2"></a></span>
<span id="cb98-3"><a href="#cb98-3"></a><span class="co"># set vectors</span></span>
<span id="cb98-4"><a href="#cb98-4"></a>my_vec_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;John &#39;</span>, <span class="st">&#39;Claire &#39;</span>, <span class="st">&#39;Adam &#39;</span>)</span>
<span id="cb98-5"><a href="#cb98-5"></a>my_vec_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;is fishing.&#39;</span>, <span class="st">&#39;is working.&#39;</span>)</span>
<span id="cb98-6"><a href="#cb98-6"></a></span>
<span id="cb98-7"><a href="#cb98-7"></a><span class="co"># create df with all combinations</span></span>
<span id="cb98-8"><a href="#cb98-8"></a>my_df &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">name =</span> my_vec_<span class="dv">1</span>,</span>
<span id="cb98-9"><a href="#cb98-9"></a>                     <span class="dt">verb =</span> my_vec_<span class="dv">2</span>)</span>
<span id="cb98-10"><a href="#cb98-10"></a></span>
<span id="cb98-11"><a href="#cb98-11"></a><span class="co"># print df</span></span>
<span id="cb98-12"><a href="#cb98-12"></a><span class="kw">print</span>(my_df)</span></code></pre></div>
<pre><code>##      name        verb
## 1   John  is fishing.
## 2 Claire  is fishing.
## 3   Adam  is fishing.
## 4   John  is working.
## 5 Claire  is working.
## 6   Adam  is working.</code></pre>
<div class="sourceCode" id="cb100"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1"></a><span class="co"># paste columns together in tibble</span></span>
<span id="cb100-2"><a href="#cb100-2"></a>my_df &lt;-<span class="st"> </span>my_df <span class="op">%&gt;%</span></span>
<span id="cb100-3"><a href="#cb100-3"></a><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">phrase =</span> <span class="kw">paste0</span>(name, verb) )</span>
<span id="cb100-4"><a href="#cb100-4"></a></span>
<span id="cb100-5"><a href="#cb100-5"></a><span class="co"># print result</span></span>
<span id="cb100-6"><a href="#cb100-6"></a><span class="kw">print</span>(my_df)</span></code></pre></div>
<pre><code>##      name        verb             phrase
## 1   John  is fishing.   John is fishing.
## 2 Claire  is fishing. Claire is fishing.
## 3   Adam  is fishing.   Adam is fishing.
## 4   John  is working.   John is working.
## 5 Claire  is working. Claire is working.
## 6   Adam  is working.   Adam is working.</code></pre>
<p>Here, we used the function <code>expand.grid</code> to create a <code>dataframe</code> containing all possible combinations of <code>my_vec_1</code> and <code>my_vec_2</code>. We pasted the contents of these columns using <code>paste0</code>.</p>
</div>
<div id="factor-objects" class="slide section level2">
<h1><code>Factor</code> Objects</h1>
<p>Object class <code>factor</code> is used to represent groups (categories) in a database.</p>
<p>It integrates nicely with statistical procedures and packages, so the work of dealing with groups becomes easier.</p>
<h3 id="creating-factors">Creating <code>factors</code></h3>
<p>The creation of factors is accomplished with function <code>factor</code>: </p>
<div class="sourceCode" id="cb102"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1"></a><span class="co"># create factor</span></span>
<span id="cb102-2"><a href="#cb102-2"></a>my_factor &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&#39;M&#39;</span>, <span class="st">&#39;F&#39;</span>, <span class="st">&#39;M&#39;</span>,</span>
<span id="cb102-3"><a href="#cb102-3"></a>                      <span class="st">&#39;M&#39;</span>, <span class="st">&#39;F&#39;</span>, <span class="st">&#39;F&#39;</span>))</span>
<span id="cb102-4"><a href="#cb102-4"></a></span>
<span id="cb102-5"><a href="#cb102-5"></a><span class="co"># print it</span></span>
<span id="cb102-6"><a href="#cb102-6"></a><span class="kw">print</span>(my_factor)</span></code></pre></div>
<pre><code>## [1] M F M M F F
## Levels: F M</code></pre>
<p>Notice that, in the previous example, the presentation of factors with function <code>print</code> shows its content and an extra item called <code>Levels,</code> which identifies the possible groups in the object, in this case, only <code>M</code> and <code>F.</code></p>
<h3 id="modifying-factors">Modifying <code>factors</code></h3>
<p>An important point about the <code>factor</code> type of objects is their <code>Levels</code> are immutable and will not update with the input of new data. You cannot modify the <code>Levels</code> after the creation of a <code>factor.</code> All new groups not in the <code>Levels</code> will be transformed into <code>NA</code> (<em>not available</em> ) and a <code>warning</code> message will appear on the screen.</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb104-1"><a href="#cb104-1"></a><span class="co"># set factor</span></span>
<span id="cb104-2"><a href="#cb104-2"></a>my_factor &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>))</span>
<span id="cb104-3"><a href="#cb104-3"></a></span>
<span id="cb104-4"><a href="#cb104-4"></a><span class="co"># change first element of a factor to &#39;c&#39;</span></span>
<span id="cb104-5"><a href="#cb104-5"></a>my_factor[<span class="dv">1</span>] &lt;-<span class="st"> &#39;c&#39;</span></span></code></pre></div>
<pre><code>## Warning in `[&lt;-.factor`(`*tmp*`, 1, value = &quot;c&quot;): invalid factor level, NA
## generated</code></pre>
<div class="sourceCode" id="cb106"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb106-1"><a href="#cb106-1"></a><span class="co"># print result</span></span>
<span id="cb106-2"><a href="#cb106-2"></a><span class="kw">print</span>(my_factor)</span></code></pre></div>
<pre><code>## [1] &lt;NA&gt; b    a    b   
## Levels: a b</code></pre>
<p>As we expected, the first element of <code>my_factor</code> becomes an <code>NA.</code> Here, the proper way to add a new factor is to first transform the <code>factor</code> object to a <code>character</code> object, change the content and, finally, change the class back from <code>character</code> to <code>factor.</code> </p>
<div class="sourceCode" id="cb108"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb108-1"><a href="#cb108-1"></a><span class="co"># set factor</span></span>
<span id="cb108-2"><a href="#cb108-2"></a>my_factor &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>))</span>
<span id="cb108-3"><a href="#cb108-3"></a></span>
<span id="cb108-4"><a href="#cb108-4"></a><span class="co"># change factor to character</span></span>
<span id="cb108-5"><a href="#cb108-5"></a>my_char &lt;-<span class="st"> </span><span class="kw">as.character</span>(my_factor)</span>
<span id="cb108-6"><a href="#cb108-6"></a></span>
<span id="cb108-7"><a href="#cb108-7"></a><span class="co"># change first element</span></span>
<span id="cb108-8"><a href="#cb108-8"></a>my_char[<span class="dv">1</span>] &lt;-<span class="st"> &#39;c&#39;</span></span>
<span id="cb108-9"><a href="#cb108-9"></a></span>
<span id="cb108-10"><a href="#cb108-10"></a><span class="co"># mutate it back to class factor</span></span>
<span id="cb108-11"><a href="#cb108-11"></a>my_factor &lt;-<span class="st"> </span><span class="kw">factor</span>(my_char)</span>
<span id="cb108-12"><a href="#cb108-12"></a></span>
<span id="cb108-13"><a href="#cb108-13"></a><span class="co"># show result</span></span>
<span id="cb108-14"><a href="#cb108-14"></a><span class="kw">print</span>(my_factor)</span></code></pre></div>
<pre><code>## [1] c b a b
## Levels: a b c</code></pre>
<p>Using these steps, we have the desired result in vector <code>my_factor,</code> with three <code>Levels</code>: <code>a,</code> <code>b</code> and <code>c.</code></p>
<p>The <code>tidyverse</code> universe also has its own package for handling factors: <code>forcats.</code> For the current factor modification problem, we can use <code>forcats::fct_recode</code> function. Heres an example where we change the values of factors and levels: </p>
<div class="sourceCode" id="cb110"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb110-1"><a href="#cb110-1"></a><span class="kw">library</span>(forcats)</span>
<span id="cb110-2"><a href="#cb110-2"></a></span>
<span id="cb110-3"><a href="#cb110-3"></a><span class="co"># set factor</span></span>
<span id="cb110-4"><a href="#cb110-4"></a>my_factor &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&#39;A&#39;</span>, <span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>, </span>
<span id="cb110-5"><a href="#cb110-5"></a>                      <span class="st">&#39;A&#39;</span>, <span class="st">&#39;C&#39;</span>, <span class="st">&#39;M&#39;</span>, </span>
<span id="cb110-6"><a href="#cb110-6"></a>                      <span class="st">&#39;N&#39;</span>))</span>
<span id="cb110-7"><a href="#cb110-7"></a></span>
<span id="cb110-8"><a href="#cb110-8"></a><span class="co"># modify factors</span></span>
<span id="cb110-9"><a href="#cb110-9"></a>my_factor &lt;-<span class="st"> </span><span class="kw">fct_recode</span>(my_factor,</span>
<span id="cb110-10"><a href="#cb110-10"></a>                        <span class="st">&#39;D&#39;</span> =<span class="st"> &#39;A&#39;</span>,</span>
<span id="cb110-11"><a href="#cb110-11"></a>                        <span class="st">&#39;E&#39;</span> =<span class="st"> &#39;B&#39;</span>,</span>
<span id="cb110-12"><a href="#cb110-12"></a>                        <span class="st">&#39;F&#39;</span> =<span class="st"> &#39;C&#39;</span>)</span>
<span id="cb110-13"><a href="#cb110-13"></a></span>
<span id="cb110-14"><a href="#cb110-14"></a><span class="co"># print result</span></span>
<span id="cb110-15"><a href="#cb110-15"></a><span class="kw">print</span>(my_factor)</span></code></pre></div>
<pre><code>## [1] D E F D F M N
## Levels: D E F M N</code></pre>
<p>Using <code>forcats::fct_recode</code> is intuitive. All we need to do is to set the new names with the equality symbol.</p>
<h3 id="converting-factors-to-other-classes">Converting <code>factors</code> to Other Classes</h3>
<p>Attention is required when converting a <code>factor</code> to another class. When converting a <code>factor</code> to the <code>character</code> class, the result is as expected:</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb112-1"><a href="#cb112-1"></a><span class="co"># create factor</span></span>
<span id="cb112-2"><a href="#cb112-2"></a>my_char &lt;-<span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>))</span>
<span id="cb112-3"><a href="#cb112-3"></a></span>
<span id="cb112-4"><a href="#cb112-4"></a><span class="co"># convert and print</span></span>
<span id="cb112-5"><a href="#cb112-5"></a><span class="kw">print</span>(<span class="kw">as.character</span>(my_char))</span></code></pre></div>
<pre><code>## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</code></pre>
<p>However, when the same procedure is performed for conversion from <code>factor</code> to the <code>numeric</code> class, the result is far from expected: </p>
<div class="sourceCode" id="cb114"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb114-1"><a href="#cb114-1"></a><span class="co"># set factor</span></span>
<span id="cb114-2"><a href="#cb114-2"></a>my_values &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="dv">5</span><span class="op">:</span><span class="dv">10</span>)</span>
<span id="cb114-3"><a href="#cb114-3"></a></span>
<span id="cb114-4"><a href="#cb114-4"></a><span class="co"># convert to numeric (WRONG)</span></span>
<span id="cb114-5"><a href="#cb114-5"></a><span class="kw">print</span>(<span class="kw">as.numeric</span>(my_values))</span></code></pre></div>
<pre><code>## [1] 1 2 3 4 5 6</code></pre>
<p>As you can see, all elements in <code>my_values</code> were converted to <code>c(1, 2, 3, 4, 5)</code>, which are obviously wrong.</p>
<p>Solving this problem and getting the result we want is easy; just turn the <code>factor</code> object into a <code>character</code> and then to <code>numeric,</code> as shown next:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb116-1"><a href="#cb116-1"></a><span class="co"># converting factors to character and then to numeric</span></span>
<span id="cb116-2"><a href="#cb116-2"></a><span class="kw">print</span>(<span class="kw">as.numeric</span>(<span class="kw">as.character</span>(my_values)))</span></code></pre></div>
<pre><code>## [1]  5  6  7  8  9 10</code></pre>
<p>As we can see, now we got the result we expected. As a rule of thumb, <strong>always be careful when transforming factors into numbers</strong>.</p>
<h3 id="creating-contingency-tables">Creating Contingency Tables</h3>
<p>After creating a factor, we can find the number of times that each group, or combination of groups, is found with function <code>table</code>.</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb118-1"><a href="#cb118-1"></a><span class="co"># create factor</span></span>
<span id="cb118-2"><a href="#cb118-2"></a>my_factor &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">sample</span>(<span class="kw">c</span>(<span class="st">&#39;Pref&#39;</span>, <span class="st">&#39;Ord&#39;</span>),</span>
<span id="cb118-3"><a href="#cb118-3"></a>                           <span class="dt">size =</span> <span class="dv">20</span>,</span>
<span id="cb118-4"><a href="#cb118-4"></a>                           <span class="dt">replace =</span> <span class="ot">TRUE</span>))</span>
<span id="cb118-5"><a href="#cb118-5"></a></span>
<span id="cb118-6"><a href="#cb118-6"></a><span class="co"># print contingency table</span></span>
<span id="cb118-7"><a href="#cb118-7"></a><span class="kw">print</span>(<span class="kw">table</span>(my_factor))</span></code></pre></div>
<pre><code>## my_factor
##  Ord Pref 
##    8   12</code></pre>
<p>A more advanced usage of function <code>table</code> is to consider more than one <code>factor</code>:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb120-1"><a href="#cb120-1"></a><span class="co"># set factors</span></span>
<span id="cb120-2"><a href="#cb120-2"></a>my_factor_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">sample</span>(<span class="kw">c</span>(<span class="st">&#39;Pref&#39;</span>, <span class="st">&#39;Ord&#39;</span>),</span>
<span id="cb120-3"><a href="#cb120-3"></a>                             <span class="dt">size =</span> <span class="dv">20</span>,</span>
<span id="cb120-4"><a href="#cb120-4"></a>                             <span class="dt">replace =</span> <span class="ot">TRUE</span>))</span>
<span id="cb120-5"><a href="#cb120-5"></a></span>
<span id="cb120-6"><a href="#cb120-6"></a>my_factor_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">sample</span>(<span class="kw">paste</span>(<span class="st">&#39;Grupo&#39;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>),</span>
<span id="cb120-7"><a href="#cb120-7"></a>                             <span class="dt">size =</span> <span class="dv">20</span>,</span>
<span id="cb120-8"><a href="#cb120-8"></a>                             <span class="dt">replace =</span> <span class="ot">TRUE</span>))</span>
<span id="cb120-9"><a href="#cb120-9"></a></span>
<span id="cb120-10"><a href="#cb120-10"></a><span class="co"># print contingency table with two factors</span></span>
<span id="cb120-11"><a href="#cb120-11"></a><span class="kw">print</span>(<span class="kw">table</span>(my_factor_<span class="dv">1</span>, </span>
<span id="cb120-12"><a href="#cb120-12"></a>            my_factor_<span class="dv">2</span>))</span></code></pre></div>
<pre><code>##            my_factor_2
## my_factor_1 Grupo 1 Grupo 2 Grupo 3
##        Ord        2       0       2
##        Pref       6       7       3</code></pre>
<p>The table that we created previously demonstrates the number of occurrences for each combination of groups. Therefore, it is worth knowing you can also use it with more than two factors.</p>
</div>
<div id="logical-objects" class="slide section level2">
<h1><code>Logical</code> Objects</h1>
<p>Logical tests are at the heart of R. In one line of code, and we can test a condition for a large vector of data.</p>
<h3 id="creating-logical-objects">Creating <code>logical</code> Objects</h3>
<p>Objects of class <code>logical</code> are created based on the use of condition tests on other objects. For example, in a sequence from 1 to 10, we can check what elements are higher than five with the following code:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb122-1"><a href="#cb122-1"></a><span class="co"># set numerical</span></span>
<span id="cb122-2"><a href="#cb122-2"></a>my_x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span></span>
<span id="cb122-3"><a href="#cb122-3"></a></span>
<span id="cb122-4"><a href="#cb122-4"></a><span class="co"># print a logical test</span></span>
<span id="cb122-5"><a href="#cb122-5"></a><span class="kw">print</span>(my_x <span class="op">&gt;</span><span class="st"> </span><span class="dv">5</span>)</span></code></pre></div>
<pre><code>##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE</code></pre>
<div class="sourceCode" id="cb124"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb124-1"><a href="#cb124-1"></a><span class="co"># print position of elements from logical test</span></span>
<span id="cb124-2"><a href="#cb124-2"></a><span class="kw">print</span>(<span class="kw">which</span>(my_x <span class="op">&gt;</span><span class="st"> </span><span class="dv">5</span>))</span></code></pre></div>
<pre><code>## [1]  6  7  8  9 10</code></pre>
<p>In the previous example, function <code>which</code> returned the index (position) where the condition is true (<code>TRUE</code>). </p>
<p>To perform equality tests, simply use the equality symbol twice (<strong><code>==</code></strong>): </p>
<div class="sourceCode" id="cb126"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb126-1"><a href="#cb126-1"></a><span class="co"># create char</span></span>
<span id="cb126-2"><a href="#cb126-2"></a>my_char &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&#39;abc&#39;</span>, <span class="st">&#39;bcd&#39;</span>), </span>
<span id="cb126-3"><a href="#cb126-3"></a>               <span class="dt">times =</span> <span class="dv">5</span>)</span>
<span id="cb126-4"><a href="#cb126-4"></a></span>
<span id="cb126-5"><a href="#cb126-5"></a><span class="co"># print its contents</span></span>
<span id="cb126-6"><a href="#cb126-6"></a><span class="kw">print</span>(my_char)</span></code></pre></div>
<pre><code>##  [1] &quot;abc&quot; &quot;bcd&quot; &quot;abc&quot; &quot;bcd&quot; &quot;abc&quot; &quot;bcd&quot; &quot;abc&quot; &quot;bcd&quot; &quot;abc&quot; &quot;bcd&quot;</code></pre>
<div class="sourceCode" id="cb128"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb128-1"><a href="#cb128-1"></a><span class="co"># print logical test</span></span>
<span id="cb128-2"><a href="#cb128-2"></a><span class="kw">print</span>(my_char <span class="op">==</span><span class="st"> &#39;abc&#39;</span>)</span></code></pre></div>
<pre><code>##  [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE</code></pre>
<p>For an inequality test, use symbol <strong><code>!=</code></strong>, as shown in the next code: </p>
<div class="sourceCode" id="cb130"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb130-1"><a href="#cb130-1"></a><span class="co"># print inequality test</span></span>
<span id="cb130-2"><a href="#cb130-2"></a><span class="kw">print</span>(my_char <span class="op">!=</span><span class="st"> &#39;abc&#39;</span>)</span></code></pre></div>
<pre><code>##  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE</code></pre>
<p>It is also possible to test multiple logical conditions. For simultaneous occurrences of events, use operator <code>&amp;.</code></p>
<p>For example, if we wanted to check the values from a sequence between 1 and 10 that are larger than 4 <strong>and</strong> smaller than 7, we write: </p>
<div class="sourceCode" id="cb132"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb132-1"><a href="#cb132-1"></a>my_x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span></span>
<span id="cb132-2"><a href="#cb132-2"></a></span>
<span id="cb132-3"><a href="#cb132-3"></a><span class="co"># print logical for values higher than 4 and lower than 7</span></span>
<span id="cb132-4"><a href="#cb132-4"></a><span class="kw">print</span>((my_x <span class="op">&gt;</span><span class="st"> </span><span class="dv">4</span>)<span class="op">&amp;</span>(my_x <span class="op">&lt;</span><span class="st"> </span><span class="dv">7</span>) )</span></code></pre></div>
<pre><code>##  [1] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE</code></pre>
<div class="sourceCode" id="cb134"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb134-1"><a href="#cb134-1"></a><span class="co"># print the actual values</span></span>
<span id="cb134-2"><a href="#cb134-2"></a>idx &lt;-<span class="st"> </span><span class="kw">which</span>( (my_x <span class="op">&gt;</span><span class="st"> </span><span class="dv">4</span>)<span class="op">&amp;</span>(my_x <span class="op">&lt;</span><span class="st"> </span><span class="dv">7</span>) )</span>
<span id="cb134-3"><a href="#cb134-3"></a><span class="kw">print</span>(my_x[idx])</span></code></pre></div>
<pre><code>## [1] 5 6</code></pre>
<p>For non-simultaneous conditions, i.e., the occurrence of one event or other, use the operator <code>|.</code></p>
<div class="sourceCode" id="cb136"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb136-1"><a href="#cb136-1"></a><span class="co"># location of elements higher than 7 or lower than 4</span></span>
<span id="cb136-2"><a href="#cb136-2"></a>idx &lt;-<span class="st"> </span><span class="kw">which</span>( (my_x <span class="op">&gt;</span><span class="st"> </span><span class="dv">7</span>)<span class="op">|</span>(my_x <span class="op">&lt;</span><span class="st"> </span><span class="dv">4</span>) )</span>
<span id="cb136-3"><a href="#cb136-3"></a></span>
<span id="cb136-4"><a href="#cb136-4"></a><span class="co"># print elements from previous condition</span></span>
<span id="cb136-5"><a href="#cb136-5"></a><span class="kw">print</span>(my_x[idx])</span></code></pre></div>
<pre><code>## [1]  1  2  3  8  9 10</code></pre>
<p>Another interesting use of logical objects is to test whether an item or more is found or not in another vector. For this, we use the operator <code>%in%</code>.</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb138-1"><a href="#cb138-1"></a><span class="kw">library</span>(dplyr)</span>
<span id="cb138-2"><a href="#cb138-2"></a><span class="co"># location of elements higher than 7 or lower than 4</span></span>
<span id="cb138-3"><a href="#cb138-3"></a>my_contries &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;Country 1&#39;</span>, <span class="st">&#39;Country 2&#39;</span>)</span>
<span id="cb138-4"><a href="#cb138-4"></a></span>
<span id="cb138-5"><a href="#cb138-5"></a><span class="co"># set df</span></span>
<span id="cb138-6"><a href="#cb138-6"></a>n_obs &lt;-<span class="st"> </span><span class="dv">100</span></span>
<span id="cb138-7"><a href="#cb138-7"></a>df_temp &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">country =</span> <span class="kw">str_c</span>(<span class="st">&#39;Country &#39;</span>,</span>
<span id="cb138-8"><a href="#cb138-8"></a>                                  <span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, </span>
<span id="cb138-9"><a href="#cb138-9"></a>                                         <span class="dt">size =</span> n_obs,</span>
<span id="cb138-10"><a href="#cb138-10"></a>                                         <span class="dt">replace =</span> <span class="ot">TRUE</span>)),</span>
<span id="cb138-11"><a href="#cb138-11"></a>                  <span class="dt">inflation.rate =</span> <span class="kw">rnorm</span>(n_obs, <span class="dt">sd =</span> <span class="fl">0.05</span>) ) <span class="op">%&gt;%</span></span>
<span id="cb138-12"><a href="#cb138-12"></a><span class="st">  </span><span class="kw">glimpse</span>()</span></code></pre></div>
<pre><code>## Observations: 100
## Variables: 2
## $ country        &lt;chr&gt; &quot;Country 7&quot;, &quot;Country 4&quot;, &quot;Country 4&quot;, &quot;Country 7&quot;, &quot;C
## $ inflation.rate &lt;dbl&gt; 0.0462839494, -0.0456405358, 0.0181461901, 0.031664895</code></pre>
<div class="sourceCode" id="cb140"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb140-1"><a href="#cb140-1"></a><span class="co"># filter rows of df with selected tickers</span></span>
<span id="cb140-2"><a href="#cb140-2"></a>df_temp &lt;-<span class="st"> </span>df_temp <span class="op">%&gt;%</span></span>
<span id="cb140-3"><a href="#cb140-3"></a><span class="st">  </span><span class="kw">filter</span>(country <span class="op">%in%</span><span class="st"> </span>my_contries) <span class="op">%&gt;%</span></span>
<span id="cb140-4"><a href="#cb140-4"></a><span class="st">  </span><span class="kw">glimpse</span>()</span></code></pre></div>
<pre><code>## Observations: 18
## Variables: 2
## $ country        &lt;chr&gt; &quot;Country 2&quot;, &quot;Country 2&quot;, &quot;Country 1&quot;, &quot;Country 1&quot;, &quot;C
## $ inflation.rate &lt;dbl&gt; 0.0143392460, -0.0785901866, -0.0365106100, -0.0403645</code></pre>
<p>The resulting dataframe only has rows for <code>&#39;Country 1&#39;</code> and <code>&#39;Country 2&#39;</code>. With operator <code>%in%</code>, we filtered our table so it only keeps the desired rows.</p>
</div>
<div id="date-and-time" class="slide section level2">
<h1>Date and Time</h1>
<p>When you have dates in your dataset, you must be certain they are correctly represented in R with the correct timezone.</p>
<p>In this section, we will give priority to package <code>lubridate</code> <span class="citation">[@lubridate]</span>, which offers efficient and diverse functions for time manipulation.</p>
<h3 id="creating-simple-dates">Creating Simple Dates</h3>
<p>The most basic class, indicating the day, month, and year, is <code>Date.</code> Using package <code>lubridate</code>, we create a date class object with functions <code>ymd</code> (year-month-date), <code>dmy</code> (day-month-year) e <code>mdy</code> (month-day-year). The order of components, and choice of function, is set according to the input character. Have a look:   </p>
<div class="sourceCode" id="cb142"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb142-1"><a href="#cb142-1"></a><span class="kw">library</span>(lubridate)</span></code></pre></div>
<pre><code>## 
## Attaching package: &#39;lubridate&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:base&#39;:
## 
##     date</code></pre>
<div class="sourceCode" id="cb145"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb145-1"><a href="#cb145-1"></a><span class="co"># set Date object (YMD)</span></span>
<span id="cb145-2"><a href="#cb145-2"></a><span class="kw">print</span>(<span class="kw">ymd</span>(<span class="st">&#39;2020-06-24&#39;</span>))</span></code></pre></div>
<pre><code>## [1] &quot;2020-06-24&quot;</code></pre>
<div class="sourceCode" id="cb147"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb147-1"><a href="#cb147-1"></a><span class="co"># set Date object (DMY)</span></span>
<span id="cb147-2"><a href="#cb147-2"></a><span class="kw">print</span>(<span class="kw">dmy</span>(<span class="st">&#39;24-06-2020&#39;</span>))</span></code></pre></div>
<pre><code>## [1] &quot;2020-06-24&quot;</code></pre>
<div class="sourceCode" id="cb149"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb149-1"><a href="#cb149-1"></a><span class="co"># set Date object (MDY)</span></span>
<span id="cb149-2"><a href="#cb149-2"></a><span class="kw">print</span>(<span class="kw">mdy</span>(<span class="st">&#39;06-24-2020&#39;</span>))</span></code></pre></div>
<pre><code>## [1] &quot;2020-06-24&quot;</code></pre>
<p>Note that the functions return the exact same object. The difference in usage is only by the way the input string is structured with the position of the day, month, and year.</p>
<p>Now, using the <code>base</code> package, we can create a date with function <code>as.Date</code>:  </p>
<div class="sourceCode" id="cb151"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb151-1"><a href="#cb151-1"></a><span class="co"># set Date from dd/mm/yyyy with the definition of format</span></span>
<span id="cb151-2"><a href="#cb151-2"></a>my_date &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="st">&#39;24/06/2020&#39;</span>, <span class="dt">format =</span> <span class="st">&#39;%d/%m/%Y&#39;</span>)</span>
<span id="cb151-3"><a href="#cb151-3"></a></span>
<span id="cb151-4"><a href="#cb151-4"></a><span class="co"># print result</span></span>
<span id="cb151-5"><a href="#cb151-5"></a><span class="kw">print</span>(my_date)</span></code></pre></div>
<pre><code>## [1] &quot;2020-06-24&quot;</code></pre>
<p>The symbols used in <em>input</em> <code>format,</code> such as <code>%d,</code> <code>%m,</code> and <code>%Y,</code> indicate how the character object should be converted and where the day, month and year are in the text.</p>
<table>
<thead>
<tr class="header">
<th align="center">Symbol</th>
<th align="center">Description</th>
<th align="center">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">%d</td>
<td align="center">day of month (decimal)</td>
<td align="center">0</td>
</tr>
<tr class="even">
<td align="center">%m</td>
<td align="center">month (decimal)</td>
<td align="center">12</td>
</tr>
<tr class="odd">
<td align="center">%b</td>
<td align="center">month (abbreviation)</td>
<td align="center">Apr</td>
</tr>
<tr class="even">
<td align="center">%B</td>
<td align="center">month (complete name)</td>
<td align="center">April</td>
</tr>
<tr class="odd">
<td align="center">%y</td>
<td align="center">year (2 digits)</td>
<td align="center">16</td>
</tr>
<tr class="even">
<td align="center">%Y</td>
<td align="center">month (4 digits)</td>
<td align="center">2020</td>
</tr>
</tbody>
</table>
<p>By using the previous table, youll be able to create and represent dates in a vast number of ways. Notice how the <code>lubridate</code> functions, regarding <code>base,</code> are simpler and easier to use.</p>
<h3 id="creating-a-sequence-of-dates">Creating a Sequence of <code>Dates</code></h3>
<p>An interesting aspect of objects <code>Date</code> is they interact with <code>numeric</code> objects and can be used for logical tests.</p>
<p>If we wanted to add a day after a particular date, all we need to do is to add value 1 to the object, as shown next:</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb153-1"><a href="#cb153-1"></a><span class="co"># create date</span></span>
<span id="cb153-2"><a href="#cb153-2"></a>my_date &lt;-<span class="st"> </span><span class="kw">ymd</span>(<span class="st">&#39;2020-06-01&#39;</span>)</span>
<span id="cb153-3"><a href="#cb153-3"></a></span>
<span id="cb153-4"><a href="#cb153-4"></a><span class="co"># find next day</span></span>
<span id="cb153-5"><a href="#cb153-5"></a>my_date_<span class="dv">2</span> &lt;-<span class="st"> </span>my_date <span class="op">+</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb153-6"><a href="#cb153-6"></a></span>
<span id="cb153-7"><a href="#cb153-7"></a><span class="co"># print result</span></span>
<span id="cb153-8"><a href="#cb153-8"></a><span class="kw">print</span>(my_date_<span class="dv">2</span>)</span></code></pre></div>
<pre><code>## [1] &quot;2020-06-02&quot;</code></pre>
<p>This property also works with vectors, facilitating the creation of <code>Date</code> sequences. See an example next.</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb155-1"><a href="#cb155-1"></a><span class="co"># create a sequence of Dates</span></span>
<span id="cb155-2"><a href="#cb155-2"></a>my_date_vec &lt;-<span class="st"> </span>my_date <span class="op">+</span><span class="st"> </span><span class="dv">0</span><span class="op">:</span><span class="dv">15</span></span>
<span id="cb155-3"><a href="#cb155-3"></a></span>
<span id="cb155-4"><a href="#cb155-4"></a><span class="co"># print it</span></span>
<span id="cb155-5"><a href="#cb155-5"></a><span class="kw">print</span>(my_date_vec)</span></code></pre></div>
<pre><code>##  [1] &quot;2020-06-01&quot; &quot;2020-06-02&quot; &quot;2020-06-03&quot; &quot;2020-06-04&quot; &quot;2020-06-05&quot;
##  [6] &quot;2020-06-06&quot; &quot;2020-06-07&quot; &quot;2020-06-08&quot; &quot;2020-06-09&quot; &quot;2020-06-10&quot;
## [11] &quot;2020-06-11&quot; &quot;2020-06-12&quot; &quot;2020-06-13&quot; &quot;2020-06-14&quot; &quot;2020-06-15&quot;
## [16] &quot;2020-06-16&quot;</code></pre>
<p>A more customizable way for creating <code>Date</code> sequences is using function <code>seq.</code></p>
<div class="sourceCode" id="cb157"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb157-1"><a href="#cb157-1"></a><span class="co"># set first and last Date</span></span>
<span id="cb157-2"><a href="#cb157-2"></a>my_date_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">ymd</span>(<span class="st">&#39;2017-03-07&#39;</span>)</span>
<span id="cb157-3"><a href="#cb157-3"></a>my_date_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">ymd</span>(<span class="st">&#39;2017-03-20&#39;</span>)</span>
<span id="cb157-4"><a href="#cb157-4"></a></span>
<span id="cb157-5"><a href="#cb157-5"></a><span class="co"># set sequence</span></span>
<span id="cb157-6"><a href="#cb157-6"></a>my_vec_date &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> my_date_<span class="dv">1</span>,</span>
<span id="cb157-7"><a href="#cb157-7"></a>                   <span class="dt">to =</span> my_date_<span class="dv">2</span>,</span>
<span id="cb157-8"><a href="#cb157-8"></a>                   <span class="dt">by =</span> <span class="st">&#39;2 days&#39;</span>)</span>
<span id="cb157-9"><a href="#cb157-9"></a></span>
<span id="cb157-10"><a href="#cb157-10"></a><span class="co"># print result</span></span>
<span id="cb157-11"><a href="#cb157-11"></a><span class="kw">print</span>(my_vec_date)</span></code></pre></div>
<pre><code>## [1] &quot;2017-03-07&quot; &quot;2017-03-09&quot; &quot;2017-03-11&quot; &quot;2017-03-13&quot; &quot;2017-03-15&quot;
## [6] &quot;2017-03-17&quot; &quot;2017-03-19&quot;</code></pre>
<p>Likewise, if we wanted a sequence of dates for every two weeks, we can simply change input <code>by</code> to <code>&#39;2 weeks&#39;</code>:</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb159-1"><a href="#cb159-1"></a><span class="co"># set first and last Date</span></span>
<span id="cb159-2"><a href="#cb159-2"></a>my_date_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">ymd</span>(<span class="st">&#39;2017-03-07&#39;</span>)</span>
<span id="cb159-3"><a href="#cb159-3"></a>my_date_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">ymd</span>(<span class="st">&#39;2017-04-20&#39;</span>)</span>
<span id="cb159-4"><a href="#cb159-4"></a></span>
<span id="cb159-5"><a href="#cb159-5"></a><span class="co"># set sequence</span></span>
<span id="cb159-6"><a href="#cb159-6"></a>my_vec_date &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> my_date_<span class="dv">1</span>,</span>
<span id="cb159-7"><a href="#cb159-7"></a>                   <span class="dt">to =</span> my_date_<span class="dv">2</span>,</span>
<span id="cb159-8"><a href="#cb159-8"></a>                   <span class="dt">by =</span> <span class="st">&#39;2 weeks&#39;</span>)</span>
<span id="cb159-9"><a href="#cb159-9"></a></span>
<span id="cb159-10"><a href="#cb159-10"></a><span class="co"># print result</span></span>
<span id="cb159-11"><a href="#cb159-11"></a><span class="kw">print</span>(my_vec_date)</span></code></pre></div>
<pre><code>## [1] &quot;2017-03-07&quot; &quot;2017-03-21&quot; &quot;2017-04-04&quot; &quot;2017-04-18&quot;</code></pre>
<p>Another way to use function <code>seq</code> is by setting the desired length of the sequence of dates. For example, if we wanted an array of dates with 10 elements, we would use:</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb161-1"><a href="#cb161-1"></a><span class="co"># set dates</span></span>
<span id="cb161-2"><a href="#cb161-2"></a>my_date_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="st">&#39;2020-06-27&#39;</span>)</span>
<span id="cb161-3"><a href="#cb161-3"></a>my_date_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="st">&#39;2020-07-27&#39;</span>)</span>
<span id="cb161-4"><a href="#cb161-4"></a></span>
<span id="cb161-5"><a href="#cb161-5"></a><span class="co"># set sequence with 10 elements</span></span>
<span id="cb161-6"><a href="#cb161-6"></a>my_vec_date &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> my_date_<span class="dv">1</span>,</span>
<span id="cb161-7"><a href="#cb161-7"></a>                   <span class="dt">to =</span> my_date_<span class="dv">2</span>,</span>
<span id="cb161-8"><a href="#cb161-8"></a>                   <span class="dt">length.out =</span> <span class="dv">10</span>)</span>
<span id="cb161-9"><a href="#cb161-9"></a></span>
<span id="cb161-10"><a href="#cb161-10"></a><span class="co"># print result</span></span>
<span id="cb161-11"><a href="#cb161-11"></a><span class="kw">print</span>(my_vec_date)</span></code></pre></div>
<pre><code>##  [1] &quot;2020-06-27&quot; &quot;2020-06-30&quot; &quot;2020-07-03&quot; &quot;2020-07-07&quot; &quot;2020-07-10&quot;
##  [6] &quot;2020-07-13&quot; &quot;2020-07-17&quot; &quot;2020-07-20&quot; &quot;2020-07-23&quot; &quot;2020-07-27&quot;</code></pre>
<p>Once again, the interval between the dates is automatically defined by the function.</p>
<h3 id="operations-with-dates">Operations with <code>Dates</code></h3>
<p>We can calculate difference of days between two dates by simply subtracting one from the other. Have a look:</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb163-1"><a href="#cb163-1"></a><span class="co"># set dates</span></span>
<span id="cb163-2"><a href="#cb163-2"></a>my_date_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">ymd</span>(<span class="st">&#39;2015-06-24&#39;</span>)</span>
<span id="cb163-3"><a href="#cb163-3"></a>my_date_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">ymd</span>(<span class="st">&#39;2020-06-24&#39;</span>)</span>
<span id="cb163-4"><a href="#cb163-4"></a></span>
<span id="cb163-5"><a href="#cb163-5"></a><span class="co"># calculate difference</span></span>
<span id="cb163-6"><a href="#cb163-6"></a>diff_date &lt;-<span class="st"> </span>my_date_<span class="dv">2</span> <span class="op">-</span><span class="st"> </span>my_date_<span class="dv">1</span></span>
<span id="cb163-7"><a href="#cb163-7"></a></span>
<span id="cb163-8"><a href="#cb163-8"></a><span class="co"># print result</span></span>
<span id="cb163-9"><a href="#cb163-9"></a><span class="kw">print</span>(diff_date)</span></code></pre></div>
<pre><code>## Time difference of 1827 days</code></pre>
<p>The output of the subtraction operation is an object of class <code>diffdate,</code> based on the <code>list</code> class. In the previous chapter, we mentioned that we could access the elements of a <code>list</code> using double brackets.</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb165-1"><a href="#cb165-1"></a><span class="co"># print difference of days as numerical value</span></span>
<span id="cb165-2"><a href="#cb165-2"></a><span class="kw">print</span>(diff_date[[<span class="dv">1</span>]])</span></code></pre></div>
<pre><code>## [1] 1827</code></pre>
<p>Going further, we can also use mathematical operators to test whether a date is more recent or not than another:</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb167-1"><a href="#cb167-1"></a><span class="co"># set date and vector</span></span>
<span id="cb167-2"><a href="#cb167-2"></a>my_date_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">ymd</span>(<span class="st">&#39;2020-06-20&#39;</span>)</span>
<span id="cb167-3"><a href="#cb167-3"></a>my_date_vec &lt;-<span class="st"> </span><span class="kw">ymd</span>(<span class="st">&#39;2020-06-20&#39;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">seq</span>(<span class="op">-</span><span class="dv">5</span>,<span class="dv">5</span>)</span>
<span id="cb167-4"><a href="#cb167-4"></a></span>
<span id="cb167-5"><a href="#cb167-5"></a><span class="co"># test which elements of my_date_vec are older than my_date_1</span></span>
<span id="cb167-6"><a href="#cb167-6"></a>my.test &lt;-<span class="st"> </span>(my_date_vec <span class="op">&gt;</span><span class="st"> </span>my_date_<span class="dv">1</span>)</span>
<span id="cb167-7"><a href="#cb167-7"></a></span>
<span id="cb167-8"><a href="#cb167-8"></a><span class="co"># print result</span></span>
<span id="cb167-9"><a href="#cb167-9"></a><span class="kw">print</span>(my.test)</span></code></pre></div>
<pre><code>##  [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE</code></pre>
<p>The previous operation is useful when selecting a certain period of time in your dataset.</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb169-1"><a href="#cb169-1"></a><span class="kw">library</span>(dplyr)</span>
<span id="cb169-2"><a href="#cb169-2"></a><span class="kw">library</span>(lubridate)</span>
<span id="cb169-3"><a href="#cb169-3"></a></span>
<span id="cb169-4"><a href="#cb169-4"></a><span class="co"># set first and last dates</span></span>
<span id="cb169-5"><a href="#cb169-5"></a>first_date &lt;-<span class="st"> </span><span class="kw">ymd</span>(<span class="st">&#39;2020-06-01&#39;</span>)</span>
<span id="cb169-6"><a href="#cb169-6"></a>last_date &lt;-<span class="st"> </span><span class="kw">ymd</span>(<span class="st">&#39;2020-06-15&#39;</span>)</span>
<span id="cb169-7"><a href="#cb169-7"></a></span>
<span id="cb169-8"><a href="#cb169-8"></a><span class="co"># create dataframe and glimpse it</span></span>
<span id="cb169-9"><a href="#cb169-9"></a>my_temp_df &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">date.vec =</span> <span class="kw">ymd</span>(<span class="st">&#39;2020-05-25&#39;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">seq</span>(<span class="dv">0</span>,<span class="dv">30</span>),</span>
<span id="cb169-10"><a href="#cb169-10"></a>                     <span class="dt">prices=</span><span class="kw">seq</span>(<span class="dv">1</span>,<span class="dv">10</span>,</span>
<span id="cb169-11"><a href="#cb169-11"></a>                                <span class="dt">length.out =</span> <span class="kw">length</span>(date.vec)))</span>
<span id="cb169-12"><a href="#cb169-12"></a></span>
<span id="cb169-13"><a href="#cb169-13"></a><span class="co"># find dates that are between the first and last date</span></span>
<span id="cb169-14"><a href="#cb169-14"></a>my_idx &lt;-<span class="st"> </span>(my_temp_df<span class="op">$</span>date.vec <span class="op">&gt;=</span><span class="st"> </span>first_date) <span class="op">&amp;</span></span>
<span id="cb169-15"><a href="#cb169-15"></a><span class="st">  </span>(my_temp_df<span class="op">$</span>date.vec <span class="op">&lt;=</span><span class="st"> </span>last_date)</span>
<span id="cb169-16"><a href="#cb169-16"></a></span>
<span id="cb169-17"><a href="#cb169-17"></a><span class="co"># use index to filter dataframe</span></span>
<span id="cb169-18"><a href="#cb169-18"></a>my_temp_df_filtered &lt;-<span class="st"> </span>my_temp_df <span class="op">%&gt;%</span></span>
<span id="cb169-19"><a href="#cb169-19"></a><span class="st">  </span><span class="kw">filter</span>(my_idx) <span class="op">%&gt;%</span></span>
<span id="cb169-20"><a href="#cb169-20"></a><span class="st">  </span><span class="kw">glimpse</span>()</span></code></pre></div>
<pre><code>## Observations: 15
## Variables: 2
## $ date.vec &lt;date&gt; 2020-06-01, 2020-06-02, 2020-06-03, 2020-06-04, 2020-06-05,
## $ prices   &lt;dbl&gt; 3.1, 3.4, 3.7, 4.0, 4.3, 4.6, 4.9, 5.2, 5.5, 5.8, 6.1, 6.4, </code></pre>
<p>In the previous code, the object <code>my_temp_df_filtered</code> will only contain rows for the time period between 2020-06-01 and 2020-06-15.</p>
<h3 id="dealing-with-time">Dealing with Time</h3>
<p>In R, the time/date format also follows the <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 standard</a><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> and is represented as year-month-day hours:minutes:seconds timezone (YYYY-MM-DD HH:mm:SS TMZ). See the following example:</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb171-1"><a href="#cb171-1"></a><span class="co"># creating a POSIXct object</span></span>
<span id="cb171-2"><a href="#cb171-2"></a>my_timedate &lt;-<span class="st"> </span><span class="kw">as.POSIXct</span>(<span class="st">&#39;2020-01-01 16:00:00&#39;</span>)</span>
<span id="cb171-3"><a href="#cb171-3"></a></span>
<span id="cb171-4"><a href="#cb171-4"></a><span class="co"># print result</span></span>
<span id="cb171-5"><a href="#cb171-5"></a><span class="kw">print</span>(my_timedate)</span></code></pre></div>
<pre><code>## [1] &quot;2020-01-01 16:00:00 -03&quot;</code></pre>
<p>The <code>lubridate</code> package also offers intelligent functions for creating date-time objects. These follow the same structural intuition as the date creation functions.</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb173-1"><a href="#cb173-1"></a><span class="kw">library</span>(lubridate)</span>
<span id="cb173-2"><a href="#cb173-2"></a></span>
<span id="cb173-3"><a href="#cb173-3"></a><span class="co"># creating a POSIXlt object</span></span>
<span id="cb173-4"><a href="#cb173-4"></a>my_timedate &lt;-<span class="st"> </span><span class="kw">ymd_hms</span>(<span class="st">&#39;2020-01-01 16:00:00&#39;</span>)</span>
<span id="cb173-5"><a href="#cb173-5"></a></span>
<span id="cb173-6"><a href="#cb173-6"></a><span class="co"># print it</span></span>
<span id="cb173-7"><a href="#cb173-7"></a><span class="kw">print</span>(my_timedate)</span></code></pre></div>
<pre><code>## [1] &quot;2020-01-01 16:00:00 UTC&quot;</code></pre>
<p>You should note that this class automatically adds the time zone. If you need to represent a different time zone, you can do so with the <code>tz</code> argument:</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb175-1"><a href="#cb175-1"></a><span class="co"># creating a POSIXlt object with custom timezone</span></span>
<span id="cb175-2"><a href="#cb175-2"></a>my_timedate_tz &lt;-<span class="st"> </span><span class="kw">ymd_hms</span>(<span class="st">&#39;2020-01-01 16:00:00&#39;</span>,</span>
<span id="cb175-3"><a href="#cb175-3"></a>                          <span class="dt">tz =</span> <span class="st">&#39;GMT&#39;</span>)</span>
<span id="cb175-4"><a href="#cb175-4"></a></span>
<span id="cb175-5"><a href="#cb175-5"></a><span class="co"># print it</span></span>
<span id="cb175-6"><a href="#cb175-6"></a><span class="kw">print</span>(my_timedate_tz)</span></code></pre></div>
<pre><code>## [1] &quot;2020-01-01 16:00:00 GMT&quot;</code></pre>
<p>An important note in the case of <code>POSIXlt</code> and <code>POSIXct</code> objects, <strong>the operations of sum and subtraction refer to seconds</strong>, not days, as with objects from the <code>Date</code> class:</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb177-1"><a href="#cb177-1"></a><span class="co"># Adding values (seconds) to a POSIXlt object and printing it</span></span>
<span id="cb177-2"><a href="#cb177-2"></a><span class="kw">print</span>(my_timedate_tz <span class="op">+</span><span class="st"> </span><span class="dv">30</span>)</span></code></pre></div>
<pre><code>## [1] &quot;2020-01-01 16:00:30 GMT&quot;</code></pre>
<h3 id="extracting-elements-of-a-date">Extracting Elements of a Date</h3>
<p>We can use function <code>format</code> to extract data elements such as the year, month, day, hour, minute and second.</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb179-1"><a href="#cb179-1"></a><span class="kw">library</span>(lubridate)</span>
<span id="cb179-2"><a href="#cb179-2"></a></span>
<span id="cb179-3"><a href="#cb179-3"></a><span class="co"># create vector of date-time</span></span>
<span id="cb179-4"><a href="#cb179-4"></a>my_datetime &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="kw">ymd_hms</span>(<span class="st">&#39;2020-01-01 12:00:00&#39;</span>),</span>
<span id="cb179-5"><a href="#cb179-5"></a>                   <span class="dt">to =</span> <span class="kw">ymd_hms</span>(<span class="st">&#39;2020-01-01 18:00:00&#39;</span>),</span>
<span id="cb179-6"><a href="#cb179-6"></a>                   <span class="dt">by =</span> <span class="st">&#39;1 hour&#39;</span>)</span>
<span id="cb179-7"><a href="#cb179-7"></a></span>
<span id="cb179-8"><a href="#cb179-8"></a><span class="co"># get hours from POSIXlt</span></span>
<span id="cb179-9"><a href="#cb179-9"></a>my_hours &lt;-<span class="st"> </span><span class="kw">format</span>(my_datetime, <span class="st">&#39;%H&#39;</span>)</span>
<span id="cb179-10"><a href="#cb179-10"></a></span>
<span id="cb179-11"><a href="#cb179-11"></a><span class="co"># print result</span></span>
<span id="cb179-12"><a href="#cb179-12"></a><span class="kw">print</span>(my_hours)</span></code></pre></div>
<pre><code>## [1] &quot;12&quot; &quot;13&quot; &quot;14&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot;</code></pre>
<p>Likewise, we can use symbols <code>%M</code> and <code>%S</code> to extract the hours, minutes and seconds of a <code>POSIXct</code> object:</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb181-1"><a href="#cb181-1"></a><span class="co"># create vector of date-time</span></span>
<span id="cb181-2"><a href="#cb181-2"></a>n_dates &lt;-<span class="st"> </span><span class="dv">10</span></span>
<span id="cb181-3"><a href="#cb181-3"></a>my_datetime &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dt">from =</span> <span class="kw">ymd_hms</span>(<span class="st">&#39;2020-01-01 12:00:00&#39;</span>),</span>
<span id="cb181-4"><a href="#cb181-4"></a>                   <span class="dt">to =</span> <span class="kw">ymd_hms</span>(<span class="st">&#39;2020-01-01 18:00:00&#39;</span>),</span>
<span id="cb181-5"><a href="#cb181-5"></a>                   <span class="dt">length.out =</span> n_dates) <span class="op">+</span><span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">59</span>, </span>
<span id="cb181-6"><a href="#cb181-6"></a>                                                  <span class="dt">size =</span> n_dates)</span>
<span id="cb181-7"><a href="#cb181-7"></a></span>
<span id="cb181-8"><a href="#cb181-8"></a><span class="co"># get minutes from POSIXlt</span></span>
<span id="cb181-9"><a href="#cb181-9"></a>my_minutes &lt;-<span class="st"> </span><span class="kw">format</span>(my_datetime, <span class="st">&#39;%H:%M:%S&#39;</span>)</span>
<span id="cb181-10"><a href="#cb181-10"></a></span>
<span id="cb181-11"><a href="#cb181-11"></a><span class="co"># print result</span></span>
<span id="cb181-12"><a href="#cb181-12"></a><span class="kw">print</span>(my_minutes)</span></code></pre></div>
<pre><code>##  [1] &quot;12:00:55&quot; &quot;12:40:53&quot; &quot;13:20:50&quot; &quot;14:00:01&quot; &quot;14:40:05&quot; &quot;15:20:58&quot;
##  [7] &quot;16:00:32&quot; &quot;16:40:02&quot; &quot;17:20:04&quot; &quot;18:00:11&quot;</code></pre>
<p>Alternatively, we can use <code>lubridate</code> functions such as <code>hour</code> and <code>minute</code>:  </p>
<div class="sourceCode" id="cb183"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb183-1"><a href="#cb183-1"></a><span class="co"># get hours with lubridate</span></span>
<span id="cb183-2"><a href="#cb183-2"></a><span class="kw">print</span>(<span class="kw">hour</span>(my_datetime))</span></code></pre></div>
<pre><code>##  [1] 12 12 13 14 14 15 16 16 17 18</code></pre>
<div class="sourceCode" id="cb185"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb185-1"><a href="#cb185-1"></a><span class="co"># get minutes with lubridate</span></span>
<span id="cb185-2"><a href="#cb185-2"></a><span class="kw">print</span>(<span class="kw">minute</span>(my_datetime))</span></code></pre></div>
<pre><code>##  [1]  0 40 20  0 40 20  0 40 20  0</code></pre>
<p>Functions for extracting other components of a date, such as <code>lubridate::year</code> and <code>lubridate::second,</code> are also available.</p>
<h3 id="find-the-current-date-and-time">Find the Current Date and Time</h3>
<p>If you want to find the present day, use function <code>base::Sys.Date</code> or <code>lubridate::today</code>  </p>
<div class="sourceCode" id="cb187"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb187-1"><a href="#cb187-1"></a><span class="kw">library</span>(lubridate)</span>
<span id="cb187-2"><a href="#cb187-2"></a></span>
<span id="cb187-3"><a href="#cb187-3"></a><span class="co"># get today</span></span>
<span id="cb187-4"><a href="#cb187-4"></a><span class="kw">print</span>(<span class="kw">Sys.Date</span>())</span></code></pre></div>
<pre><code>## [1] &quot;2020-02-26&quot;</code></pre>
<div class="sourceCode" id="cb189"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb189-1"><a href="#cb189-1"></a><span class="co"># print it</span></span>
<span id="cb189-2"><a href="#cb189-2"></a><span class="kw">print</span>(<span class="kw">today</span>())</span></code></pre></div>
<pre><code>## [1] &quot;2020-02-26&quot;</code></pre>
<p>If you want to find the current date and time, we use function <code>base::Sys.time</code> or <code>lubridate::now</code>:  </p>
<div class="sourceCode" id="cb191"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb191-1"><a href="#cb191-1"></a><span class="co"># get time!</span></span>
<span id="cb191-2"><a href="#cb191-2"></a><span class="kw">print</span>(<span class="kw">Sys.time</span>())</span></code></pre></div>
<pre><code>## [1] &quot;2020-02-26 09:02:49 -03&quot;</code></pre>
<div class="sourceCode" id="cb193"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb193-1"><a href="#cb193-1"></a><span class="co"># get time!</span></span>
<span id="cb193-2"><a href="#cb193-2"></a><span class="kw">print</span>(<span class="kw">now</span>())</span></code></pre></div>
<pre><code>## [1] &quot;2020-02-26 09:02:49 -03&quot;</code></pre>
<p>Going further, based on these functions, we can write:</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb195-1"><a href="#cb195-1"></a><span class="co"># example of log message</span></span>
<span id="cb195-2"><a href="#cb195-2"></a>my_sys_info &lt;-<span class="st"> </span><span class="kw">Sys.info</span>()</span>
<span id="cb195-3"><a href="#cb195-3"></a>my_str &lt;-<span class="st"> </span><span class="kw">str_c</span>(<span class="st">&#39;Log of execution</span><span class="ch">\n</span><span class="st">&#39;</span>,</span>
<span id="cb195-4"><a href="#cb195-4"></a>                <span class="st">&#39;Time of execution: &#39;</span>, <span class="kw">now</span>(), <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>,</span>
<span id="cb195-5"><a href="#cb195-5"></a>                <span class="st">&#39;User: &#39;</span>, my_sys_info[<span class="st">&#39;user&#39;</span>], <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>,</span>
<span id="cb195-6"><a href="#cb195-6"></a>                <span class="st">&#39;Computer: &#39;</span>, my_sys_info[<span class="st">&#39;nodename&#39;</span>])</span>
<span id="cb195-7"><a href="#cb195-7"></a></span>
<span id="cb195-8"><a href="#cb195-8"></a><span class="co"># print it</span></span>
<span id="cb195-9"><a href="#cb195-9"></a><span class="kw">cat</span>(my_str)</span></code></pre></div>
<pre><code>## Log of execution
## Time of execution: 2020-02-26 09:02:49
## User: msperlin
## Computer: Dell-Desktop</code></pre>
<p>This is the exact time when this book was compiled in its final version. Notice we also got some details regarding username and computer with function <code>Sys.info.</code></p>
</div>
<div id="missing-data---na-not-available" class="slide section level2">
<h1>Missing Data - <code>NA</code> (<em>Not available</em>)</h1>
<p>One of the main innovations of R is the representation of missing data with objects of class <code>NA</code> (<em>Not Available</em>).</p>
<h3 id="defining-na-values">Defining <code>NA</code> Values</h3>
<p>To define omissions in the dataset, use symbol <code>NA</code> without quotes:</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb197-1"><a href="#cb197-1"></a><span class="co"># a vector with NA</span></span>
<span id="cb197-2"><a href="#cb197-2"></a>my_x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="ot">NA</span>, <span class="dv">4</span>, <span class="dv">5</span>)</span>
<span id="cb197-3"><a href="#cb197-3"></a></span>
<span id="cb197-4"><a href="#cb197-4"></a><span class="co"># print it</span></span>
<span id="cb197-5"><a href="#cb197-5"></a><span class="kw">print</span>(my_x)</span></code></pre></div>
<pre><code>## [1]  1  2 NA  4  5</code></pre>
<p>An important information that you must remember from previous chapters is that an <code>NA</code> object is contagious.</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb199-1"><a href="#cb199-1"></a><span class="co"># a vector </span></span>
<span id="cb199-2"><a href="#cb199-2"></a>my_y &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">1</span>)</span>
<span id="cb199-3"><a href="#cb199-3"></a></span>
<span id="cb199-4"><a href="#cb199-4"></a><span class="co"># example of NA interacting with other objects</span></span>
<span id="cb199-5"><a href="#cb199-5"></a><span class="kw">print</span>(my_x <span class="op">+</span><span class="st"> </span>my_y)</span></code></pre></div>
<pre><code>## [1]  3  5 NA  8  6</code></pre>
<p>This property demands special attention if you are calculating a value recursively, such as when using functions <code>cumsum</code> and <code>cumprod.</code> In these cases, any value after <code>NA</code> will turn into <code>NA</code>:</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb201-1"><a href="#cb201-1"></a><span class="co"># set vector with NA</span></span>
<span id="cb201-2"><a href="#cb201-2"></a>my_x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="ot">NA</span>, <span class="dv">5</span><span class="op">:</span><span class="dv">10</span>)</span>
<span id="cb201-3"><a href="#cb201-3"></a></span>
<span id="cb201-4"><a href="#cb201-4"></a><span class="co"># print cumsum (NA after sixth element)</span></span>
<span id="cb201-5"><a href="#cb201-5"></a><span class="kw">print</span>(<span class="kw">cumsum</span>(my_x))</span></code></pre></div>
<pre><code>##  [1]  1  3  6 10 15 NA NA NA NA NA NA NA</code></pre>
<div class="sourceCode" id="cb203"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb203-1"><a href="#cb203-1"></a><span class="co"># print cumprod (NA after sixth element)</span></span>
<span id="cb203-2"><a href="#cb203-2"></a><span class="kw">print</span>(<span class="kw">cumprod</span>(my_x))</span></code></pre></div>
<pre><code>##  [1]   1   2   6  24 120  NA  NA  NA  NA  NA  NA  NA</code></pre>
<p>Therefore, when using functions <code>cumsum</code> and <code>cumprod,</code> make sure no <code>NA</code> value is found in the input vector.</p>
<h3 id="finding-and-replacing-na">Finding and Replacing <code>NA</code></h3>
<p>To find <code>NA</code> values, use function <code>is.na</code>: </p>
<div class="sourceCode" id="cb205"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb205-1"><a href="#cb205-1"></a><span class="co"># set vector with NA</span></span>
<span id="cb205-2"><a href="#cb205-2"></a>my_x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="ot">NA</span>, <span class="dv">4</span><span class="op">:</span><span class="dv">10</span>)</span>
<span id="cb205-3"><a href="#cb205-3"></a></span>
<span id="cb205-4"><a href="#cb205-4"></a><span class="co"># Test and find location of NA</span></span>
<span id="cb205-5"><a href="#cb205-5"></a><span class="kw">print</span>(<span class="kw">is.na</span>(my_x))</span></code></pre></div>
<pre><code>##  [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE</code></pre>
<div class="sourceCode" id="cb207"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb207-1"><a href="#cb207-1"></a><span class="kw">print</span>(<span class="kw">which</span>(<span class="kw">is.na</span>(my_x)))</span></code></pre></div>
<pre><code>## [1] 3</code></pre>
<p>To replace it, use indexing with the output of <code>is.na</code>:</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb209-1"><a href="#cb209-1"></a><span class="co"># set vector</span></span>
<span id="cb209-2"><a href="#cb209-2"></a>my_x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="ot">NA</span>, <span class="dv">3</span><span class="op">:</span><span class="dv">4</span>, <span class="ot">NA</span>)</span>
<span id="cb209-3"><a href="#cb209-3"></a></span>
<span id="cb209-4"><a href="#cb209-4"></a><span class="co"># replace NA for 2</span></span>
<span id="cb209-5"><a href="#cb209-5"></a>my_x[<span class="kw">is.na</span>(my_x)] &lt;-<span class="st"> </span><span class="dv">2</span></span>
<span id="cb209-6"><a href="#cb209-6"></a></span>
<span id="cb209-7"><a href="#cb209-7"></a><span class="co"># print result</span></span>
<span id="cb209-8"><a href="#cb209-8"></a><span class="kw">print</span>(my_x)</span></code></pre></div>
<pre><code>## [1] 1 2 3 4 2</code></pre>
<p>Another way to remove <code>NA</code> values is to use the function <code>na.omit,</code> which returns the same object, but without the <code>NA</code> values.</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb211-1"><a href="#cb211-1"></a><span class="co"># set vector</span></span>
<span id="cb211-2"><a href="#cb211-2"></a>my_char &lt;-<span class="st"> </span><span class="kw">c</span>(letters[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>], <span class="ot">NA</span>, letters[<span class="dv">5</span><span class="op">:</span><span class="dv">8</span>])</span>
<span id="cb211-3"><a href="#cb211-3"></a></span>
<span id="cb211-4"><a href="#cb211-4"></a><span class="co"># print it</span></span>
<span id="cb211-5"><a href="#cb211-5"></a><span class="kw">print</span>(my_char)</span></code></pre></div>
<pre><code>## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; NA  &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot;</code></pre>
<div class="sourceCode" id="cb213"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb213-1"><a href="#cb213-1"></a><span class="co"># use na.omit to remove NA</span></span>
<span id="cb213-2"><a href="#cb213-2"></a>my_char &lt;-<span class="st"> </span><span class="kw">na.omit</span>(my_char)</span>
<span id="cb213-3"><a href="#cb213-3"></a></span>
<span id="cb213-4"><a href="#cb213-4"></a><span class="co"># print result</span></span>
<span id="cb213-5"><a href="#cb213-5"></a><span class="kw">print</span>(my_char)</span></code></pre></div>
<pre><code>## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot;
## attr(,&quot;na.action&quot;)
## [1] 4
## attr(,&quot;class&quot;)
## [1] &quot;omit&quot;</code></pre>
</div>
<div id="exercises" class="slide section level2">
<h1>Exercises</h1>
<ol style="list-style-type: decimal">
<li><p>Lets assume that, on a certain date, you bought 100 shares of a company, 15 dollars per share. After some time, you sold 30 shares for 18 dollars each and the remaining shares were sold for 22 dollars in a later day. Using a <em>script</em> in R, structure this financial problem by creating numeric objects. What is the gross profit of this stock market transaction?</p></li>
<li><p>Consider these numeric vectors <code>x</code> and <code>y</code>:</p></li>
</ol>
<div class="sourceCode" id="cb215"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb215-1"><a href="#cb215-1"></a><span class="kw">set.seed</span>(<span class="dv">7</span>)</span>
<span id="cb215-2"><a href="#cb215-2"></a>x &lt;-<span class="st"> </span><span class="kw">sample</span> (<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">size =</span> <span class="dv">5</span>, <span class="dt">replace =</span> T)</span>
<span id="cb215-3"><a href="#cb215-3"></a>y &lt;-<span class="st"> </span><span class="kw">sample</span> (<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">size =</span> <span class="dv">5</span>, <span class="dt">replace =</span> T)</span></code></pre></div>
<p>What is the sum of the elements of a new vector resulting from the multiplication between the elements of x and y?</p>
<ol start="3" style="list-style-type: decimal">
<li><p>Create a sequence called <code>seq_1</code>, with values between -10 and 10, where the interval between elements is equal to 2.</p></li>
<li><p>Define another object named <code>seq_2</code>, which contains a sequence of length 1000, with values between 0 and 100.</p></li>
<li><p>Calculate the sum between <code>seq_1</code> and <code>seq_2</code>. Did this operation work despite the different sizes of the vectors? Explain your answer.</p></li>
<li><p>If we create an object with the cumulative sum of a sequence from 1 to 100, what is the position of the first element that exceeds the value of 50?</p></li>
<li><p>Create a vector according to the following formula, where <span class="math inline">\(i=1 ... 100\)</span>. What is the value of the sum of the elements of x?</p></li>
</ol>
<p><span class="math display">\[
x_i = \frac{(-1^{i + 1})}{2i-1}
\]</span></p>
<ol start="8" style="list-style-type: decimal">
<li><strong>CHALLENGE</strong> - Create a <span class="math inline">\(z_i\)</span> vector according to the following formula, where <span class="math inline">\(x_i = 1...50\)</span> and <span class="math inline">\(y_i = 50...1\)</span>. What is the value of the sum of <span class="math inline">\(z_i\)</span> elements? (TIP: see function <code>dplyr::lag</code>)</li>
</ol>
<p><span class="math display">\[
z_i = \frac{y_i-x_{i-1}}{y_{i-2}}
\]</span></p>
<ol start="9" style="list-style-type: decimal">
<li><p>Create an object named <code>x</code> with 1000 random values taken from a Normal distribution with average and standard deviation equal to 10. Using the <code>cut</code> function, create another object that defines two groups based on values of <code>x,</code> one for values higher than 10, and another for values under -5. How many observations do we find in each group?</p></li>
<li><p>Execute the following code and create object <code>my_char</code>:</p></li>
</ol>
<div class="sourceCode" id="cb216"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb216-1"><a href="#cb216-1"></a><span class="kw">set.seed</span>(<span class="dv">10</span>)</span>
<span id="cb216-2"><a href="#cb216-2"></a>my_char &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="kw">sample</span>(letters, </span>
<span id="cb216-3"><a href="#cb216-3"></a>                        <span class="dt">size =</span>  <span class="dv">500</span>, </span>
<span id="cb216-4"><a href="#cb216-4"></a>                        <span class="dt">replace =</span> T), </span>
<span id="cb216-5"><a href="#cb216-5"></a>                 <span class="dt">collapse =</span> <span class="st">&#39;&#39;</span>)</span></code></pre></div>
<p>How often is the letter <code>&#39;x&#39;</code> found in the resulting text object?</p>
<ol start="11" style="list-style-type: decimal">
<li><p>If we split the <code>my_char</code> object from the previous exercise into several smaller pieces of text using the letter <code>&quot;b,&quot;</code> what is the number of characters in the largest piece?</p></li>
<li><p>At link <a href="https://www.gutenberg.org/ebooks/2264.txt.utf-8">https://www.gutenberg.org/ebooks/2264.txt.utf-8</a>, you can find a file containing the full text of William Shakespeares Macbeth book. Use the link directly with function <code>readr::read_lines</code> to import the entire book as a vector of characters called <code>my_book.</code> How many lines does the resulting object have?</p></li>
<li><p>Aggregate the vector of characters in <code>my_book</code> to a single text object named <code>full_text</code> using function <code>paste0(my_book, collapse = &#39;\n&#39;)</code>. With functions from package <code>stringr,</code> check how often the word <code>&#39;lord&#39;</code> repeats itself throughout the text.</p></li>
<li><p><strong>CHALLENGE</strong> - Use function <code>stringr::str_split</code> in object <code>full_text</code> to break the whole text as a function of whitespace (<code>&#39; &#39;</code>). Use this information with the function <code>base::table</code> and create a frequency table, showing the number of occurrences of each word. What are the five most used words in the text?</p></li>
<li><p>Assuming youll live for 100 years, what is the proportion of your birthdays that will land on a weekend day (Sunday/Saturday)? Tip: Use operator <code>%in%</code> to check a multiple equality condition.</p></li>
</ol>
</div>
<div class="footnotes slide">
<hr />
<ol>
<li id="fn1"><p><a href="https://www.iso.org/iso-8601-date-and-time-format.html" class="uri">https://www.iso.org/iso-8601-date-and-time-format.html</a><a href="#fnref1" class="footnote-back"></a></p></li>
</ol>
</div>

  <!-- dynamically load mathjax for compatibility with self-contained -->
  <script>
    (function () {
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
      document.getElementsByTagName("head")[0].appendChild(script);
    })();
  </script>

</body>
</html>
